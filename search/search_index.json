{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is property-utils?","text":"<p><code>property-utils</code> is a python library that aims at making programming with physical properties easier.  It was created to be used by scientists and engineers with little programming experience.</p> <p>What is provided by property-utils?</p>"},{"location":"#unit-arithmetics","title":"Unit arithmetics","text":"<p>You can divide and multiply units to create new units. For example you can create velocity units by dividing length units with time units.</p>"},{"location":"#unit-conversions","title":"Unit conversions","text":"<p>You can easily convert a property from one unit to another by calling a method.</p>"},{"location":"#property-arithmetics","title":"Property arithmetics","text":"<p>You can add, subtract, divide and multiply properties to create new properties. For example, you can create a density property by dividing a mass property with a volume property.</p> <p>If you're not sure what all the above mean, head to Usage to see examples of how they're used.</p>"},{"location":"converter_types/","title":"converter types","text":"<p>This module defines: Functions to fetch and register unit converters Unit converter protocol Base abstract classes for different types of unit converters  </p> <p>Converters implement a 2-step process to convert 'from_unit' to 'to_unit'. 1. Convert the 'from_unit' to a reference unit. 2. Convert the reference unit to the 'to_unit'.</p>"},{"location":"converter_types/#property_utils.units.converter_types.AbsoluteUnitConverter","title":"<code>AbsoluteUnitConverter</code>","text":"<p>Base converter class for measurement units that are absolute, i.e. not relative.</p> <p>e.g. Pressure units are absolute because the following applies: unit_i = unit_j * constant, where unit_i and unit_j can be any pressure units.</p> <p>Temperature units are not absolute because the above equation does not apply when converting from a relative temperature to an absolute temperature (e.g. from Celcius to Kelvin, or Fahrenheit to Rankine).</p> <p>Use the <code>register_converter</code> decorator when subclassing and define the <code>reference_unit</code> and <code>conversion_map</code> attributes. It does not matter what unit you shall choose to be the reference; although you have to define the conversion map accordingly. The conversion map is a dictionary that holds the conversion factors from the reference unit to other units. e.g. in the below example: 1 in = 2.54 cm</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class AbsoluteUnitConverter(metaclass=ABCMeta):\n    \"\"\"\n    Base converter class for measurement units that are absolute, i.e. not relative.\n\n    e.g.\n    Pressure units are absolute because the following applies:\n    unit_i = unit_j * constant,\n    where unit_i and unit_j can be any pressure units.\n\n    Temperature units are not absolute because the above equation does not apply when\n    converting from a relative temperature to an absolute temperature (e.g. from Celcius\n    to Kelvin, or Fahrenheit to Rankine).\n\n    Use the `register_converter` decorator when subclassing and define the\n    `reference_unit` and `conversion_map` attributes. It does not matter what unit you\n    shall choose to be the reference; although you have to define the conversion map\n    accordingly. The conversion map is a dictionary that holds the conversion factors\n    from the reference unit to other units. e.g. in the below example: 1 in = 2.54 cm\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n    \"\"\"\n\n    generic_unit_descriptor: MeasurementUnitType\n    reference_unit: MeasurementUnit\n    conversion_map: Dict[MeasurementUnit, float]\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from an absolute unit to another absolute unit.\n        Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n        an instance of the generic that is registered with the converter or if `value`\n        is not a numeric.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            ...     INCH = \"in\"\n\n            &gt;&gt;&gt; @register_converter(LengthUnit)\n            ... class LengthUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = LengthUnit.INCH\n            ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n            &gt;&gt;&gt; LengthUnitConverter.convert(2, LengthUnit.INCH, LengthUnit.CENTI_METER)\n            5.08\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n\n    @classmethod\n    def get_factor(\n        cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Get the multiplication factor for the conversion from `from_descriptor` to\n        `to_descriptor`.\n        Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n        an instance of the generic that is registered with the converter.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            ...     INCH = \"in\"\n\n            &gt;&gt;&gt; @register_converter(LengthUnit)\n            ... class LengthUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = LengthUnit.INCH\n            ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n            &gt;&gt;&gt; LengthUnitConverter.get_factor(LengthUnit.INCH, LengthUnit.CENTI_METER)\n            2.54\n        \"\"\"\n        if not from_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n            )\n        if not to_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n            )\n        from_unit = MeasurementUnit.from_descriptor(from_descriptor)\n\n        if isinstance(from_unit, AliasMeasurementUnit) and not isinstance(\n            to_descriptor, AliasMeasurementUnit\n        ):\n            return cls._get_aliased_factor(from_unit, to_descriptor)\n\n        to_unit = MeasurementUnit.from_descriptor(to_descriptor)\n        try:\n            return cls._to_reference(from_unit) * cls.conversion_map[to_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert to {to_unit}; unit is not registered in {cls.__name__}'s conversion map. \",\n            ) from None\n\n    @classmethod\n    def _to_reference(cls, from_unit: MeasurementUnit) -&gt; float:\n        try:\n            return 1 / cls.conversion_map[from_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert from {from_unit}; unit is not registered in {cls.__name__}'s conversion map. \",\n            ) from None\n\n    @classmethod\n    def _get_aliased_factor(\n        cls, from_unit: AliasMeasurementUnit, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Returns the conversion factor from an alias unit to its aliased.\n\n        The conversion happens in four steps:\n\n        1. Convert from the alias unit to the SI unit.\n        2. Convert from the SI unit to the aliased SI units (this step is not\n        implemented in code, because the conversion factor is 1)\n        3. Convert from the SI units to the target units.\n\n        e.g. if you want to convert from bar to kN/m^2:\n        1. bar -&gt; Pa\n        2. Pa -&gt; N/m^2 (conversion factor 1)\n        3. N/m^2 -&gt; kN/m^2\n        \"\"\"\n        step_1_factor = cls.get_factor(from_unit, from_unit.si())\n\n        converter = get_converter(to_descriptor.to_generic())\n\n        step_3_factor = converter.convert(\n            1, to_descriptor.to_generic().to_si(), to_descriptor\n        )\n\n        return step_1_factor * step_3_factor\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.AbsoluteUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from an absolute unit to another absolute unit. Raises <code>UnitConversionError</code> if <code>from_descriptor</code> or <code>to_descriptor</code> are not an instance of the generic that is registered with the converter or if <code>value</code> is not a numeric.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; LengthUnitConverter.convert(2, LengthUnit.INCH, LengthUnit.CENTI_METER)\n5.08\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from an absolute unit to another absolute unit.\n    Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n    an instance of the generic that is registered with the converter or if `value`\n    is not a numeric.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; LengthUnitConverter.convert(2, LengthUnit.INCH, LengthUnit.CENTI_METER)\n        5.08\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.AbsoluteUnitConverter.get_factor","title":"<code>get_factor(from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Get the multiplication factor for the conversion from <code>from_descriptor</code> to <code>to_descriptor</code>. Raises <code>UnitConversionError</code> if <code>from_descriptor</code> or <code>to_descriptor</code> are not an instance of the generic that is registered with the converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; LengthUnitConverter.get_factor(LengthUnit.INCH, LengthUnit.CENTI_METER)\n2.54\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef get_factor(\n    cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n) -&gt; float:\n    \"\"\"\n    Get the multiplication factor for the conversion from `from_descriptor` to\n    `to_descriptor`.\n    Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n    an instance of the generic that is registered with the converter.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; LengthUnitConverter.get_factor(LengthUnit.INCH, LengthUnit.CENTI_METER)\n        2.54\n    \"\"\"\n    if not from_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'from_descriptor; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n        )\n    if not to_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'to_descriptor'; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n        )\n    from_unit = MeasurementUnit.from_descriptor(from_descriptor)\n\n    if isinstance(from_unit, AliasMeasurementUnit) and not isinstance(\n        to_descriptor, AliasMeasurementUnit\n    ):\n        return cls._get_aliased_factor(from_unit, to_descriptor)\n\n    to_unit = MeasurementUnit.from_descriptor(to_descriptor)\n    try:\n        return cls._to_reference(from_unit) * cls.conversion_map[to_unit]\n    except KeyError:\n        raise UnitConversionError(\n            f\"cannot convert to {to_unit}; unit is not registered in {cls.__name__}'s conversion map. \",\n        ) from None\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.CompositeUnitConverter","title":"<code>CompositeUnitConverter</code>","text":"<p>Base converter for composite units.</p> <p>Use the <code>register_converter</code> decorator when subclassing. This converter requires the converters for the individual measurement units to be defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n...     MINUTE = \"min\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(TimeUnit)\n... class TimeUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = TimeUnit.MINUTE\n...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n... class VelocityUnitConverter(CompositeUnitConverter): ...\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class CompositeUnitConverter(metaclass=ABCMeta):\n    \"\"\"\n    Base converter for composite units.\n\n    Use the `register_converter` decorator when subclassing. This converter requires\n    the converters for the individual measurement units to be defined.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        ...     MINUTE = \"min\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(TimeUnit)\n        ... class TimeUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = TimeUnit.MINUTE\n        ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n        ... class VelocityUnitConverter(CompositeUnitConverter): ...\n    \"\"\"\n\n    generic_unit_descriptor: GenericUnitDescriptor\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from a composite unit to another composite unit.\n\n        Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n        an instance of the generic that is registered with the converter or if `value`\n        is not a numeric.\n\n        Raises `ConverterDependenciesError` if a converter for an invdividual unit has\n        not been defined/registered.\n\n        Raises `UnsupportedConverterError` if an individual unit is a relative unit.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            ...     INCH = \"in\"\n\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n            ...     MINUTE = \"min\"\n\n            &gt;&gt;&gt; @register_converter(LengthUnit)\n            ... class LengthUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = LengthUnit.INCH\n            ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n            &gt;&gt;&gt; @register_converter(TimeUnit)\n            ... class TimeUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = TimeUnit.MINUTE\n            ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n            &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n            ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n            &gt;&gt;&gt; VelocityUnitConverter.convert(100, LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.CENTI_METER/TimeUnit.SECOND)\n            254.0\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n\n    @classmethod\n    def get_factor(\n        cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Get the multiplication factor for the conversion from `from_descriptor` to\n        `to_descriptor`.\n\n        Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n        an instance of the generic that is registered with the converter.\n\n        Raises `ConverterDependenciesError` if a converter for an invdividual unit has\n        not been defined/registered.\n\n        Raises `UnsupportedConverterError` if an individual unit is a relative unit.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            ...     INCH = \"in\"\n\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n            ...     MINUTE = \"min\"\n\n            &gt;&gt;&gt; @register_converter(LengthUnit)\n            ... class LengthUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = LengthUnit.INCH\n            ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n            &gt;&gt;&gt; @register_converter(TimeUnit)\n            ... class TimeUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = TimeUnit.MINUTE\n            ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n            &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n            ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n            &gt;&gt;&gt; VelocityUnitConverter.get_factor(LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.INCH/TimeUnit.MINUTE)\n            60.0\n        \"\"\"\n        if not from_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n            )\n        if not to_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n            )\n\n        from_dimension = CompositeDimension.from_descriptor(from_descriptor)\n\n        if not to_descriptor.isinstance(from_descriptor.to_generic()):\n\n            if cls._is_alias(from_dimension, to_descriptor) or (\n                cls._is_aliased(from_dimension)\n            ):\n                return cls._get_aliased_factor(from_dimension, to_descriptor)\n\n        to_dimension = CompositeDimension.from_descriptor(to_descriptor)\n        return cls._get_numerator_factor(\n            from_dimension, to_dimension\n        ) / cls._get_denominator_factor(from_dimension, to_dimension)\n\n    @classmethod\n    def _get_numerator_factor(\n        cls, from_dimension: CompositeDimension, to_dimension: CompositeDimension\n    ) -&gt; float:\n        numerator_factor = 1.0\n        for from_d in from_dimension.numerator:\n            to_d = to_dimension.get_numerator(from_d.to_generic())\n            if to_d is None:\n                raise UnitConversionError(\n                    f\"cannot convert from {from_dimension} to {to_dimension}\"\n                )\n            try:\n                converter = get_converter(type(from_d.unit))\n            except UndefinedConverterError:\n                raise ConverterDependenciesError(\n                    f\"converter {cls.__name__} depends on a converter for \"\n                    f\"{type(from_d.unit)}. Did you forget to register \"\n                    f\" a converter for {type(from_d.unit)}? \"\n                ) from None\n            if not issubclass(converter, AbsoluteUnitConverter):\n                # NOTE: provide a link to documentation for the error.\n                raise UnsupportedConverterError(\n                    f\"converter {cls.__name__} is not supported since \"\n                    f\"{type(from_d.unit)} is not an absolute unit;\"\n                    \" conversion between composite relative units is invalid. \"\n                )\n            factor = (converter.get_factor(from_d.unit, to_d.unit)) ** from_d.power\n            numerator_factor *= factor\n        return numerator_factor\n\n    @classmethod\n    def _get_denominator_factor(\n        cls, from_dimension: CompositeDimension, to_dimension: CompositeDimension\n    ) -&gt; float:\n        denominator_factor = 1.0\n\n        for from_d in from_dimension.denominator:\n            to_d = to_dimension.get_denominator(from_d.to_generic())\n            if to_d is None:\n                raise UnitConversionError(\n                    f\"cannot convert from {from_dimension} to {to_dimension}\"\n                )\n            try:\n                converter = get_converter(type(from_d.unit))\n            except UndefinedConverterError:\n                raise ConverterDependenciesError(\n                    f\"converter {cls.__name__} depends on a converter for \"\n                    f\"{type(from_d.unit)}. Did you forget to register \"\n                    f\" a converter for {type(from_d.unit)}? \"\n                ) from None\n            if not issubclass(converter, AbsoluteUnitConverter):\n                # NOTE: provide a link to documentation for the error.\n                raise UnsupportedConverterError(\n                    f\"converter {cls.__name__} is not supported since \"\n                    f\"{type(from_d.unit)} is not an absolute unit;\"\n                    \" conversion between composite relative units is invalid. \"\n                )\n            factor = (converter.get_factor(from_d.unit, to_d.unit)) ** from_d.power\n            denominator_factor *= factor\n        return denominator_factor\n\n    @staticmethod\n    def _is_alias(\n        from_dimension: CompositeDimension, descriptor: UnitDescriptor\n    ) -&gt; bool:\n        \"\"\"\n        Returns True if the descriptor is an alias of the from_dimension.\n\n        Assumes that from_dimension and descriptor are both an instance of the\n        converter's generic unit descriptor.\n        \"\"\"\n        if isinstance(descriptor, AliasMeasurementUnit):\n            return True\n\n        if isinstance(descriptor, Dimension):\n            if isinstance(descriptor.unit, AliasMeasurementUnit):\n                return True\n\n            return False\n\n        if isinstance(descriptor, CompositeDimension):\n            for n in descriptor.numerator:\n                if from_dimension.get_numerator(n.to_generic(), None) is None:\n                    return True\n\n            for d in descriptor.denominator:\n                if from_dimension.get_denominator(d.to_generic(), None) is None:\n                    return True\n\n        return False\n\n    @staticmethod\n    def _is_aliased(dimension: CompositeDimension) -&gt; bool:\n        \"\"\"\n        Returns True if the dimension contains an alias, False otherwise.\n        \"\"\"\n        for n in dimension.numerator:\n            if isinstance(n.unit, AliasMeasurementUnit):\n                return True\n\n        for d in dimension.denominator:\n            if isinstance(d.unit, AliasMeasurementUnit):\n                return True\n\n        return False\n\n    @classmethod\n    def _get_aliased_factor(\n        cls, from_dimension: CompositeDimension, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Returns the conversion factor from an alias unit to its aliased.\n\n        The conversion happens in three steps:\n\n        1. Convert from the alias unit to the SI unit.\n        2. Convert from the SI unit to the aliased SI units (this step is not\n        implemented in code, because the conversion factor is 1)\n        3. Convert from the SI units to the target units.\n\n        e.g. if you want to convert from cal/K/s to kW/K:\n        1. cal/K/s -&gt; J/K/s\n        2. J/K/s -&gt; W/K (conversion factor 1)\n        3. W/K -&gt; kW/K\n        \"\"\"\n        step_1_factor = cls.get_factor(from_dimension, from_dimension.si())\n\n        converter = get_converter(to_descriptor.to_generic())\n\n        step_3_factor = converter.convert(\n            1, to_descriptor.to_generic().to_si(), to_descriptor\n        )\n\n        return step_1_factor * step_3_factor\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.CompositeUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from a composite unit to another composite unit.</p> <p>Raises <code>UnitConversionError</code> if <code>from_descriptor</code> or <code>to_descriptor</code> are not an instance of the generic that is registered with the converter or if <code>value</code> is not a numeric.</p> <p>Raises <code>ConverterDependenciesError</code> if a converter for an invdividual unit has not been defined/registered.</p> <p>Raises <code>UnsupportedConverterError</code> if an individual unit is a relative unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n...     MINUTE = \"min\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(TimeUnit)\n... class TimeUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = TimeUnit.MINUTE\n...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n... class VelocityUnitConverter(CompositeUnitConverter): ...\n</code></pre> <pre><code>&gt;&gt;&gt; VelocityUnitConverter.convert(100, LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.CENTI_METER/TimeUnit.SECOND)\n254.0\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from a composite unit to another composite unit.\n\n    Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n    an instance of the generic that is registered with the converter or if `value`\n    is not a numeric.\n\n    Raises `ConverterDependenciesError` if a converter for an invdividual unit has\n    not been defined/registered.\n\n    Raises `UnsupportedConverterError` if an individual unit is a relative unit.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        ...     MINUTE = \"min\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(TimeUnit)\n        ... class TimeUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = TimeUnit.MINUTE\n        ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n        ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n        &gt;&gt;&gt; VelocityUnitConverter.convert(100, LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.CENTI_METER/TimeUnit.SECOND)\n        254.0\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.CompositeUnitConverter.get_factor","title":"<code>get_factor(from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Get the multiplication factor for the conversion from <code>from_descriptor</code> to <code>to_descriptor</code>.</p> <p>Raises <code>UnitConversionError</code> if <code>from_descriptor</code> or <code>to_descriptor</code> are not an instance of the generic that is registered with the converter.</p> <p>Raises <code>ConverterDependenciesError</code> if a converter for an invdividual unit has not been defined/registered.</p> <p>Raises <code>UnsupportedConverterError</code> if an individual unit is a relative unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n...     MINUTE = \"min\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(TimeUnit)\n... class TimeUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = TimeUnit.MINUTE\n...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n... class VelocityUnitConverter(CompositeUnitConverter): ...\n</code></pre> <pre><code>&gt;&gt;&gt; VelocityUnitConverter.get_factor(LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.INCH/TimeUnit.MINUTE)\n60.0\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef get_factor(\n    cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n) -&gt; float:\n    \"\"\"\n    Get the multiplication factor for the conversion from `from_descriptor` to\n    `to_descriptor`.\n\n    Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n    an instance of the generic that is registered with the converter.\n\n    Raises `ConverterDependenciesError` if a converter for an invdividual unit has\n    not been defined/registered.\n\n    Raises `UnsupportedConverterError` if an individual unit is a relative unit.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        ...     MINUTE = \"min\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(TimeUnit)\n        ... class TimeUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = TimeUnit.MINUTE\n        ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n        ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n        &gt;&gt;&gt; VelocityUnitConverter.get_factor(LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.INCH/TimeUnit.MINUTE)\n        60.0\n    \"\"\"\n    if not from_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'from_descriptor; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n        )\n    if not to_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'to_descriptor'; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n        )\n\n    from_dimension = CompositeDimension.from_descriptor(from_descriptor)\n\n    if not to_descriptor.isinstance(from_descriptor.to_generic()):\n\n        if cls._is_alias(from_dimension, to_descriptor) or (\n            cls._is_aliased(from_dimension)\n        ):\n            return cls._get_aliased_factor(from_dimension, to_descriptor)\n\n    to_dimension = CompositeDimension.from_descriptor(to_descriptor)\n    return cls._get_numerator_factor(\n        from_dimension, to_dimension\n    ) / cls._get_denominator_factor(from_dimension, to_dimension)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.ExponentiatedUnitConverter","title":"<code>ExponentiatedUnitConverter</code>","text":"<p>Base converter for exponentiated absolute measurement units.</p> <p>Use the <code>register_converter</code> decorator when subclassing. This converter requires the converter for the measurement unit that is exponentiated to be defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit**2)\n... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class ExponentiatedUnitConverter(metaclass=ABCMeta):\n    \"\"\"\n    Base converter for exponentiated absolute measurement units.\n\n    Use the `register_converter` decorator when subclassing. This converter requires\n    the converter for the measurement unit that is exponentiated to be defined.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit**2)\n        ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n    \"\"\"\n\n    generic_unit_descriptor: GenericDimension\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from an absolute exponentiated unit to another absolute\n        exponentiated unit. In order to use this converter a converter must exist for\n        the base unit.\n\n        Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n        an instance of the generic that is registered with the converter or if `value`\n        is not a numeric.\n\n        Raises `ConverterDependenciesError` if a converter for the base unit has not\n        been defined/registered.\n\n        Raises `UnsupportedConverterError` if the base unit is a relative unit.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            ...     INCH = \"in\"\n\n            &gt;&gt;&gt; @register_converter(LengthUnit)\n            ... class LengthUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = LengthUnit.INCH\n            ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n            &gt;&gt;&gt; @register_converter(LengthUnit**2)\n            ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n            &gt;&gt;&gt; AreaUnitConverter.convert(10, LengthUnit.INCH**2, LengthUnit.CENTI_METER**2)\n            64.516\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n\n    @classmethod\n    def get_factor(\n        cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Get the multiplication factor for the conversion from `from_descriptor` to\n        `to_descriptor`.\n\n        Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n        an instance of the generic that is registered with the converter.\n\n        Raises `ConverterDependenciesError` if a converter for the base unit has not\n        been defined/registered.\n\n        Raises `UnsupportedConverterError` if the base unit is a relative unit.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            ...     INCH = \"in\"\n\n            &gt;&gt;&gt; @register_converter(LengthUnit)\n            ... class LengthUnitConverter(AbsoluteUnitConverter):\n            ...     reference_unit = LengthUnit.INCH\n            ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n            &gt;&gt;&gt; @register_converter(LengthUnit**2)\n            ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n            &gt;&gt;&gt; AreaUnitConverter.get_factor(LengthUnit.INCH**2, LengthUnit.CENTI_METER**2)\n            6.4516\n        \"\"\"\n        if not from_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n            )\n        if not to_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n            )\n        from_dimension = Dimension.from_descriptor(from_descriptor)\n\n        if not to_descriptor.isinstance(from_descriptor.to_generic()):\n            if isinstance(to_descriptor, AliasMeasurementUnit):\n                return cls._get_aliased_factor(from_dimension, to_descriptor)\n\n        to_dimension = Dimension.from_descriptor(to_descriptor)\n\n        try:\n            converter = get_converter(cls.generic_unit_descriptor.unit_type)\n        except UndefinedConverterError:\n            raise ConverterDependenciesError(\n                f\"converter {cls.__name__} depends on a converter for \"\n                f\"{cls.generic_unit_descriptor.unit_type}. Did you forget to register \"\n                f\" a converter for {cls.generic_unit_descriptor.unit_type}? \"\n            ) from None\n        if not issubclass(converter, AbsoluteUnitConverter):\n            # NOTE: provide a link to documentation for the error.\n            raise UnsupportedConverterError(\n                f\"converter {cls.__name__} is not supported since \"\n                f\"{cls.generic_unit_descriptor.unit_type} is not an absolute unit;\"\n                \" conversion between exponentiated relative units is invalid. \"\n            )\n        factor = converter.get_factor(from_dimension.unit, to_dimension.unit)\n        return factor**to_dimension.power\n\n    @classmethod\n    def _get_aliased_factor(\n        cls, from_dimension: Dimension, to_descriptor: AliasMeasurementUnit\n    ) -&gt; float:\n        \"\"\"\n        Returns the conversion factor from an alias unit to its aliased.\n\n        The conversion happens in three steps:\n\n        1. Convert from the alias unit to the SI unit.\n        2. Convert from the SI unit to the aliased SI units (this step is not\n        implemented in code, because the conversion factor is 1)\n        3. Convert from the aliased SI units to the target units.\n\n        e.g. if you want to convert from cm^3 to L:\n        1. cm^3 -&gt; m^3\n        2. m^3 -&gt; kL (conversion factor 1)\n        3. kL -&gt; L\n        \"\"\"\n        step_1_factor = cls.get_factor(from_dimension, from_dimension.si())\n\n        converter = get_converter(to_descriptor.to_generic())\n\n        step_3_factor = converter.convert(\n            1, to_descriptor.to_generic().to_si(), to_descriptor\n        )\n\n        return step_1_factor * step_3_factor\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.ExponentiatedUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from an absolute exponentiated unit to another absolute exponentiated unit. In order to use this converter a converter must exist for the base unit.</p> <p>Raises <code>UnitConversionError</code> if <code>from_descriptor</code> or <code>to_descriptor</code> are not an instance of the generic that is registered with the converter or if <code>value</code> is not a numeric.</p> <p>Raises <code>ConverterDependenciesError</code> if a converter for the base unit has not been defined/registered.</p> <p>Raises <code>UnsupportedConverterError</code> if the base unit is a relative unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit**2)\n... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n</code></pre> <pre><code>&gt;&gt;&gt; AreaUnitConverter.convert(10, LengthUnit.INCH**2, LengthUnit.CENTI_METER**2)\n64.516\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from an absolute exponentiated unit to another absolute\n    exponentiated unit. In order to use this converter a converter must exist for\n    the base unit.\n\n    Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n    an instance of the generic that is registered with the converter or if `value`\n    is not a numeric.\n\n    Raises `ConverterDependenciesError` if a converter for the base unit has not\n    been defined/registered.\n\n    Raises `UnsupportedConverterError` if the base unit is a relative unit.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit**2)\n        ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n        &gt;&gt;&gt; AreaUnitConverter.convert(10, LengthUnit.INCH**2, LengthUnit.CENTI_METER**2)\n        64.516\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.ExponentiatedUnitConverter.get_factor","title":"<code>get_factor(from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Get the multiplication factor for the conversion from <code>from_descriptor</code> to <code>to_descriptor</code>.</p> <p>Raises <code>UnitConversionError</code> if <code>from_descriptor</code> or <code>to_descriptor</code> are not an instance of the generic that is registered with the converter.</p> <p>Raises <code>ConverterDependenciesError</code> if a converter for the base unit has not been defined/registered.</p> <p>Raises <code>UnsupportedConverterError</code> if the base unit is a relative unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n...     INCH = \"in\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit)\n... class LengthUnitConverter(AbsoluteUnitConverter):\n...     reference_unit = LengthUnit.INCH\n...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(LengthUnit**2)\n... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n</code></pre> <pre><code>&gt;&gt;&gt; AreaUnitConverter.get_factor(LengthUnit.INCH**2, LengthUnit.CENTI_METER**2)\n6.4516\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef get_factor(\n    cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n) -&gt; float:\n    \"\"\"\n    Get the multiplication factor for the conversion from `from_descriptor` to\n    `to_descriptor`.\n\n    Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n    an instance of the generic that is registered with the converter.\n\n    Raises `ConverterDependenciesError` if a converter for the base unit has not\n    been defined/registered.\n\n    Raises `UnsupportedConverterError` if the base unit is a relative unit.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit**2)\n        ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n        &gt;&gt;&gt; AreaUnitConverter.get_factor(LengthUnit.INCH**2, LengthUnit.CENTI_METER**2)\n        6.4516\n    \"\"\"\n    if not from_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'from_descriptor; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n        )\n    if not to_descriptor.isinstance_equivalent(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'to_descriptor'; expected an instance-equivalent of {cls.generic_unit_descriptor}. \"\n        )\n    from_dimension = Dimension.from_descriptor(from_descriptor)\n\n    if not to_descriptor.isinstance(from_descriptor.to_generic()):\n        if isinstance(to_descriptor, AliasMeasurementUnit):\n            return cls._get_aliased_factor(from_dimension, to_descriptor)\n\n    to_dimension = Dimension.from_descriptor(to_descriptor)\n\n    try:\n        converter = get_converter(cls.generic_unit_descriptor.unit_type)\n    except UndefinedConverterError:\n        raise ConverterDependenciesError(\n            f\"converter {cls.__name__} depends on a converter for \"\n            f\"{cls.generic_unit_descriptor.unit_type}. Did you forget to register \"\n            f\" a converter for {cls.generic_unit_descriptor.unit_type}? \"\n        ) from None\n    if not issubclass(converter, AbsoluteUnitConverter):\n        # NOTE: provide a link to documentation for the error.\n        raise UnsupportedConverterError(\n            f\"converter {cls.__name__} is not supported since \"\n            f\"{cls.generic_unit_descriptor.unit_type} is not an absolute unit;\"\n            \" conversion between exponentiated relative units is invalid. \"\n        )\n    factor = converter.get_factor(from_dimension.unit, to_dimension.unit)\n    return factor**to_dimension.power\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.RelativeUnitConverter","title":"<code>RelativeUnitConverter</code>","text":"<p>Base converter class for measurement units that are relative.</p> <p>e.g. Temperature units are relative because conversion from one unit to another is not necessarily performed with multiplication with a single factor.</p> <p>Use the <code>register_converter</code> decorator when subclassing and define the <code>reference_unit</code>, <code>conversion_map</code> and <code>reference_conversion_map</code> attributes. It does not matter what unit you shall choose to be the reference; although you have to define the conversion map and reference conversion map accordingly. The conversion map is a dictionary that holds the conversion functions that convert other units to the reference unit. The reference conversion map is a dictionary that holds the conversion functions that convert the reference unit to other units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"\u00b0C\"\n...     FAHRENHEIT = \"\u00b0F\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(TemperatureUnit)\n... class TemperatureUnitConverter(RelativeUnitConverter):\n...     reference_unit = TemperatureUnit.CELCIUS\n...     conversion_map = {\n...             TemperatureUnit.CELCIUS: lambda t: t,\n...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n...                 }\n...     reference_conversion_map = {\n...             TemperatureUnit.CELCIUS: lambda t: t,\n...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n...                 }\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class RelativeUnitConverter(\n    metaclass=ABCMeta\n):  # pylint: disable=too-few-public-methods\n    \"\"\"\n    Base converter class for measurement units that are relative.\n\n    e.g. Temperature units are relative because conversion from one unit to another\n    is not necessarily performed with multiplication with a single factor.\n\n    Use the `register_converter` decorator when subclassing and define the\n    `reference_unit`, `conversion_map` and `reference_conversion_map` attributes. It\n    does not matter what unit you shall choose to be the reference; although you have to\n    define the conversion map and reference conversion map accordingly. The conversion\n    map is a dictionary that holds the conversion functions that convert other units to\n    the reference unit. The reference conversion map is a dictionary that holds the\n    conversion functions that convert the reference unit to other units.\n\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"\u00b0C\"\n        ...     FAHRENHEIT = \"\u00b0F\"\n\n        &gt;&gt;&gt; @register_converter(TemperatureUnit)\n        ... class TemperatureUnitConverter(RelativeUnitConverter):\n        ...     reference_unit = TemperatureUnit.CELCIUS\n        ...     conversion_map = {\n        ...             TemperatureUnit.CELCIUS: lambda t: t,\n        ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n        ...                 }\n        ...     reference_conversion_map = {\n        ...             TemperatureUnit.CELCIUS: lambda t: t,\n        ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n        ...                 }\n    \"\"\"\n\n    generic_unit_descriptor: MeasurementUnitType\n    reference_unit: MeasurementUnit\n    reference_conversion_map: Dict[MeasurementUnit, Callable[[float], float]]\n    conversion_map: Dict[MeasurementUnit, Callable[[float], float]]\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from a relative unit to another relative unit.\n\n        Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n        an instance of the generic that is registered with the converter or if `value`\n        is not a numeric.\n\n        Raises `ConversionFunctionError` if an error occurs when calling a function\n        provided in the conversion_map or reference_conversion_map.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"\u00b0C\"\n            ...     FAHRENHEIT = \"\u00b0F\"\n\n            &gt;&gt;&gt; @register_converter(TemperatureUnit)\n            ... class TemperatureUnitConverter(RelativeUnitConverter):\n            ...     reference_unit = TemperatureUnit.CELCIUS\n            ...     conversion_map = {\n            ...             TemperatureUnit.CELCIUS: lambda t: t,\n            ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n            ...                 }\n            ...     reference_conversion_map = {\n            ...             TemperatureUnit.CELCIUS: lambda t: t,\n            ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n            ...                 }\n\n            &gt;&gt;&gt; TemperatureUnitConverter.convert(100, TemperatureUnit.CELCIUS, TemperatureUnit.FAHRENHEIT)\n            212.0\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return cls._from_reference(\n            cls._to_reference(value, from_descriptor), to_descriptor\n        )\n\n    @classmethod\n    def _to_reference(cls, value: float, from_descriptor: UnitDescriptor) -&gt; float:\n        if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        from_unit = MeasurementUnit.from_descriptor(from_descriptor)\n        try:\n            conversion_func = cls.conversion_map[from_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert from {from_unit}; unit is not in {cls.__name__}'s conversion map. \",\n            ) from None\n        try:\n            return conversion_func(value)\n        except Exception as exc:\n            raise ConversionFunctionError(\n                f\"an error occured in a conversion function of {cls.__name__}. \", exc\n            ) from exc\n\n    @classmethod\n    def _from_reference(cls, value: float, to_descriptor: UnitDescriptor) -&gt; float:\n        if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        to_unit = MeasurementUnit.from_descriptor(to_descriptor)\n        try:\n            conversion_func = cls.reference_conversion_map[to_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert to {to_unit}; unit is not registered in {cls.__name__}'s reference conversion map. \",\n            ) from None\n        try:\n            return conversion_func(value)\n        except Exception as exc:\n            raise ConversionFunctionError(\n                f\"an error occured in a conversion function of {cls.__name__}. \", exc\n            ) from exc\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.RelativeUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from a relative unit to another relative unit.</p> <p>Raises <code>UnitConversionError</code> if <code>from_descriptor</code> or <code>to_descriptor</code> are not an instance of the generic that is registered with the converter or if <code>value</code> is not a numeric.</p> <p>Raises <code>ConversionFunctionError</code> if an error occurs when calling a function provided in the conversion_map or reference_conversion_map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"\u00b0C\"\n...     FAHRENHEIT = \"\u00b0F\"\n</code></pre> <pre><code>&gt;&gt;&gt; @register_converter(TemperatureUnit)\n... class TemperatureUnitConverter(RelativeUnitConverter):\n...     reference_unit = TemperatureUnit.CELCIUS\n...     conversion_map = {\n...             TemperatureUnit.CELCIUS: lambda t: t,\n...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n...                 }\n...     reference_conversion_map = {\n...             TemperatureUnit.CELCIUS: lambda t: t,\n...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n...                 }\n</code></pre> <pre><code>&gt;&gt;&gt; TemperatureUnitConverter.convert(100, TemperatureUnit.CELCIUS, TemperatureUnit.FAHRENHEIT)\n212.0\n</code></pre> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from a relative unit to another relative unit.\n\n    Raises `UnitConversionError` if `from_descriptor` or `to_descriptor` are not\n    an instance of the generic that is registered with the converter or if `value`\n    is not a numeric.\n\n    Raises `ConversionFunctionError` if an error occurs when calling a function\n    provided in the conversion_map or reference_conversion_map.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"\u00b0C\"\n        ...     FAHRENHEIT = \"\u00b0F\"\n\n        &gt;&gt;&gt; @register_converter(TemperatureUnit)\n        ... class TemperatureUnitConverter(RelativeUnitConverter):\n        ...     reference_unit = TemperatureUnit.CELCIUS\n        ...     conversion_map = {\n        ...             TemperatureUnit.CELCIUS: lambda t: t,\n        ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n        ...                 }\n        ...     reference_conversion_map = {\n        ...             TemperatureUnit.CELCIUS: lambda t: t,\n        ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n        ...                 }\n\n        &gt;&gt;&gt; TemperatureUnitConverter.convert(100, TemperatureUnit.CELCIUS, TemperatureUnit.FAHRENHEIT)\n        212.0\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return cls._from_reference(\n        cls._to_reference(value, from_descriptor), to_descriptor\n    )\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.UnitConverter","title":"<code>UnitConverter</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Protocol of classes that convert a value from one unit to another.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class UnitConverter(Protocol):  # pylint: disable=too-few-public-methods\n    \"\"\"Protocol of classes that convert a value from one unit to another.\"\"\"\n\n    generic_unit_descriptor: GenericUnitDescriptor\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from a unit descriptor to its' corresponding value in a\n        different unit descriptor.\n        \"\"\"\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.UnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from a unit descriptor to its' corresponding value in a different unit descriptor.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from a unit descriptor to its' corresponding value in a\n    different unit descriptor.\n    \"\"\"\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.get_converter","title":"<code>get_converter(generic)</code>","text":"<p>Get converter for given generic descriptor.</p> <p>Raises <code>PropertyUtilsTypeError</code> if argument is not a generic unit descriptor.</p> <p>Raises <code>UndefinedConverterError</code> if a converter has not been defined for the given generic.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>def get_converter(generic: GenericUnitDescriptor) -&gt; ConverterType:\n    \"\"\"\n    Get converter for given generic descriptor.\n\n    Raises `PropertyUtilsTypeError` if argument is not a generic unit descriptor.\n\n    Raises `UndefinedConverterError` if a converter has not been defined for the given generic.\n    \"\"\"\n    if not isinstance(\n        generic, (MeasurementUnitType, GenericDimension, GenericCompositeDimension)\n    ):\n        raise PropertyUtilsTypeError(\n            f\"cannot get converter; argument: {generic} is not a generic unit descriptor. \"\n        )\n    if isinstance(generic, GenericDimension) and generic.power == 1:\n        generic = generic.unit_type\n    elif isinstance(generic, GenericDimension) and generic not in _converters:\n        register_converter(generic)(\n            type(f\"{generic}_Converter\", (ExponentiatedUnitConverter,), {})\n        )\n    elif isinstance(generic, GenericCompositeDimension) and generic not in _converters:\n        register_converter(generic)(\n            type(f\"{generic}_Converter\", (CompositeUnitConverter,), {})\n        )\n    try:\n        return _converters[generic]\n    except KeyError:\n        raise UndefinedConverterError(\n            f\"a converter has not been defined for {generic}\"\n        ) from None\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.register_converter","title":"<code>register_converter(generic)</code>","text":"<p>Decorate a converter class to register the generic descriptor of the units it operates on. This decorator also sets the 'generic_unit_descriptor' attribute of the decorated class.</p> <p>Raises <code>PropertyUtilsTypeError</code> if argument is not a generic unit descriptor.</p> <p>Raises <code>PropertyUtilsValueError</code> if generic has already a converter registered.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>def register_converter(generic: GenericUnitDescriptor) -&gt; Callable:\n    \"\"\"\n    Decorate a converter class to register the generic descriptor of the units it\n    operates on.\n    This decorator also sets the 'generic_unit_descriptor' attribute of the decorated\n    class.\n\n    Raises `PropertyUtilsTypeError` if argument is not a generic unit descriptor.\n\n    Raises `PropertyUtilsValueError` if generic has already a converter registered.\n    \"\"\"\n    if not isinstance(\n        generic, (MeasurementUnitType, GenericDimension, GenericCompositeDimension)\n    ):\n        raise PropertyUtilsTypeError(\n            f\"cannot get converter; argument: {generic} is not a generic unit descriptor. \"\n        )\n\n    if generic in _converters:\n        raise PropertyUtilsValueError(\n            f\"cannot register converter twice; {generic} has already got a converter. \"\n        )\n\n    def wrapper(cls: ConverterType) -&gt; ConverterType:\n        _converters[generic] = cls\n        cls.generic_unit_descriptor = generic\n        return cls\n\n    return wrapper\n</code></pre>"},{"location":"converters/","title":"converters","text":"<p>This module defines unit converters for the units in 'property_utils.units.units' as well as some converters for common exponentiated units (area and volume).</p>"},{"location":"converters/#property_utils.units.converters.AbsoluteTemperatureUnitConverter","title":"<code>AbsoluteTemperatureUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert absolute temperature with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AbsoluteTemperatureUnitConverter.convert(10, AbsoluteTemperatureUnit.KELVIN, AbsoluteTemperatureUnit.RANKINE)\n18.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(AbsoluteTemperatureUnit)\nclass AbsoluteTemperatureUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert absolute temperature with this converter.\n\n    Examples:\n        &gt;&gt;&gt; AbsoluteTemperatureUnitConverter.convert(10, AbsoluteTemperatureUnit.KELVIN, AbsoluteTemperatureUnit.RANKINE)\n        18.0\n    \"\"\"\n\n    reference_unit = AbsoluteTemperatureUnit.KELVIN\n    conversion_map = {\n        AbsoluteTemperatureUnit.KELVIN: 1,\n        AbsoluteTemperatureUnit.RANKINE: 1.8,\n    }\n\n    @override\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        if from_descriptor.isinstance(\n            RelativeTemperatureUnit\n        ) or to_descriptor.isinstance(RelativeTemperatureUnit):\n            return RelativeTemperatureUnitConverter.convert(\n                value, from_descriptor, to_descriptor\n            )\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasEnergyUnitConverter","title":"<code>AliasEnergyUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert energy units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AliasEnergyUnitConverter.convert(2500, EnergyUnit.JOULE, EnergyUnit.KILO_JOULE)\n2.5\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(EnergyUnit)\nclass AliasEnergyUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert energy units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; AliasEnergyUnitConverter.convert(2500, EnergyUnit.JOULE, EnergyUnit.KILO_JOULE)\n        2.5\n    \"\"\"\n\n    reference_unit = EnergyUnit.JOULE\n    conversion_map = {\n        EnergyUnit.JOULE: 1,\n        EnergyUnit.KILO_JOULE: UnitPrefix.KILO.inverse(),\n        EnergyUnit.MEGA_JOULE: UnitPrefix.MEGA.inverse(),\n        EnergyUnit.GIGA_JOULE: UnitPrefix.GIGA.inverse(),\n        EnergyUnit.CALORIE: 1 / 4.184,\n        EnergyUnit.KILO_CALORIE: (1 / 4.184) * UnitPrefix.KILO.inverse(),\n        EnergyUnit.BTU: 1 / 1055.0,\n        EnergyUnit.ELECTRONVOLT: 6.242e18,\n        EnergyUnit.WATTHOUR: 1 / 3600,\n        EnergyUnit.KILO_WATTHOUR: (1 / 3600) * UnitPrefix.KILO.inverse(),\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasForceUnitConverter","title":"<code>AliasForceUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert force units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AliasForceUnitConverter.convert(2, ForceUnit.NEWTON, ForceUnit.DYNE)\n200000.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(ForceUnit)\nclass AliasForceUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert force units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; AliasForceUnitConverter.convert(2, ForceUnit.NEWTON, ForceUnit.DYNE)\n        200000.0\n    \"\"\"\n\n    reference_unit = ForceUnit.NEWTON\n    conversion_map = {ForceUnit.NEWTON: 1, ForceUnit.DYNE: 100_000}\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasPowerUnitConverter","title":"<code>AliasPowerUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert power units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AliasPowerUnitConverter.convert(5, PowerUnit.KILO_WATT, PowerUnit.WATT)\n5000.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PowerUnit)\nclass AliasPowerUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert power units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; AliasPowerUnitConverter.convert(5, PowerUnit.KILO_WATT, PowerUnit.WATT)\n        5000.0\n    \"\"\"\n\n    reference_unit = PowerUnit.WATT\n    conversion_map = {\n        PowerUnit.WATT: 1,\n        PowerUnit.KILO_WATT: UnitPrefix.KILO.inverse(),\n        PowerUnit.MEGA_WATT: UnitPrefix.MEGA.inverse(),\n        PowerUnit.GIGA_WATT: UnitPrefix.GIGA.inverse(),\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasPressureUnitConverter","title":"<code>AliasPressureUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert pressure units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AliasPressureUnitConverter.convert(2, PressureUnit.BAR, PressureUnit.KILO_PASCAL)\n200.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PressureUnit)\nclass AliasPressureUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert pressure units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; AliasPressureUnitConverter.convert(2, PressureUnit.BAR, PressureUnit.KILO_PASCAL)\n        200.0\n    \"\"\"\n\n    reference_unit = PressureUnit.BAR\n    conversion_map = {\n        PressureUnit.MILLI_BAR: UnitPrefix.MILLI.inverse(),\n        PressureUnit.BAR: 1,\n        PressureUnit.PSI: 14.5038,\n        PressureUnit.PASCAL: 100_000,\n        PressureUnit.KILO_PASCAL: 100,\n        PressureUnit.MEGA_PASCAL: 0.1,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AmountUnitConverter","title":"<code>AmountUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert amount units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AmountUnitConverter.convert(2000, AmountUnit.MOL, AmountUnit.KILO_MOL)\n2.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(AmountUnit)\nclass AmountUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert amount units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; AmountUnitConverter.convert(2000, AmountUnit.MOL, AmountUnit.KILO_MOL)\n        2.0\n    \"\"\"\n\n    reference_unit = AmountUnit.MOL\n    conversion_map = {AmountUnit.MOL: 1, AmountUnit.KILO_MOL: UnitPrefix.KILO.inverse()}\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AreaUnitConverter","title":"<code>AreaUnitConverter</code>","text":"<p>             Bases: <code>ExponentiatedUnitConverter</code></p> <p>Convert area units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AreaUnitConverter.convert(1, LengthUnit.METER**2, LengthUnit.CENTI_METER**2)\n10000.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(LengthUnit**2)\nclass AreaUnitConverter(ExponentiatedUnitConverter):\n    \"\"\"\n    Convert area units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; AreaUnitConverter.convert(1, LengthUnit.METER**2, LengthUnit.CENTI_METER**2)\n        10000.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.ElectricCurrentUnitConverter","title":"<code>ElectricCurrentUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert electric current units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ElectricCurrentUnitConverter.convert(1000, ElectricCurrentUnit.MILLI_AMPERE, ElectricCurrentUnit.AMPERE)\n1.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(ElectricCurrentUnit)\nclass ElectricCurrentUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert electric current units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; ElectricCurrentUnitConverter.convert(1000, ElectricCurrentUnit.MILLI_AMPERE, ElectricCurrentUnit.AMPERE)\n        1.0\n    \"\"\"\n\n    reference_unit = ElectricCurrentUnit.AMPERE\n    conversion_map = {\n        ElectricCurrentUnit.MILLI_AMPERE: UnitPrefix.MILLI.inverse(),\n        ElectricCurrentUnit.AMPERE: 1,\n        ElectricCurrentUnit.KILO_AMPERE: UnitPrefix.KILO.inverse(),\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.EnergyUnitConverter","title":"<code>EnergyUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert energy units (mass * length^2 / time^2) with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER**2) / (TimeUnit.MINUTE**2)\n&gt;&gt;&gt; to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER**2) / (TimeUnit.MINUTE**2)\n&gt;&gt;&gt; EnergyUnitConverter.convert(25, from_unit, to_unit)\n250.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(EnergyUnit.aliased_generic_descriptor())\nclass EnergyUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert energy units (mass * length^2 / time^2) with this converter.\n\n    Examples:\n        &gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER**2) / (TimeUnit.MINUTE**2)\n        &gt;&gt;&gt; to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER**2) / (TimeUnit.MINUTE**2)\n        &gt;&gt;&gt; EnergyUnitConverter.convert(25, from_unit, to_unit)\n        250.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.ForceUnitConverter","title":"<code>ForceUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert force units (mass * length / time^2) with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * LengthUnit.CENTI_METER / (TimeUnit.SECOND**2)\n&gt;&gt;&gt; to_unit = MassUnit.GRAM * LengthUnit.METER / (TimeUnit.SECOND**2)\n&gt;&gt;&gt; ForceUnitConverter.convert(100, from_unit, to_unit)\n1000.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(ForceUnit.aliased_generic_descriptor())\nclass ForceUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert force units (mass * length / time^2) with this converter.\n\n    Examples:\n        &gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * LengthUnit.CENTI_METER / (TimeUnit.SECOND**2)\n        &gt;&gt;&gt; to_unit = MassUnit.GRAM * LengthUnit.METER / (TimeUnit.SECOND**2)\n        &gt;&gt;&gt; ForceUnitConverter.convert(100, from_unit, to_unit)\n        1000.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.LengthUnitConverter","title":"<code>LengthUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert length units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; LengthUnitConverter.convert(2000, LengthUnit.MILLI_METER, LengthUnit.METER)\n2.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(LengthUnit)\nclass LengthUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert length units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; LengthUnitConverter.convert(2000, LengthUnit.MILLI_METER, LengthUnit.METER)\n        2.0\n    \"\"\"\n\n    reference_unit = LengthUnit.METER\n    conversion_map = {\n        LengthUnit.MILLI_METER: UnitPrefix.MILLI.inverse(),\n        LengthUnit.CENTI_METER: UnitPrefix.CENTI.inverse(),\n        LengthUnit.METER: 1,\n        LengthUnit.KILO_METER: UnitPrefix.KILO.inverse(),\n        LengthUnit.INCH: 39.37,\n        LengthUnit.FOOT: 3.281,\n        LengthUnit.YARD: 1.094,\n        LengthUnit.MILE: 1 / 1609,\n        LengthUnit.NAUTICAL_MILE: 1 / 1852,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.MassUnitConverter","title":"<code>MassUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert mass units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MassUnitConverter.convert(10, MassUnit.KILO_GRAM, MassUnit.GRAM)\n10000.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(MassUnit)\nclass MassUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert mass units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; MassUnitConverter.convert(10, MassUnit.KILO_GRAM, MassUnit.GRAM)\n        10000.0\n    \"\"\"\n\n    reference_unit = MassUnit.KILO_GRAM\n    conversion_map = {\n        MassUnit.MILLI_GRAM: UnitPrefix.KILO * UnitPrefix.MILLI.inverse(),\n        MassUnit.GRAM: UnitPrefix.KILO,\n        MassUnit.KILO_GRAM: 1,\n        MassUnit.METRIC_TONNE: 1 / 1_000.0,\n        MassUnit.POUND: 2.205,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.PowerUnitConverter","title":"<code>PowerUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert power units (mass * length^2 / time^3) with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER**2) / (TimeUnit.MINUTE**3)\n&gt;&gt;&gt; to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER**2) / (TimeUnit.MINUTE**3)\n&gt;&gt;&gt; PowerUnitConverter.convert(15, from_unit, to_unit)\n150.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PowerUnit.aliased_generic_descriptor())\nclass PowerUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert power units (mass * length^2 / time^3) with this converter.\n\n    Examples:\n        &gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER**2) / (TimeUnit.MINUTE**3)\n        &gt;&gt;&gt; to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER**2) / (TimeUnit.MINUTE**3)\n        &gt;&gt;&gt; PowerUnitConverter.convert(15, from_unit, to_unit)\n        150.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.PressureUnitConverter","title":"<code>PressureUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert pressure units (mass / length / time^2) with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from_unit = MassUnit.GRAM / LengthUnit.CENTI_METER / (TimeUnit.HOUR**2)\n&gt;&gt;&gt; to_unit = MassUnit.KILO_GRAM / LengthUnit.METER / (TimeUnit.HOUR**2)\n&gt;&gt;&gt; PressureUnitConverter.convert(50, from_unit, to_unit)\n5.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PressureUnit.aliased_generic_descriptor())\nclass PressureUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert pressure units (mass / length / time^2) with this converter.\n\n    Examples:\n        &gt;&gt;&gt; from_unit = MassUnit.GRAM / LengthUnit.CENTI_METER / (TimeUnit.HOUR**2)\n        &gt;&gt;&gt; to_unit = MassUnit.KILO_GRAM / LengthUnit.METER / (TimeUnit.HOUR**2)\n        &gt;&gt;&gt; PressureUnitConverter.convert(50, from_unit, to_unit)\n        5.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.RelativeTemperatureUnitConverter","title":"<code>RelativeTemperatureUnitConverter</code>","text":"<p>             Bases: <code>RelativeUnitConverter</code></p> <p>Convert temperature units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; RelativeTemperatureUnitConverter.convert(100, RelativeTemperatureUnit.CELCIUS, RelativeTemperatureUnit.FAHRENHEIT)\n212.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(RelativeTemperatureUnit)\nclass RelativeTemperatureUnitConverter(\n    RelativeUnitConverter\n):  # pylint: disable=too-few-public-methods\n    \"\"\"\n    Convert temperature units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; RelativeTemperatureUnitConverter.convert(100, RelativeTemperatureUnit.CELCIUS, RelativeTemperatureUnit.FAHRENHEIT)\n        212.0\n    \"\"\"\n\n    reference_unit = RelativeTemperatureUnit.CELCIUS\n    conversion_map = {\n        RelativeTemperatureUnit.CELCIUS: lambda t: t,\n        AbsoluteTemperatureUnit.KELVIN: lambda t: t - 273.15,\n        RelativeTemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n        AbsoluteTemperatureUnit.RANKINE: lambda t: (t / 1.8) - 273.15,\n    }\n    reference_conversion_map = {\n        RelativeTemperatureUnit.CELCIUS: lambda t: t,\n        AbsoluteTemperatureUnit.KELVIN: lambda t: t + 273.15,\n        RelativeTemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n        AbsoluteTemperatureUnit.RANKINE: lambda t: (t + 273.15) * 1.8,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.TimeUnitConverter","title":"<code>TimeUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert time units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TimeUnitConverter.convert(1, TimeUnit.HOUR, TimeUnit.SECOND)\n3600.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(TimeUnit)\nclass TimeUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert time units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; TimeUnitConverter.convert(1, TimeUnit.HOUR, TimeUnit.SECOND)\n        3600.0\n    \"\"\"\n\n    reference_unit = TimeUnit.SECOND\n    conversion_map = {\n        TimeUnit.MILLI_SECOND: UnitPrefix.MILLI.inverse(),\n        TimeUnit.SECOND: 1,\n        TimeUnit.MINUTE: 1 / 60.0,\n        TimeUnit.HOUR: 1 / 60.0 / 60.0,\n        TimeUnit.DAY: 1 / 60.0 / 60.0 / 24.0,\n        TimeUnit.WEEK: 1 / 60.0 / 60.0 / 24.0 / 7,\n        TimeUnit.MONTH: 1 / 60.0 / 60.0 / 24.0 / (365 / 12),\n        TimeUnit.YEAR: 1 / 60.0 / 60.0 / 24.0 / 365,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.UnitPrefix","title":"<code>UnitPrefix</code>","text":"<p>             Bases: <code>float</code>, <code>Enum</code></p> <p>Enumeration of unit prefixes. Handy when converting to and fro prefixed units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; centimeters = 225\n&gt;&gt;&gt; meters = centimeters * UnitPrefix.CENTI\n&gt;&gt;&gt; meters\n2.25\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>class UnitPrefix(float, Enum):\n    \"\"\"\n    Enumeration of unit prefixes.\n    Handy when converting to and fro prefixed units.\n\n    Examples:\n        &gt;&gt;&gt; centimeters = 225\n        &gt;&gt;&gt; meters = centimeters * UnitPrefix.CENTI\n        &gt;&gt;&gt; meters\n        2.25\n    \"\"\"\n\n    PICO = 1e-12\n    NANO = 1e-9\n    MICRO = 1e-6\n    MILLI = 1e-3\n    CENTI = 1e-2\n    DECI = 1e-1\n    DECA = 1e1\n    HECTO = 1e2\n    KILO = 1e3\n    MEGA = 1e6\n    GIGA = 1e9\n    TERA = 1e12\n\n    def inverse(self) -&gt; float:\n        \"\"\"\n        Return the inverse of the unit prefix. Use when prefixing a unit.\n\n        Examples:\n            &gt;&gt;&gt; meters = 50.26\n            &gt;&gt;&gt; centimeters = meters * UnitPrefix.CENTI.inverse()\n            &gt;&gt;&gt; centimeters\n            5026.0\n        \"\"\"\n        return 1 / self.value\n</code></pre>"},{"location":"converters/#property_utils.units.converters.UnitPrefix.inverse","title":"<code>inverse()</code>","text":"<p>Return the inverse of the unit prefix. Use when prefixing a unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; meters = 50.26\n&gt;&gt;&gt; centimeters = meters * UnitPrefix.CENTI.inverse()\n&gt;&gt;&gt; centimeters\n5026.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>def inverse(self) -&gt; float:\n    \"\"\"\n    Return the inverse of the unit prefix. Use when prefixing a unit.\n\n    Examples:\n        &gt;&gt;&gt; meters = 50.26\n        &gt;&gt;&gt; centimeters = meters * UnitPrefix.CENTI.inverse()\n        &gt;&gt;&gt; centimeters\n        5026.0\n    \"\"\"\n    return 1 / self.value\n</code></pre>"},{"location":"converters/#property_utils.units.converters.VolumeUnitConverter","title":"<code>VolumeUnitConverter</code>","text":"<p>             Bases: <code>ExponentiatedUnitConverter</code></p> <p>Convert volume units with this converter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; VolumeUnitConverter.convert(1, LengthUnit.METER**3, LengthUnit.CENTI_METER**3)\n1000000.0\n</code></pre> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(LengthUnit**3)\nclass VolumeUnitConverter(ExponentiatedUnitConverter):\n    \"\"\"\n    Convert volume units with this converter.\n\n    Examples:\n        &gt;&gt;&gt; VolumeUnitConverter.convert(1, LengthUnit.METER**3, LengthUnit.CENTI_METER**3)\n        1000000.0\n    \"\"\"\n</code></pre>"},{"location":"descriptors/","title":"descriptors","text":"<p>This module includes definitions for generic unit descriptors and unit descriptors.</p> <p>A unit descriptor is an interface that describes a measurement unit. It can represent anything like \u00b0C, m^3, mol/m^3/s etc.</p> <p>A generic unit descriptor is an interface that describes a generic measurement unit. It can represent e.g. a temperature unit, a volume unit, a reaction rate unit etc.</p>"},{"location":"descriptors/#property_utils.units.descriptors.AliasMeasurementUnit","title":"<code>AliasMeasurementUnit</code>","text":"<p>             Bases: <code>MeasurementUnit</code></p> <p>Base class for common composite units of physical quantities.</p> <p>Subclasses of <code>MeasurementUnit</code> represent only primitive physical quantities. However, many common physical properties have composite units (e.g. pressure, force, energy, etc), thus subclasses of this class alias composite units as primitive ones.</p> <p>Only very common composite units should be aliased.</p> <p>e.g. you can create an alias for pressure units, instead of using mass * length / (     time^2) units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n...     BAR = \"bar\"\n...     PASCAL = \"Pa\"\n...     KILO_PASCAL = \"kPa\"\n...     PSI = \"psi\"\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class AliasMeasurementUnit(MeasurementUnit):\n    \"\"\"\n    Base class for common composite units of physical quantities.\n\n    Subclasses of `MeasurementUnit` represent only primitive physical quantities.\n    However, many common physical properties have composite units (e.g. pressure, force,\n    energy, etc), thus subclasses of this class alias composite units as primitive ones.\n\n    Only very common composite units should be aliased.\n\n    e.g. you can create an alias for pressure units, instead of using mass * length / (\n        time^2) units.\n\n    Examples:\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     BAR = \"bar\"\n        ...     PASCAL = \"Pa\"\n        ...     KILO_PASCAL = \"kPa\"\n        ...     PSI = \"psi\"\n    \"\"\"\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; MeasurementUnit:\n        \"\"\"\n        Create an AliasMeasurementUnit from given descriptor.\n        If descriptor is already an AliasMeasurementUnit, it returns the same object.\n\n        This function does not serve as a constructor for AliasMeasurementUnit, rather\n        it is intended to be used to convert an unknown unit descriptor to an\n        AliasMeasurementUnit.\n\n        Subclasses should implement aliased_generic_descriptor and alias_mapping\n        methods.\n\n        Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n        to an AliasMeasurementUnit  instance.\n\n        Examples:\n            &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n            ...     BAR = \"bar\"\n\n            &gt;&gt;&gt; bar = MeasurementUnit.from_descriptor(PressureUnit.BAR**(-1))\n            &gt;&gt;&gt; bar\n            &lt;PressureUnit: bar&gt;\n        \"\"\"\n        if isinstance(descriptor, Dimension) and isinstance(\n            descriptor.unit, AliasMeasurementUnit\n        ):\n            return descriptor.unit\n        if isinstance(descriptor, AliasMeasurementUnit):\n            return descriptor\n        raise UnitDescriptorTypeError(\n            f\"cannot create AliasMeasurementUnit from descriptor {descriptor}\"\n        )\n\n    @classmethod\n    def aliased_generic_descriptor(cls) -&gt; GenericUnitDescriptor:\n        \"\"\"\n        Implement this method by returning the generic of the unit descriptor that this\n        measurement unit aliases.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return LengthUnit**2\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.AliasMeasurementUnit.aliased_generic_descriptor","title":"<code>aliased_generic_descriptor()</code>  <code>classmethod</code>","text":"<p>Implement this method by returning the generic of the unit descriptor that this measurement unit aliases.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return LengthUnit**2\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@classmethod\ndef aliased_generic_descriptor(cls) -&gt; GenericUnitDescriptor:\n    \"\"\"\n    Implement this method by returning the generic of the unit descriptor that this\n    measurement unit aliases.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return LengthUnit**2\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.AliasMeasurementUnit.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create an AliasMeasurementUnit from given descriptor. If descriptor is already an AliasMeasurementUnit, it returns the same object.</p> <p>This function does not serve as a constructor for AliasMeasurementUnit, rather it is intended to be used to convert an unknown unit descriptor to an AliasMeasurementUnit.</p> <p>Subclasses should implement aliased_generic_descriptor and alias_mapping methods.</p> <p>Raises <code>UnitDescriptorTypeError</code> if given descriptor cannot be translated to an AliasMeasurementUnit  instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n...     BAR = \"bar\"\n</code></pre> <pre><code>&gt;&gt;&gt; bar = MeasurementUnit.from_descriptor(PressureUnit.BAR**(-1))\n&gt;&gt;&gt; bar\n&lt;PressureUnit: bar&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; MeasurementUnit:\n    \"\"\"\n    Create an AliasMeasurementUnit from given descriptor.\n    If descriptor is already an AliasMeasurementUnit, it returns the same object.\n\n    This function does not serve as a constructor for AliasMeasurementUnit, rather\n    it is intended to be used to convert an unknown unit descriptor to an\n    AliasMeasurementUnit.\n\n    Subclasses should implement aliased_generic_descriptor and alias_mapping\n    methods.\n\n    Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n    to an AliasMeasurementUnit  instance.\n\n    Examples:\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     BAR = \"bar\"\n\n        &gt;&gt;&gt; bar = MeasurementUnit.from_descriptor(PressureUnit.BAR**(-1))\n        &gt;&gt;&gt; bar\n        &lt;PressureUnit: bar&gt;\n    \"\"\"\n    if isinstance(descriptor, Dimension) and isinstance(\n        descriptor.unit, AliasMeasurementUnit\n    ):\n        return descriptor.unit\n    if isinstance(descriptor, AliasMeasurementUnit):\n        return descriptor\n    raise UnitDescriptorTypeError(\n        f\"cannot create AliasMeasurementUnit from descriptor {descriptor}\"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension","title":"<code>CompositeDimension</code>  <code>dataclass</code>","text":"<p>A CompositeDimension represents a measurement unit that is composed from other measurement units.</p> <p>Objects of this class can represent either multiplication or division between two Dimension objects.</p> <p>Create objects by multiplying and diving Dimension or MeasurementUnit objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n</code></pre> <pre><code>&gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n...     KILO_MOL = \"kmol\"\n</code></pre> <pre><code>&gt;&gt;&gt; molal_volume_dimension = (LengthUnit.METER**3) / AmountUnit.KILO_MOL\n&gt;&gt;&gt; molal_volume_dimension\n&lt;CompositeDimension: (m^3) / kmol&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass CompositeDimension:\n    \"\"\"\n    A CompositeDimension represents a measurement unit that is composed from other\n    measurement units.\n\n    Objects of this class can represent either multiplication or division between two\n    Dimension objects.\n\n    Create objects by multiplying and diving Dimension or MeasurementUnit objects.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n        ...     KILO_MOL = \"kmol\"\n\n        &gt;&gt;&gt; molal_volume_dimension = (LengthUnit.METER**3) / AmountUnit.KILO_MOL\n        &gt;&gt;&gt; molal_volume_dimension\n        &lt;CompositeDimension: (m^3) / kmol&gt;\n    \"\"\"\n\n    Default = TypeVar(\"Default\")  # default return type for `get` functions.\n\n    numerator: List[Dimension] = field(default_factory=list)\n    denominator: List[Dimension] = field(default_factory=list)\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a CompositeDimension from given descriptor.\n        If descriptor is already a CompositeDimension, it returns the same object.\n\n        This function does not serve as a constructor for CompositeDimension, rather it\n        is intended to be used to convert an unknown unit descriptor to a\n        CompositeDimension.\n\n        Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n        to a CompositeDimension instance.\n        \"\"\"\n        if not isinstance(descriptor, CompositeDimension):\n            raise UnitDescriptorTypeError(\n                f\"cannot create CompositeDimension from descriptor {descriptor}\"\n            )\n        return descriptor\n\n    def si(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Returns this composite dimension in SI units.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n            ...     RANKINE = \"R\"\n            ...     @classmethod\n            ...     def si(cls): return cls.KELVIN\n\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n            ...     FOOT = \"ft\"\n            ...     @classmethod\n            ...     def si(cls): return cls.METER\n\n            &gt;&gt;&gt; (TemperatureUnit.RANKINE / LengthUnit.FOOT**2).si()\n            &lt;CompositeDimension: K / (m^2)&gt;\n        \"\"\"\n        return CompositeDimension(\n            [n.si() for n in self.numerator], [d.si() for d in self.denominator]\n        )\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the CompositeDimension is an instance of the generic, False\n        otherwise.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.METER).isinstance(TemperatureUnit / LengthUnit)\n            True\n\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.METER).isinstance(TemperatureUnit**2)\n            False\n        \"\"\"\n        if not isinstance(generic, GenericCompositeDimension):\n            return False\n\n        return self.to_generic() == generic\n\n    def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n        False otherwise.\n\n        A unit descriptor is an instance-equivalent of a generic if the generic of the\n        unit descriptor is equivalent to the generic.\n\n        Equivalence between generics is checked with the `is_equivalent` method.\n\n        Examples:\n            &gt;&gt;&gt; class MassUnit(MeasurementUnit):\n            ...     KILO_GRAM = \"kg\"\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n\n            &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n            ...     NEWTON = \"N\"\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n            &gt;&gt;&gt; (MassUnit.KILO_GRAM * LengthUnit.METER / (TimeUnit.SECOND**2)).isinstance_equivalent(ForceUnit)\n            True\n        \"\"\"\n        return self.to_generic().is_equivalent(generic)\n\n    def to_generic(self) -&gt; GenericCompositeDimension:\n        \"\"\"\n        Create a generic descriptor from this CompositeDimension.\n\n        Examples:\n            &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n            ...     MOL = \"mol\"\n\n            &gt;&gt;&gt; class MassUnit(MeasurementUnit):\n            ...     KILO_GRAM = \"kg\"\n\n            &gt;&gt;&gt; (AmountUnit.MOL / MassUnit.KILO_GRAM).to_generic()\n            &lt;GenericCompositeDimension: AmountUnit / MassUnit&gt;\n        \"\"\"\n        return GenericCompositeDimension(\n            numerator=[n.to_generic() for n in self.numerator],\n            denominator=[d.to_generic() for d in self.denominator],\n        )\n\n    def get_numerator(\n        self,\n        generic: Union[MeasurementUnitType, GenericDimension],\n        default: Optional[Default] = None,\n    ) -&gt; Union[Dimension, Optional[Default]]:\n        \"\"\"\n        Get a dimension from the numerator. If the dimension is not found it returns\n        the default.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n\n            &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n            &gt;&gt;&gt; composite.get_numerator(TemperatureUnit)\n            &lt;Dimension: K&gt;\n            &gt;&gt;&gt; composite.get_numerator(LengthUnit, \"default\")\n            'default'\n        \"\"\"\n        for n in self.numerator:\n            if n.isinstance(generic):\n                return n\n        return default\n\n    def get_denominator(\n        self,\n        generic: Union[MeasurementUnitType, GenericDimension],\n        default: Optional[Default] = None,\n    ) -&gt; Union[Dimension, Optional[Default]]:\n        \"\"\"\n        Get a dimension from the denominator. If the dimension is not found it returns\n        the default.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n\n            &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n            &gt;&gt;&gt; composite.get_denominator(LengthUnit**3)\n            &lt;Dimension: m^3&gt;\n            &gt;&gt;&gt; composite.get_denominator(LengthUnit, \"default\")\n            'default'\n        \"\"\"\n        for d in self.denominator:\n            if d.isinstance(generic):\n                return d\n        return default\n\n    def simplify(self) -&gt; None:\n        \"\"\"\n        Simplify the composite by merging common dimensions.\n\n        Examples:\n            &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n            ...     BAR = \"bar\"\n            ...     PASCAL = \"Pa\"\n\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n\n            &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n            &gt;&gt;&gt; composite\n            &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n            &gt;&gt;&gt; composite.simplify()\n            &gt;&gt;&gt; composite\n            &lt;CompositeDimension: K / (bar^2)&gt;\n\n            &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n            &gt;&gt;&gt; composite\n            &lt;CompositeDimension: Pa * Pa * m / s&gt;\n            &gt;&gt;&gt; composite.simplify()\n            &gt;&gt;&gt; composite\n            &lt;CompositeDimension: (Pa^2) * m / s&gt;\n        \"\"\"\n        exponents: Dict[MeasurementUnit, float] = {}\n        for n in self.numerator:\n            if n.unit in exponents:\n                exponents[n.unit] += n.power\n            else:\n                exponents[n.unit] = n.power\n\n        for d in self.denominator:\n            if d.unit in exponents:\n                exponents[d.unit] -= d.power\n            else:\n                exponents[d.unit] = 0 - d.power\n\n        numerator = []\n        denominator = []\n        for unit, exponent in exponents.items():\n            if exponent &gt; 0:\n                numerator.append(Dimension(unit) ** exponent)\n            elif exponent &lt; 0:\n                denominator.append(Dimension(unit) ** abs(exponent))\n\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def simplified(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Returns a simplified version of this composite dimension as a new object.\n\n        Examples:\n            &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n            ...     BAR = \"bar\"\n            ...     PASCAL = \"Pa\"\n\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n\n            &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n            &gt;&gt;&gt; composite\n            &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n            &gt;&gt;&gt; composite.simplified()\n            &lt;CompositeDimension: K / (bar^2)&gt;\n\n            &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n            &gt;&gt;&gt; composite\n            &lt;CompositeDimension: Pa * Pa * m / s&gt;\n            &gt;&gt;&gt; composite.simplified()\n            &lt;CompositeDimension: (Pa^2) * m / s&gt;\n        \"\"\"\n        copy = replace(self)\n        copy.simplify()\n        return copy\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n\n            &gt;&gt;&gt; (LengthUnit.METER / TimeUnit.SECOND).inverse()\n            &lt;CompositeDimension: s / m&gt;\n        \"\"\"\n        return CompositeDimension(self._denominator_copy(), self._numerator_copy())\n\n    def _numerator_copy(self) -&gt; List[Dimension]:\n        return [replace(n) for n in self.numerator]\n\n    def _denominator_copy(self) -&gt; List[Dimension]:\n        return [replace(d) for d in self.denominator]\n\n    def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.CENTI_METER) * TimeUnit.SECOND\n            &lt;CompositeDimension: C * s / cm&gt;\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(descriptor, CompositeDimension):\n            numerator.extend(descriptor.numerator)\n            denominator.extend(descriptor.denominator)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            numerator.append(descriptor)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, MeasurementUnit):\n            numerator.append(Dimension(descriptor))\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        raise DescriptorBinaryOperationError(\n            f\"cannot multiply {self} with {descriptor}. \"\n        )\n\n    def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     CENTI_METER = \"cm\"\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.CENTI_METER) / TimeUnit.SECOND\n            &lt;CompositeDimension: C * cm / s&gt;\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(descriptor, CompositeDimension):\n            numerator.extend(descriptor.denominator)\n            denominator.extend(descriptor.numerator)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            denominator.append(descriptor)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, MeasurementUnit):\n            denominator.append(Dimension(descriptor))\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        raise DescriptorBinaryOperationError(\n            f\"cannot divide {self} with {descriptor}. \"\n        )\n\n    def __pow__(self, power: float) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines exponentiation for CompositeDimension(s).\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     HOUR = \"hr\"\n\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR)**2\n            &lt;CompositeDimension: (C^2) / (hr^2)&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        numerator = [n**power for n in self._numerator_copy()]\n        denominator = [d**power for d in self._denominator_copy()]\n        return CompositeDimension(numerator, denominator)\n\n    def __eq__(self, dimension) -&gt; bool:\n        \"\"\"\n        Defines equality for CompositeDimension(s).\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     HOUR = \"hr\"\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR) != (TimeUnit.HOUR / TemperatureUnit.CELCIUS)\n            True\n        \"\"\"\n        if not isinstance(dimension, CompositeDimension):\n            return False\n        return Counter(self.numerator) == Counter(dimension.numerator) and (\n            Counter(self.denominator) == Counter(dimension.denominator)\n        )\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __str__(self):\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return numerators + denominators\n\n    def __repr__(self) -&gt; str:\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return f\"&lt;CompositeDimension: {numerators + denominators}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__eq__","title":"<code>__eq__(dimension)</code>","text":"<p>Defines equality for CompositeDimension(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     HOUR = \"hr\"\n&gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR) != (TimeUnit.HOUR / TemperatureUnit.CELCIUS)\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, dimension) -&gt; bool:\n    \"\"\"\n    Defines equality for CompositeDimension(s).\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR) != (TimeUnit.HOUR / TemperatureUnit.CELCIUS)\n        True\n    \"\"\"\n    if not isinstance(dimension, CompositeDimension):\n        return False\n    return Counter(self.numerator) == Counter(dimension.numerator) and (\n        Counter(self.denominator) == Counter(dimension.denominator)\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__mul__","title":"<code>__mul__(descriptor)</code>","text":"<p>Defines multiplication between CompositeDimension(s) and other unit descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n&gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.CENTI_METER) * TimeUnit.SECOND\n&lt;CompositeDimension: C * s / cm&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.CENTI_METER) * TimeUnit.SECOND\n        &lt;CompositeDimension: C * s / cm&gt;\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(descriptor, CompositeDimension):\n        numerator.extend(descriptor.numerator)\n        denominator.extend(descriptor.denominator)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        numerator.append(descriptor)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, MeasurementUnit):\n        numerator.append(Dimension(descriptor))\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    raise DescriptorBinaryOperationError(\n        f\"cannot multiply {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for CompositeDimension(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     HOUR = \"hr\"\n</code></pre> <pre><code>&gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR)**2\n&lt;CompositeDimension: (C^2) / (hr^2)&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines exponentiation for CompositeDimension(s).\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR)**2\n        &lt;CompositeDimension: (C^2) / (hr^2)&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    numerator = [n**power for n in self._numerator_copy()]\n    denominator = [d**power for d in self._denominator_copy()]\n    return CompositeDimension(numerator, denominator)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__truediv__","title":"<code>__truediv__(descriptor)</code>","text":"<p>Defines multiplication between CompositeDimension(s) and other unit descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     CENTI_METER = \"cm\"\n&gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.CENTI_METER) / TimeUnit.SECOND\n&lt;CompositeDimension: C * cm / s&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.CENTI_METER) / TimeUnit.SECOND\n        &lt;CompositeDimension: C * cm / s&gt;\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(descriptor, CompositeDimension):\n        numerator.extend(descriptor.denominator)\n        denominator.extend(descriptor.numerator)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        denominator.append(descriptor)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, MeasurementUnit):\n        denominator.append(Dimension(descriptor))\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    raise DescriptorBinaryOperationError(\n        f\"cannot divide {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create a CompositeDimension from given descriptor. If descriptor is already a CompositeDimension, it returns the same object.</p> <p>This function does not serve as a constructor for CompositeDimension, rather it is intended to be used to convert an unknown unit descriptor to a CompositeDimension.</p> <p>Raises <code>UnitDescriptorTypeError</code> if given descriptor cannot be translated to a CompositeDimension instance.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a CompositeDimension from given descriptor.\n    If descriptor is already a CompositeDimension, it returns the same object.\n\n    This function does not serve as a constructor for CompositeDimension, rather it\n    is intended to be used to convert an unknown unit descriptor to a\n    CompositeDimension.\n\n    Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n    to a CompositeDimension instance.\n    \"\"\"\n    if not isinstance(descriptor, CompositeDimension):\n        raise UnitDescriptorTypeError(\n            f\"cannot create CompositeDimension from descriptor {descriptor}\"\n        )\n    return descriptor\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.get_denominator","title":"<code>get_denominator(generic, default=None)</code>","text":"<p>Get a dimension from the denominator. If the dimension is not found it returns the default.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n</code></pre> <pre><code>&gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n&gt;&gt;&gt; composite.get_denominator(LengthUnit**3)\n&lt;Dimension: m^3&gt;\n&gt;&gt;&gt; composite.get_denominator(LengthUnit, \"default\")\n'default'\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def get_denominator(\n    self,\n    generic: Union[MeasurementUnitType, GenericDimension],\n    default: Optional[Default] = None,\n) -&gt; Union[Dimension, Optional[Default]]:\n    \"\"\"\n    Get a dimension from the denominator. If the dimension is not found it returns\n    the default.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n        &gt;&gt;&gt; composite.get_denominator(LengthUnit**3)\n        &lt;Dimension: m^3&gt;\n        &gt;&gt;&gt; composite.get_denominator(LengthUnit, \"default\")\n        'default'\n    \"\"\"\n    for d in self.denominator:\n        if d.isinstance(generic):\n            return d\n    return default\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.get_numerator","title":"<code>get_numerator(generic, default=None)</code>","text":"<p>Get a dimension from the numerator. If the dimension is not found it returns the default.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n</code></pre> <pre><code>&gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n&gt;&gt;&gt; composite.get_numerator(TemperatureUnit)\n&lt;Dimension: K&gt;\n&gt;&gt;&gt; composite.get_numerator(LengthUnit, \"default\")\n'default'\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def get_numerator(\n    self,\n    generic: Union[MeasurementUnitType, GenericDimension],\n    default: Optional[Default] = None,\n) -&gt; Union[Dimension, Optional[Default]]:\n    \"\"\"\n    Get a dimension from the numerator. If the dimension is not found it returns\n    the default.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n        &gt;&gt;&gt; composite.get_numerator(TemperatureUnit)\n        &lt;Dimension: K&gt;\n        &gt;&gt;&gt; composite.get_numerator(LengthUnit, \"default\")\n        'default'\n    \"\"\"\n    for n in self.numerator:\n        if n.isinstance(generic):\n            return n\n    return default\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n</code></pre> <pre><code>&gt;&gt;&gt; (LengthUnit.METER / TimeUnit.SECOND).inverse()\n&lt;CompositeDimension: s / m&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; (LengthUnit.METER / TimeUnit.SECOND).inverse()\n        &lt;CompositeDimension: s / m&gt;\n    \"\"\"\n    return CompositeDimension(self._denominator_copy(), self._numerator_copy())\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the CompositeDimension is an instance of the generic, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n</code></pre> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n</code></pre> <pre><code>&gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.METER).isinstance(TemperatureUnit / LengthUnit)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.METER).isinstance(TemperatureUnit**2)\nFalse\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the CompositeDimension is an instance of the generic, False\n    otherwise.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.METER).isinstance(TemperatureUnit / LengthUnit)\n        True\n\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.METER).isinstance(TemperatureUnit**2)\n        False\n    \"\"\"\n    if not isinstance(generic, GenericCompositeDimension):\n        return False\n\n    return self.to_generic() == generic\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.isinstance_equivalent","title":"<code>isinstance_equivalent(generic)</code>","text":"<p>Returns True if the UnitDescriptor is an instance-equivalent of the generic, False otherwise.</p> <p>A unit descriptor is an instance-equivalent of a generic if the generic of the unit descriptor is equivalent to the generic.</p> <p>Equivalence between generics is checked with the <code>is_equivalent</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MassUnit(MeasurementUnit):\n...     KILO_GRAM = \"kg\"\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n</code></pre> <pre><code>&gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n...     NEWTON = \"N\"\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return MassUnit * LengthUnit / (TimeUnit**2)\n</code></pre> <pre><code>&gt;&gt;&gt; (MassUnit.KILO_GRAM * LengthUnit.METER / (TimeUnit.SECOND**2)).isinstance_equivalent(ForceUnit)\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n    False otherwise.\n\n    A unit descriptor is an instance-equivalent of a generic if the generic of the\n    unit descriptor is equivalent to the generic.\n\n    Equivalence between generics is checked with the `is_equivalent` method.\n\n    Examples:\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit):\n        ...     KILO_GRAM = \"kg\"\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n        ...     NEWTON = \"N\"\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n        &gt;&gt;&gt; (MassUnit.KILO_GRAM * LengthUnit.METER / (TimeUnit.SECOND**2)).isinstance_equivalent(ForceUnit)\n        True\n    \"\"\"\n    return self.to_generic().is_equivalent(generic)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.si","title":"<code>si()</code>","text":"<p>Returns this composite dimension in SI units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n...     RANKINE = \"R\"\n...     @classmethod\n...     def si(cls): return cls.KELVIN\n</code></pre> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n...     FOOT = \"ft\"\n...     @classmethod\n...     def si(cls): return cls.METER\n</code></pre> <pre><code>&gt;&gt;&gt; (TemperatureUnit.RANKINE / LengthUnit.FOOT**2).si()\n&lt;CompositeDimension: K / (m^2)&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def si(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Returns this composite dimension in SI units.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n        ...     RANKINE = \"R\"\n        ...     @classmethod\n        ...     def si(cls): return cls.KELVIN\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        ...     FOOT = \"ft\"\n        ...     @classmethod\n        ...     def si(cls): return cls.METER\n\n        &gt;&gt;&gt; (TemperatureUnit.RANKINE / LengthUnit.FOOT**2).si()\n        &lt;CompositeDimension: K / (m^2)&gt;\n    \"\"\"\n    return CompositeDimension(\n        [n.si() for n in self.numerator], [d.si() for d in self.denominator]\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.simplified","title":"<code>simplified()</code>","text":"<p>Returns a simplified version of this composite dimension as a new object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n...     BAR = \"bar\"\n...     PASCAL = \"Pa\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n</code></pre> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n</code></pre> <pre><code>&gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n&gt;&gt;&gt; composite\n&lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n&gt;&gt;&gt; composite.simplified()\n&lt;CompositeDimension: K / (bar^2)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n&gt;&gt;&gt; composite\n&lt;CompositeDimension: Pa * Pa * m / s&gt;\n&gt;&gt;&gt; composite.simplified()\n&lt;CompositeDimension: (Pa^2) * m / s&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplified(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Returns a simplified version of this composite dimension as a new object.\n\n    Examples:\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     BAR = \"bar\"\n        ...     PASCAL = \"Pa\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;CompositeDimension: K / (bar^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: Pa * Pa * m / s&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;CompositeDimension: (Pa^2) * m / s&gt;\n    \"\"\"\n    copy = replace(self)\n    copy.simplify()\n    return copy\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.simplify","title":"<code>simplify()</code>","text":"<p>Simplify the composite by merging common dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n...     BAR = \"bar\"\n...     PASCAL = \"Pa\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n</code></pre> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n</code></pre> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n</code></pre> <pre><code>&gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n&gt;&gt;&gt; composite\n&lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n&gt;&gt;&gt; composite.simplify()\n&gt;&gt;&gt; composite\n&lt;CompositeDimension: K / (bar^2)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n&gt;&gt;&gt; composite\n&lt;CompositeDimension: Pa * Pa * m / s&gt;\n&gt;&gt;&gt; composite.simplify()\n&gt;&gt;&gt; composite\n&lt;CompositeDimension: (Pa^2) * m / s&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplify(self) -&gt; None:\n    \"\"\"\n    Simplify the composite by merging common dimensions.\n\n    Examples:\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     BAR = \"bar\"\n        ...     PASCAL = \"Pa\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: K / (bar^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: Pa * Pa * m / s&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: (Pa^2) * m / s&gt;\n    \"\"\"\n    exponents: Dict[MeasurementUnit, float] = {}\n    for n in self.numerator:\n        if n.unit in exponents:\n            exponents[n.unit] += n.power\n        else:\n            exponents[n.unit] = n.power\n\n    for d in self.denominator:\n        if d.unit in exponents:\n            exponents[d.unit] -= d.power\n        else:\n            exponents[d.unit] = 0 - d.power\n\n    numerator = []\n    denominator = []\n    for unit, exponent in exponents.items():\n        if exponent &gt; 0:\n            numerator.append(Dimension(unit) ** exponent)\n        elif exponent &lt; 0:\n            denominator.append(Dimension(unit) ** abs(exponent))\n\n    self.numerator = numerator\n    self.denominator = denominator\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this CompositeDimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n...     MOL = \"mol\"\n</code></pre> <pre><code>&gt;&gt;&gt; class MassUnit(MeasurementUnit):\n...     KILO_GRAM = \"kg\"\n</code></pre> <pre><code>&gt;&gt;&gt; (AmountUnit.MOL / MassUnit.KILO_GRAM).to_generic()\n&lt;GenericCompositeDimension: AmountUnit / MassUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericCompositeDimension:\n    \"\"\"\n    Create a generic descriptor from this CompositeDimension.\n\n    Examples:\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n        ...     MOL = \"mol\"\n\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit):\n        ...     KILO_GRAM = \"kg\"\n\n        &gt;&gt;&gt; (AmountUnit.MOL / MassUnit.KILO_GRAM).to_generic()\n        &lt;GenericCompositeDimension: AmountUnit / MassUnit&gt;\n    \"\"\"\n    return GenericCompositeDimension(\n        numerator=[n.to_generic() for n in self.numerator],\n        denominator=[d.to_generic() for d in self.denominator],\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension","title":"<code>Dimension</code>  <code>dataclass</code>","text":"<p>A Dimension is a wrapper around MeasurementUnit.</p> <p>Objects of this class can represent either a simple MeasurementUnit or a MeasurementUnit to some power.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n</code></pre> <pre><code>&gt;&gt;&gt; TimeUnit.SECOND**2\n&lt;Dimension: s^2&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass Dimension:\n    \"\"\"\n    A Dimension is a wrapper around MeasurementUnit.\n\n    Objects of this class can represent either a simple MeasurementUnit or a\n    MeasurementUnit to some power.\n\n    Examples:\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; TimeUnit.SECOND**2\n        &lt;Dimension: s^2&gt;\n    \"\"\"\n\n    unit: MeasurementUnit\n    power: float = 1\n\n    def __init__(self, unit: MeasurementUnit, power: float = 1) -&gt; None:\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.unit = unit\n        self.power = power\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; \"Dimension\":\n        \"\"\"\n        Create a Dimension from given descriptor.\n        If descriptor is already a Dimension, it returns the same object.\n\n        This function does not serve as a constructor for Dimension, rather it\n        is intended to be used to convert an unknown unit descriptor to a Dimension.\n\n        Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n        to a Dimension instance.\n        \"\"\"\n        if isinstance(descriptor, Dimension):\n            return descriptor\n        if isinstance(descriptor, MeasurementUnit):\n            return Dimension(descriptor)\n        raise UnitDescriptorTypeError(\n            f\"cannot create Dimension from descriptor: {descriptor}\"\n        )\n\n    def si(self) -&gt; \"Dimension\":\n        \"\"\"\n        Returns this dimension in SI units.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n            ...     FOOT = \"ft\"\n            ...     @classmethod\n            ...     def si(cls): return cls.METER\n\n            &gt;&gt;&gt; (LengthUnit.FOOT**2).si()\n            &lt;Dimension: m^2&gt;\n        \"\"\"\n        return Dimension(self.unit.si(), self.power)\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the Dimension is an instance of the generic, False\n        otherwise.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n\n            &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit)\n            True\n\n            &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit**2)\n            False\n        \"\"\"\n        if isinstance(generic, MeasurementUnitType):\n            generic = GenericDimension(generic)\n        if not isinstance(generic, GenericDimension):\n            return False\n\n        if isinstance(self.unit, generic.unit_type) and self.power == generic.power:\n            return True\n\n        return False\n\n    def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n        False otherwise.\n\n        A unit descriptor is an instance-equivalent of a generic if the generic of the\n        unit descriptor is equivalent to the generic.\n\n        Equivalence between generics is checked with the `is_equivalent` method.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n            &gt;&gt;&gt; class VolumeUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls): return LengthUnit**3\n\n            &gt;&gt;&gt; (LengthUnit.METER**3).isinstance_equivalent(VolumeUnit)\n            True\n        \"\"\"\n        return self.to_generic().is_equivalent(generic)\n\n    def to_generic(self) -&gt; GenericDimension:\n        \"\"\"\n        Create a generic descriptor from this Dimension.\n\n        Examples:\n            &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n            ...     MOL = \"mol\"\n\n            &gt;&gt;&gt; (AmountUnit.MOL**3.56).to_generic()\n            &lt;GenericDimension: AmountUnit^3.56&gt;\n        \"\"\"\n        return GenericDimension(type(self.unit), self.power)\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n            &gt;&gt;&gt; (LengthUnit.METER**2).inverse()\n            &lt;CompositeDimension:  / (m^2)&gt;\n        \"\"\"\n        return CompositeDimension([], [replace(self)])\n\n    def _isinstance_aliased(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the generic is the aliased unit descriptor of this Dimension,\n        False otherwise.\n\n        Only applicable if this Dimension's unit is of type AliasMeasurementUnit.\n        \"\"\"\n        return (\n            isinstance(self.unit, AliasMeasurementUnit)\n            and (self.unit.aliased_generic_descriptor() ** self.power) == generic\n        )\n\n    def _isinstance_alias(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if this Dimension's unit is an instance of the aliased unit\n        descriptor of the generic, False otherwise.\n\n        Only applicable if generic is an AliasMeasurementUnit.\n        \"\"\"\n        if isinstance(generic, MeasurementUnitType):\n            generic = GenericDimension(generic)\n\n        if not isinstance(generic, GenericDimension):\n            return False\n\n        if not issubclass(generic.unit_type, AliasMeasurementUnit):\n            return False\n\n        if (\n            generic.unit_type.aliased_generic_descriptor() ** generic.power\n            == self.to_generic()\n        ):\n            return True\n\n        return False\n\n    def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between Dimension(s) and other unit descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     MINUTE = \"min\"\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS**3) * TimeUnit.MINUTE\n            &lt;CompositeDimension: (C^3) * min&gt;\n        \"\"\"\n        if isinstance(descriptor, CompositeDimension):\n            numerator = descriptor.numerator.copy()\n            denominator = descriptor.denominator.copy()\n            numerator.append(self)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            return CompositeDimension(numerator=[self, descriptor])\n        if isinstance(descriptor, MeasurementUnit):\n            return CompositeDimension(numerator=[self, Dimension(descriptor)])\n        raise DescriptorBinaryOperationError(\n            f\"cannot multiply {self} with {descriptor}. \"\n        )\n\n    def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines division between Dimension(s) and other unit descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     MINUTE = \"min\"\n            &gt;&gt;&gt; (TemperatureUnit.CELCIUS**3) / TimeUnit.MINUTE\n            &lt;CompositeDimension: (C^3) / min&gt;\n        \"\"\"\n        if isinstance(descriptor, CompositeDimension):\n            numerator = descriptor.denominator.copy()\n            denominator = descriptor.numerator.copy()\n            numerator.append(self)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            return CompositeDimension(numerator=[self], denominator=[descriptor])\n        if isinstance(descriptor, MeasurementUnit):\n            return CompositeDimension(\n                numerator=[self], denominator=[Dimension(descriptor)]\n            )\n        raise DescriptorBinaryOperationError(\n            f\"cannot divide {self} with  {descriptor}. \"\n        )\n\n    def __pow__(self, power: float) -&gt; \"Dimension\":\n        \"\"\"\n        Defines exponentiation for Dimension(s).\n\n        Examples:\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n            &gt;&gt;&gt; (TimeUnit.SECOND**2)**3\n            &lt;Dimension: s^6&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.power *= power\n        return self\n\n    def __eq__(self, dimension) -&gt; bool:\n        \"\"\"\n        Defines equality for Dimension(s).\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n            &gt;&gt;&gt; (TemperatureUnit.KELVIN**2) != TemperatureUnit.KELVIN\n            True\n        \"\"\"\n        if not isinstance(dimension, Dimension):\n            return False\n        return self.unit == dimension.unit and self.power == dimension.power\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __repr__(self) -&gt; str:\n        if self.power != 1:\n            return f\"&lt;Dimension: {self.unit.value}^{self.power}&gt;\"\n        return f\"&lt;Dimension: {self.unit.value}&gt;\"\n\n    def __str__(self) -&gt; str:\n        s = self.unit.value\n        if self.power != 1:\n            return f\"({s}^{self.power})\"\n        return s\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__eq__","title":"<code>__eq__(dimension)</code>","text":"<p>Defines equality for Dimension(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n&gt;&gt;&gt; (TemperatureUnit.KELVIN**2) != TemperatureUnit.KELVIN\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, dimension) -&gt; bool:\n    \"\"\"\n    Defines equality for Dimension(s).\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n        &gt;&gt;&gt; (TemperatureUnit.KELVIN**2) != TemperatureUnit.KELVIN\n        True\n    \"\"\"\n    if not isinstance(dimension, Dimension):\n        return False\n    return self.unit == dimension.unit and self.power == dimension.power\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__mul__","title":"<code>__mul__(descriptor)</code>","text":"<p>Defines multiplication between Dimension(s) and other unit descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     MINUTE = \"min\"\n&gt;&gt;&gt; (TemperatureUnit.CELCIUS**3) * TimeUnit.MINUTE\n&lt;CompositeDimension: (C^3) * min&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between Dimension(s) and other unit descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     MINUTE = \"min\"\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS**3) * TimeUnit.MINUTE\n        &lt;CompositeDimension: (C^3) * min&gt;\n    \"\"\"\n    if isinstance(descriptor, CompositeDimension):\n        numerator = descriptor.numerator.copy()\n        denominator = descriptor.denominator.copy()\n        numerator.append(self)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        return CompositeDimension(numerator=[self, descriptor])\n    if isinstance(descriptor, MeasurementUnit):\n        return CompositeDimension(numerator=[self, Dimension(descriptor)])\n    raise DescriptorBinaryOperationError(\n        f\"cannot multiply {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for Dimension(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n&gt;&gt;&gt; (TimeUnit.SECOND**2)**3\n&lt;Dimension: s^6&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"Dimension\":\n    \"\"\"\n    Defines exponentiation for Dimension(s).\n\n    Examples:\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        &gt;&gt;&gt; (TimeUnit.SECOND**2)**3\n        &lt;Dimension: s^6&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    self.power *= power\n    return self\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__truediv__","title":"<code>__truediv__(descriptor)</code>","text":"<p>Defines division between Dimension(s) and other unit descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     MINUTE = \"min\"\n&gt;&gt;&gt; (TemperatureUnit.CELCIUS**3) / TimeUnit.MINUTE\n&lt;CompositeDimension: (C^3) / min&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines division between Dimension(s) and other unit descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     MINUTE = \"min\"\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS**3) / TimeUnit.MINUTE\n        &lt;CompositeDimension: (C^3) / min&gt;\n    \"\"\"\n    if isinstance(descriptor, CompositeDimension):\n        numerator = descriptor.denominator.copy()\n        denominator = descriptor.numerator.copy()\n        numerator.append(self)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        return CompositeDimension(numerator=[self], denominator=[descriptor])\n    if isinstance(descriptor, MeasurementUnit):\n        return CompositeDimension(\n            numerator=[self], denominator=[Dimension(descriptor)]\n        )\n    raise DescriptorBinaryOperationError(\n        f\"cannot divide {self} with  {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create a Dimension from given descriptor. If descriptor is already a Dimension, it returns the same object.</p> <p>This function does not serve as a constructor for Dimension, rather it is intended to be used to convert an unknown unit descriptor to a Dimension.</p> <p>Raises <code>UnitDescriptorTypeError</code> if given descriptor cannot be translated to a Dimension instance.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; \"Dimension\":\n    \"\"\"\n    Create a Dimension from given descriptor.\n    If descriptor is already a Dimension, it returns the same object.\n\n    This function does not serve as a constructor for Dimension, rather it\n    is intended to be used to convert an unknown unit descriptor to a Dimension.\n\n    Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n    to a Dimension instance.\n    \"\"\"\n    if isinstance(descriptor, Dimension):\n        return descriptor\n    if isinstance(descriptor, MeasurementUnit):\n        return Dimension(descriptor)\n    raise UnitDescriptorTypeError(\n        f\"cannot create Dimension from descriptor: {descriptor}\"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n&gt;&gt;&gt; (LengthUnit.METER**2).inverse()\n&lt;CompositeDimension:  / (m^2)&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        &gt;&gt;&gt; (LengthUnit.METER**2).inverse()\n        &lt;CompositeDimension:  / (m^2)&gt;\n    \"\"\"\n    return CompositeDimension([], [replace(self)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the Dimension is an instance of the generic, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n</code></pre> <pre><code>&gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit**2)\nFalse\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the Dimension is an instance of the generic, False\n    otherwise.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit)\n        True\n\n        &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit**2)\n        False\n    \"\"\"\n    if isinstance(generic, MeasurementUnitType):\n        generic = GenericDimension(generic)\n    if not isinstance(generic, GenericDimension):\n        return False\n\n    if isinstance(self.unit, generic.unit_type) and self.power == generic.power:\n        return True\n\n    return False\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.isinstance_equivalent","title":"<code>isinstance_equivalent(generic)</code>","text":"<p>Returns True if the UnitDescriptor is an instance-equivalent of the generic, False otherwise.</p> <p>A unit descriptor is an instance-equivalent of a generic if the generic of the unit descriptor is equivalent to the generic.</p> <p>Equivalence between generics is checked with the <code>is_equivalent</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n&gt;&gt;&gt; class VolumeUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls): return LengthUnit**3\n</code></pre> <pre><code>&gt;&gt;&gt; (LengthUnit.METER**3).isinstance_equivalent(VolumeUnit)\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n    False otherwise.\n\n    A unit descriptor is an instance-equivalent of a generic if the generic of the\n    unit descriptor is equivalent to the generic.\n\n    Equivalence between generics is checked with the `is_equivalent` method.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        &gt;&gt;&gt; class VolumeUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls): return LengthUnit**3\n\n        &gt;&gt;&gt; (LengthUnit.METER**3).isinstance_equivalent(VolumeUnit)\n        True\n    \"\"\"\n    return self.to_generic().is_equivalent(generic)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.si","title":"<code>si()</code>","text":"<p>Returns this dimension in SI units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n...     FOOT = \"ft\"\n...     @classmethod\n...     def si(cls): return cls.METER\n</code></pre> <pre><code>&gt;&gt;&gt; (LengthUnit.FOOT**2).si()\n&lt;Dimension: m^2&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def si(self) -&gt; \"Dimension\":\n    \"\"\"\n    Returns this dimension in SI units.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        ...     FOOT = \"ft\"\n        ...     @classmethod\n        ...     def si(cls): return cls.METER\n\n        &gt;&gt;&gt; (LengthUnit.FOOT**2).si()\n        &lt;Dimension: m^2&gt;\n    \"\"\"\n    return Dimension(self.unit.si(), self.power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this Dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n...     MOL = \"mol\"\n</code></pre> <pre><code>&gt;&gt;&gt; (AmountUnit.MOL**3.56).to_generic()\n&lt;GenericDimension: AmountUnit^3.56&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericDimension:\n    \"\"\"\n    Create a generic descriptor from this Dimension.\n\n    Examples:\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n        ...     MOL = \"mol\"\n\n        &gt;&gt;&gt; (AmountUnit.MOL**3.56).to_generic()\n        &lt;GenericDimension: AmountUnit^3.56&gt;\n    \"\"\"\n    return GenericDimension(type(self.unit), self.power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension","title":"<code>GenericCompositeDimension</code>  <code>dataclass</code>","text":"<p>A <code>GenericCompositeDimension</code> represents a generic measurement unit that is composed from other generic measurement units.</p> <p>Objects of this class can represent either multiplication or division between two <code>GenericDimension</code> objects.</p> <p>Create objects by multiplying and diving GenericDimension or MeasurementUnitMeta class objects:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class AmountUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; generic_molal_volume_dimension = (LengthUnit**3) / AmountUnit\n&gt;&gt;&gt; generic_molal_volume_dimension\n&lt;GenericCompositeDimension: (LengthUnit^3) / AmountUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass GenericCompositeDimension:\n    \"\"\"\n    A `GenericCompositeDimension` represents a generic measurement unit that is composed\n    from other generic measurement units.\n\n    Objects of this class can represent either multiplication or division between two\n    `GenericDimension` objects.\n\n    Create objects by multiplying and diving GenericDimension or MeasurementUnitMeta\n    class objects:\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; generic_molal_volume_dimension = (LengthUnit**3) / AmountUnit\n        &gt;&gt;&gt; generic_molal_volume_dimension\n        &lt;GenericCompositeDimension: (LengthUnit^3) / AmountUnit&gt;\n    \"\"\"\n\n    numerator: List[GenericDimension] = field(default_factory=list)\n    denominator: List[GenericDimension] = field(default_factory=list)\n\n    def to_si(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a CompositeDimension with SI units.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n            ...     @classmethod\n            ...     def si(cls): return cls.KELVIN\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     SECOND = \"s\"\n            ...     @classmethod\n            ...     def si(cls): return cls.SECOND\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n            ...     @classmethod\n            ...     def si(cls): return cls.METER\n            &gt;&gt;&gt; (TemperatureUnit * LengthUnit / TimeUnit).to_si()\n            &lt;CompositeDimension: K * m / s&gt;\n        \"\"\"\n        return CompositeDimension(\n            [n.to_si() for n in self.numerator], [d.to_si() for d in self.denominator]\n        )\n\n    def simplify(self) -&gt; None:\n        \"\"\"\n        Simplify the composite by merging common dimensions.\n\n        Examples:\n            &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n            &gt;&gt;&gt; composite.simplify()\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n            &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit / TimeUnit\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n            &gt;&gt;&gt; composite.simplify()\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n        \"\"\"\n        exponents: Dict[MeasurementUnitType, float] = {}\n        for n in self.numerator:\n            if n.unit_type in exponents:\n                exponents[n.unit_type] += n.power\n            else:\n                exponents[n.unit_type] = n.power\n\n        for d in self.denominator:\n            if d.unit_type in exponents:\n                exponents[d.unit_type] -= d.power\n            else:\n                exponents[d.unit_type] = 0 - d.power\n\n        numerator = []\n        denominator = []\n        for unit_type, exponent in exponents.items():\n            if exponent &gt; 0:\n                numerator.append(GenericDimension(unit_type) ** exponent)\n            elif exponent &lt; 0:\n                denominator.append(GenericDimension(unit_type) ** abs(exponent))\n\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def simplified(self) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Returns a simplified version of this composite generic as a new object.\n\n        Examples:\n            &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n            &gt;&gt;&gt; composite.simplified()\n            &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n            &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit /TimeUnit\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n            &gt;&gt;&gt; composite.simplified()\n            &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n        \"\"\"\n        copy = replace(self)\n        copy.simplify()\n        return copy\n\n    def analyse(self) -&gt; None:\n        \"\"\"\n        Analyse this composite by replacing its alias units with their aliased units.\n\n        Examples:\n            &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls) -&gt; GenericCompositeDimension:\n            ...         return MassUnit / LengthUnit / (TimeUnit**2)\n\n            &gt;&gt;&gt; composite = PressureUnit / LengthUnit\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: PressureUnit / LengthUnit&gt;\n\n            &gt;&gt;&gt; composite.analyse()\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: MassUnit / (TimeUnit^2) / LengthUnit / LengthUnit&gt;\n        \"\"\"\n        for n in self.numerator:\n            if issubclass(n.unit_type, AliasMeasurementUnit):\n                aliased = n.unit_type.aliased_generic_descriptor() ** n.power\n                if isinstance(aliased, GenericDimension):\n                    self.numerator.append(aliased)\n                elif isinstance(aliased, GenericCompositeDimension):\n                    self.numerator.extend(aliased.numerator)\n                    self.denominator.extend(aliased.denominator)\n\n                self.numerator.remove(n)\n\n        for d in self.denominator:\n            if issubclass(d.unit_type, AliasMeasurementUnit):\n                aliased = d.unit_type.aliased_generic_descriptor() ** d.power\n                if isinstance(aliased, GenericDimension):\n                    self.denominator.append(aliased)\n                elif isinstance(aliased, GenericCompositeDimension):\n                    self.denominator.extend(aliased.numerator)\n                    self.numerator.extend(aliased.denominator)\n\n                self.denominator.remove(d)\n\n    def analysed(self) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Returns an analysed version of this composite generic as a new object.\n\n        Examples:\n            &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls) -&gt; GenericCompositeDimension:\n            ...         return MassUnit / LengthUnit / (TimeUnit**2)\n\n            &gt;&gt;&gt; composite = PressureUnit / LengthUnit\n            &gt;&gt;&gt; composite\n            &lt;GenericCompositeDimension: PressureUnit / LengthUnit&gt;\n\n            &gt;&gt;&gt; composite.analysed()\n            &lt;GenericCompositeDimension: MassUnit / (TimeUnit^2) / LengthUnit / LengthUnit&gt;\n        \"\"\"\n        copy = replace(self)\n        copy.analyse()\n        return copy\n\n    def inverse_generic(self):\n        \"\"\"\n        Create a generic composite with inverse units.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; (LengthUnit / TimeUnit).inverse_generic()\n            &lt;GenericCompositeDimension: TimeUnit / LengthUnit&gt;\n        \"\"\"\n        return GenericCompositeDimension(\n            self._denominator_copy(), self._numerator_copy()\n        )\n\n    def is_equivalent(self, other: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if this generic is equivalent to the given one, False otherwise.\n\n        A generic can be equivalent with another generic if the latter or the former\n        is an alias.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n            &gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\n            True\n\n            &gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return ForceUnit * LengthUnit\n\n            &gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\n            True\n        \"\"\"\n        if isinstance(other, MeasurementUnitType):\n            if (\n                self.denominator == []\n                and len(self.numerator) == 1\n                and self.numerator[0].is_equivalent(other)\n            ):\n                return True\n\n            if issubclass(other, AliasMeasurementUnit):\n                return other.aliased_generic_descriptor().is_equivalent(self)  # type: ignore[attr-defined]\n\n        elif isinstance(other, GenericDimension):\n            if (\n                self.denominator == []\n                and len(self.numerator) == 1\n                and self.numerator[0].is_equivalent(other)\n            ):\n                return True\n\n            if issubclass(other.unit_type, AliasMeasurementUnit):\n                return (\n                    other.unit_type.aliased_generic_descriptor() ** other.power\n                ).is_equivalent(self)\n\n        elif isinstance(other, GenericCompositeDimension):\n            _generic = other.analysed().simplified()\n            _self = self.analysed().simplified()\n\n            return Counter(_self.numerator) == Counter(_generic.numerator) and (\n                Counter(_self.denominator) == Counter(_generic.denominator)\n            )\n\n        return False\n\n    def _numerator_copy(self) -&gt; List[GenericDimension]:\n        return [replace(n) for n in self.numerator]\n\n    def _denominator_copy(self) -&gt; List[GenericDimension]:\n        return [replace(d) for d in self.denominator]\n\n    def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines multiplication between GenericCompositeDimension(s) and other generic\n        descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; (TemperatureUnit / LengthUnit) * TimeUnit\n            &lt;GenericCompositeDimension: TemperatureUnit * TimeUnit / LengthUnit&gt;\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(generic, GenericCompositeDimension):\n            numerator.extend(generic.numerator)\n            denominator.extend(generic.denominator)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n\n        if isinstance(generic, GenericDimension):\n            numerator.append(generic)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n\n        if isinstance(generic, MeasurementUnitType):\n            numerator.append(GenericDimension(generic))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n\n    def __truediv__(\n        self, generic: GenericUnitDescriptor\n    ) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines division between GenericCompositeDimension(s) and other generic\n        descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; (TemperatureUnit * LengthUnit) / TimeUnit\n            &lt;GenericCompositeDimension: LengthUnit * TemperatureUnit / TimeUnit&gt;\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(generic, GenericCompositeDimension):\n            numerator.extend(generic.denominator)\n            denominator.extend(generic.numerator)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, GenericDimension):\n            denominator.append(generic)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, MeasurementUnitType):\n            denominator.append(GenericDimension(generic))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n\n    def __pow__(self, power: float) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines exponentiation for GenericCompositeDimension(s).\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n            &gt;&gt;&gt; (TemperatureUnit / TimeUnit)**2\n            &lt;GenericCompositeDimension: (TemperatureUnit^2) / (TimeUnit^2)&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        numerator = [n**power for n in self._numerator_copy()]\n        denominator = [d**power for d in self._denominator_copy()]\n        return GenericCompositeDimension(numerator, denominator)\n\n    def __eq__(self, generic) -&gt; bool:\n        \"\"\"\n        Defines equality for GenericCompositeDimension(s).\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; (TemperatureUnit / TimeUnit) != (TimeUnit / TemperatureUnit)\n            True\n        \"\"\"\n        if not isinstance(generic, GenericCompositeDimension):\n            return False\n        return Counter(self.numerator) == Counter(generic.numerator) and (\n            Counter(self.denominator) == Counter(generic.denominator)\n        )\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __str__(self) -&gt; str:\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return numerators + denominators\n\n    def __repr__(self) -&gt; str:\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return f\"&lt;GenericCompositeDimension: {numerators + denominators}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__eq__","title":"<code>__eq__(generic)</code>","text":"<p>Defines equality for GenericCompositeDimension(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; (TemperatureUnit / TimeUnit) != (TimeUnit / TemperatureUnit)\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, generic) -&gt; bool:\n    \"\"\"\n    Defines equality for GenericCompositeDimension(s).\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (TemperatureUnit / TimeUnit) != (TimeUnit / TemperatureUnit)\n        True\n    \"\"\"\n    if not isinstance(generic, GenericCompositeDimension):\n        return False\n    return Counter(self.numerator) == Counter(generic.numerator) and (\n        Counter(self.denominator) == Counter(generic.denominator)\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__mul__","title":"<code>__mul__(generic)</code>","text":"<p>Defines multiplication between GenericCompositeDimension(s) and other generic descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; (TemperatureUnit / LengthUnit) * TimeUnit\n&lt;GenericCompositeDimension: TemperatureUnit * TimeUnit / LengthUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines multiplication between GenericCompositeDimension(s) and other generic\n    descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (TemperatureUnit / LengthUnit) * TimeUnit\n        &lt;GenericCompositeDimension: TemperatureUnit * TimeUnit / LengthUnit&gt;\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(generic, GenericCompositeDimension):\n        numerator.extend(generic.numerator)\n        denominator.extend(generic.denominator)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n\n    if isinstance(generic, GenericDimension):\n        numerator.append(generic)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n\n    if isinstance(generic, MeasurementUnitType):\n        numerator.append(GenericDimension(generic))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for GenericCompositeDimension(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; (TemperatureUnit / TimeUnit)**2\n&lt;GenericCompositeDimension: (TemperatureUnit^2) / (TimeUnit^2)&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines exponentiation for GenericCompositeDimension(s).\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; (TemperatureUnit / TimeUnit)**2\n        &lt;GenericCompositeDimension: (TemperatureUnit^2) / (TimeUnit^2)&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    numerator = [n**power for n in self._numerator_copy()]\n    denominator = [d**power for d in self._denominator_copy()]\n    return GenericCompositeDimension(numerator, denominator)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__truediv__","title":"<code>__truediv__(generic)</code>","text":"<p>Defines division between GenericCompositeDimension(s) and other generic descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; (TemperatureUnit * LengthUnit) / TimeUnit\n&lt;GenericCompositeDimension: LengthUnit * TemperatureUnit / TimeUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(\n    self, generic: GenericUnitDescriptor\n) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines division between GenericCompositeDimension(s) and other generic\n    descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (TemperatureUnit * LengthUnit) / TimeUnit\n        &lt;GenericCompositeDimension: LengthUnit * TemperatureUnit / TimeUnit&gt;\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(generic, GenericCompositeDimension):\n        numerator.extend(generic.denominator)\n        denominator.extend(generic.numerator)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, GenericDimension):\n        denominator.append(generic)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, MeasurementUnitType):\n        denominator.append(GenericDimension(generic))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.analyse","title":"<code>analyse()</code>","text":"<p>Analyse this composite by replacing its alias units with their aliased units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls) -&gt; GenericCompositeDimension:\n...         return MassUnit / LengthUnit / (TimeUnit**2)\n</code></pre> <pre><code>&gt;&gt;&gt; composite = PressureUnit / LengthUnit\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: PressureUnit / LengthUnit&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; composite.analyse()\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: MassUnit / (TimeUnit^2) / LengthUnit / LengthUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def analyse(self) -&gt; None:\n    \"\"\"\n    Analyse this composite by replacing its alias units with their aliased units.\n\n    Examples:\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls) -&gt; GenericCompositeDimension:\n        ...         return MassUnit / LengthUnit / (TimeUnit**2)\n\n        &gt;&gt;&gt; composite = PressureUnit / LengthUnit\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: PressureUnit / LengthUnit&gt;\n\n        &gt;&gt;&gt; composite.analyse()\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: MassUnit / (TimeUnit^2) / LengthUnit / LengthUnit&gt;\n    \"\"\"\n    for n in self.numerator:\n        if issubclass(n.unit_type, AliasMeasurementUnit):\n            aliased = n.unit_type.aliased_generic_descriptor() ** n.power\n            if isinstance(aliased, GenericDimension):\n                self.numerator.append(aliased)\n            elif isinstance(aliased, GenericCompositeDimension):\n                self.numerator.extend(aliased.numerator)\n                self.denominator.extend(aliased.denominator)\n\n            self.numerator.remove(n)\n\n    for d in self.denominator:\n        if issubclass(d.unit_type, AliasMeasurementUnit):\n            aliased = d.unit_type.aliased_generic_descriptor() ** d.power\n            if isinstance(aliased, GenericDimension):\n                self.denominator.append(aliased)\n            elif isinstance(aliased, GenericCompositeDimension):\n                self.denominator.extend(aliased.numerator)\n                self.numerator.extend(aliased.denominator)\n\n            self.denominator.remove(d)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.analysed","title":"<code>analysed()</code>","text":"<p>Returns an analysed version of this composite generic as a new object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls) -&gt; GenericCompositeDimension:\n...         return MassUnit / LengthUnit / (TimeUnit**2)\n</code></pre> <pre><code>&gt;&gt;&gt; composite = PressureUnit / LengthUnit\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: PressureUnit / LengthUnit&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; composite.analysed()\n&lt;GenericCompositeDimension: MassUnit / (TimeUnit^2) / LengthUnit / LengthUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def analysed(self) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Returns an analysed version of this composite generic as a new object.\n\n    Examples:\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls) -&gt; GenericCompositeDimension:\n        ...         return MassUnit / LengthUnit / (TimeUnit**2)\n\n        &gt;&gt;&gt; composite = PressureUnit / LengthUnit\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: PressureUnit / LengthUnit&gt;\n\n        &gt;&gt;&gt; composite.analysed()\n        &lt;GenericCompositeDimension: MassUnit / (TimeUnit^2) / LengthUnit / LengthUnit&gt;\n    \"\"\"\n    copy = replace(self)\n    copy.analyse()\n    return copy\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; (LengthUnit / TimeUnit).inverse_generic()\n&lt;GenericCompositeDimension: TimeUnit / LengthUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(self):\n    \"\"\"\n    Create a generic composite with inverse units.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; (LengthUnit / TimeUnit).inverse_generic()\n        &lt;GenericCompositeDimension: TimeUnit / LengthUnit&gt;\n    \"\"\"\n    return GenericCompositeDimension(\n        self._denominator_copy(), self._numerator_copy()\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Returns True if this generic is equivalent to the given one, False otherwise.</p> <p>A generic can be equivalent with another generic if the latter or the former is an alias.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return MassUnit * LengthUnit / (TimeUnit**2)\n</code></pre> <pre><code>&gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return ForceUnit * LengthUnit\n</code></pre> <pre><code>&gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def is_equivalent(self, other: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if this generic is equivalent to the given one, False otherwise.\n\n    A generic can be equivalent with another generic if the latter or the former\n    is an alias.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n        &gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\n        True\n\n        &gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return ForceUnit * LengthUnit\n\n        &gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\n        True\n    \"\"\"\n    if isinstance(other, MeasurementUnitType):\n        if (\n            self.denominator == []\n            and len(self.numerator) == 1\n            and self.numerator[0].is_equivalent(other)\n        ):\n            return True\n\n        if issubclass(other, AliasMeasurementUnit):\n            return other.aliased_generic_descriptor().is_equivalent(self)  # type: ignore[attr-defined]\n\n    elif isinstance(other, GenericDimension):\n        if (\n            self.denominator == []\n            and len(self.numerator) == 1\n            and self.numerator[0].is_equivalent(other)\n        ):\n            return True\n\n        if issubclass(other.unit_type, AliasMeasurementUnit):\n            return (\n                other.unit_type.aliased_generic_descriptor() ** other.power\n            ).is_equivalent(self)\n\n    elif isinstance(other, GenericCompositeDimension):\n        _generic = other.analysed().simplified()\n        _self = self.analysed().simplified()\n\n        return Counter(_self.numerator) == Counter(_generic.numerator) and (\n            Counter(_self.denominator) == Counter(_generic.denominator)\n        )\n\n    return False\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.simplified","title":"<code>simplified()</code>","text":"<p>Returns a simplified version of this composite generic as a new object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n&gt;&gt;&gt; composite.simplified()\n&lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit /TimeUnit\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n&gt;&gt;&gt; composite.simplified()\n&lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplified(self) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Returns a simplified version of this composite generic as a new object.\n\n    Examples:\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit /TimeUnit\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n    \"\"\"\n    copy = replace(self)\n    copy.simplify()\n    return copy\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.simplify","title":"<code>simplify()</code>","text":"<p>Simplify the composite by merging common dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n</code></pre> <pre><code>&gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n&gt;&gt;&gt; composite.simplify()\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit / TimeUnit\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n&gt;&gt;&gt; composite.simplify()\n&gt;&gt;&gt; composite\n&lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplify(self) -&gt; None:\n    \"\"\"\n    Simplify the composite by merging common dimensions.\n\n    Examples:\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit / TimeUnit\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n    \"\"\"\n    exponents: Dict[MeasurementUnitType, float] = {}\n    for n in self.numerator:\n        if n.unit_type in exponents:\n            exponents[n.unit_type] += n.power\n        else:\n            exponents[n.unit_type] = n.power\n\n    for d in self.denominator:\n        if d.unit_type in exponents:\n            exponents[d.unit_type] -= d.power\n        else:\n            exponents[d.unit_type] = 0 - d.power\n\n    numerator = []\n    denominator = []\n    for unit_type, exponent in exponents.items():\n        if exponent &gt; 0:\n            numerator.append(GenericDimension(unit_type) ** exponent)\n        elif exponent &lt; 0:\n            denominator.append(GenericDimension(unit_type) ** abs(exponent))\n\n    self.numerator = numerator\n    self.denominator = denominator\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.to_si","title":"<code>to_si()</code>","text":"<p>Create a CompositeDimension with SI units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n...     @classmethod\n...     def si(cls): return cls.KELVIN\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     SECOND = \"s\"\n...     @classmethod\n...     def si(cls): return cls.SECOND\n&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n...     @classmethod\n...     def si(cls): return cls.METER\n&gt;&gt;&gt; (TemperatureUnit * LengthUnit / TimeUnit).to_si()\n&lt;CompositeDimension: K * m / s&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a CompositeDimension with SI units.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n        ...     @classmethod\n        ...     def si(cls): return cls.KELVIN\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        ...     @classmethod\n        ...     def si(cls): return cls.SECOND\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        ...     @classmethod\n        ...     def si(cls): return cls.METER\n        &gt;&gt;&gt; (TemperatureUnit * LengthUnit / TimeUnit).to_si()\n        &lt;CompositeDimension: K * m / s&gt;\n    \"\"\"\n    return CompositeDimension(\n        [n.to_si() for n in self.numerator], [d.to_si() for d in self.denominator]\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension","title":"<code>GenericDimension</code>  <code>dataclass</code>","text":"<p>Represents a generic property unit or a generic property unit to some power.</p> <p>e.g. a generic dimension can be a temperature dimension or a volume dimension (length dimension to the 3rd power).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n&gt;&gt;&gt; MassUnit**2\n&lt;GenericDimension: MassUnit^2&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass GenericDimension:\n    \"\"\"\n    Represents a generic property unit or a generic property unit to some power.\n\n    e.g. a generic dimension can be a temperature dimension or a volume dimension\n    (length dimension to the 3rd power).\n\n    Examples:\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; MassUnit**2\n        &lt;GenericDimension: MassUnit^2&gt;\n    \"\"\"\n\n    unit_type: MeasurementUnitType\n    power: float = 1\n\n    def __init__(self, unit_type: MeasurementUnitType, power: float = 1) -&gt; None:\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.unit_type = unit_type\n        self.power = power\n\n    def to_si(self) -&gt; \"Dimension\":\n        \"\"\"\n        Create a Dimension with SI units.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            ...     KELVIN = \"K\"\n            ...     @classmethod\n            ...     def si(cls): return cls.KELVIN\n            &gt;&gt;&gt; (TemperatureUnit**2).to_si()\n            &lt;Dimension: K^2&gt;\n        \"\"\"\n        return Dimension(self.unit_type.to_si(), self.power)\n\n    def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Create a generic composite with inverse units.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; (LengthUnit**2).inverse_generic()\n            &lt;GenericCompositeDimension:  / (LengthUnit^2)&gt;\n        \"\"\"\n        return GenericCompositeDimension([], [replace(self)])\n\n    # pylint: disable=too-many-return-statements\n    def is_equivalent(self, other: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if this generic is equivalent to the given one, False otherwise.\n\n        A generic can be equivalent with another generic if the latter or the former\n        is an alias.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n            &gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\n            True\n\n            &gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return ForceUnit * LengthUnit\n\n            &gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\n            True\n        \"\"\"\n        if isinstance(other, MeasurementUnitType):\n            if self.unit_type == other and self.power == 1:\n                return True\n\n            if issubclass(other, AliasMeasurementUnit):\n                return other.aliased_generic_descriptor().is_equivalent(self)  # type: ignore[attr-defined]\n\n        elif isinstance(other, GenericDimension):\n            if self.unit_type == other.unit_type and self.power == other.power:\n                return True\n\n            if issubclass(other.unit_type, AliasMeasurementUnit):\n                return (\n                    other.unit_type.aliased_generic_descriptor() ** other.power\n                ).is_equivalent(self)\n\n            if issubclass(self.unit_type, AliasMeasurementUnit):\n                return (\n                    self.unit_type.aliased_generic_descriptor() ** self.power\n                ).is_equivalent(other)\n\n        elif isinstance(other, GenericCompositeDimension):\n            if (\n                other.denominator == []\n                and len(other.numerator) == 1\n                and other.numerator[0].is_equivalent(self)\n            ):\n                return True\n\n            if issubclass(self.unit_type, AliasMeasurementUnit):\n                return (\n                    self.unit_type.aliased_generic_descriptor() ** self.power\n                ).is_equivalent(other)\n\n        return False\n\n    def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines multiplication between GenericDimension(s) and other generic\n        descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; (TemperatureUnit**2) * TimeUnit\n            &lt;GenericCompositeDimension: (TemperatureUnit^2) * TimeUnit&gt;\n        \"\"\"\n        if isinstance(generic, GenericCompositeDimension):\n            numerator = generic.numerator.copy()\n            denominator = generic.denominator.copy()\n            numerator.append(self)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, GenericDimension):\n            return GenericCompositeDimension(numerator=[self, generic])\n        if isinstance(generic, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[self, GenericDimension(generic)]\n            )\n        raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n\n    def __truediv__(\n        self, generic: GenericUnitDescriptor\n    ) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines division between GenericDimension(s) and other generic descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; TemperatureUnit / (TimeUnit**2)\n            &lt;GenericCompositeDimension: TemperatureUnit / (TimeUnit^2)&gt;\n        \"\"\"\n        if isinstance(generic, GenericCompositeDimension):\n            numerator = generic.denominator.copy()\n            denominator = generic.numerator.copy()\n            numerator.append(self)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, GenericDimension):\n            return GenericCompositeDimension(numerator=[self], denominator=[generic])\n        if isinstance(generic, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[self], denominator=[GenericDimension(generic)]\n            )\n        raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n\n    def __pow__(self, power: float) -&gt; \"GenericDimension\":\n        \"\"\"\n        Defines exponentiation of GenericDimension.\n\n        Examples:\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; (TimeUnit**2)**3\n            &lt;GenericDimension: TimeUnit^6&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.power *= power\n        return self\n\n    def __eq__(self, generic) -&gt; bool:\n        \"\"\"\n        Defines equality for GenericDimension(s).\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; (TemperatureUnit**2) != TemperatureUnit\n            True\n        \"\"\"\n        if not isinstance(generic, GenericDimension):\n            return False\n        return self.unit_type == generic.unit_type and self.power == generic.power\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __str__(self) -&gt; str:\n        s = self.unit_type.__name__\n        if self.power != 1:\n            return f\"({s}^{self.power})\"\n        return s\n\n    def __repr__(self) -&gt; str:\n        if self.power != 1:\n            return f\"&lt;GenericDimension: {self.unit_type.__name__}^{self.power}&gt;\"\n        return f\"&lt;GenericDimension: {self.unit_type.__name__}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__eq__","title":"<code>__eq__(generic)</code>","text":"<p>Defines equality for GenericDimension(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; (TemperatureUnit**2) != TemperatureUnit\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, generic) -&gt; bool:\n    \"\"\"\n    Defines equality for GenericDimension(s).\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (TemperatureUnit**2) != TemperatureUnit\n        True\n    \"\"\"\n    if not isinstance(generic, GenericDimension):\n        return False\n    return self.unit_type == generic.unit_type and self.power == generic.power\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__mul__","title":"<code>__mul__(generic)</code>","text":"<p>Defines multiplication between GenericDimension(s) and other generic descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; (TemperatureUnit**2) * TimeUnit\n&lt;GenericCompositeDimension: (TemperatureUnit^2) * TimeUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines multiplication between GenericDimension(s) and other generic\n    descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (TemperatureUnit**2) * TimeUnit\n        &lt;GenericCompositeDimension: (TemperatureUnit^2) * TimeUnit&gt;\n    \"\"\"\n    if isinstance(generic, GenericCompositeDimension):\n        numerator = generic.numerator.copy()\n        denominator = generic.denominator.copy()\n        numerator.append(self)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, GenericDimension):\n        return GenericCompositeDimension(numerator=[self, generic])\n    if isinstance(generic, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[self, GenericDimension(generic)]\n        )\n    raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation of GenericDimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; (TimeUnit**2)**3\n&lt;GenericDimension: TimeUnit^6&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"GenericDimension\":\n    \"\"\"\n    Defines exponentiation of GenericDimension.\n\n    Examples:\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (TimeUnit**2)**3\n        &lt;GenericDimension: TimeUnit^6&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    self.power *= power\n    return self\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__truediv__","title":"<code>__truediv__(generic)</code>","text":"<p>Defines division between GenericDimension(s) and other generic descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; TemperatureUnit / (TimeUnit**2)\n&lt;GenericCompositeDimension: TemperatureUnit / (TimeUnit^2)&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(\n    self, generic: GenericUnitDescriptor\n) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines division between GenericDimension(s) and other generic descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; TemperatureUnit / (TimeUnit**2)\n        &lt;GenericCompositeDimension: TemperatureUnit / (TimeUnit^2)&gt;\n    \"\"\"\n    if isinstance(generic, GenericCompositeDimension):\n        numerator = generic.denominator.copy()\n        denominator = generic.numerator.copy()\n        numerator.append(self)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, GenericDimension):\n        return GenericCompositeDimension(numerator=[self], denominator=[generic])\n    if isinstance(generic, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[self], denominator=[GenericDimension(generic)]\n        )\n    raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; (LengthUnit**2).inverse_generic()\n&lt;GenericCompositeDimension:  / (LengthUnit^2)&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Create a generic composite with inverse units.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (LengthUnit**2).inverse_generic()\n        &lt;GenericCompositeDimension:  / (LengthUnit^2)&gt;\n    \"\"\"\n    return GenericCompositeDimension([], [replace(self)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Returns True if this generic is equivalent to the given one, False otherwise.</p> <p>A generic can be equivalent with another generic if the latter or the former is an alias.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return MassUnit * LengthUnit / (TimeUnit**2)\n</code></pre> <pre><code>&gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return ForceUnit * LengthUnit\n</code></pre> <pre><code>&gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def is_equivalent(self, other: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if this generic is equivalent to the given one, False otherwise.\n\n    A generic can be equivalent with another generic if the latter or the former\n    is an alias.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n        &gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\n        True\n\n        &gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return ForceUnit * LengthUnit\n\n        &gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\n        True\n    \"\"\"\n    if isinstance(other, MeasurementUnitType):\n        if self.unit_type == other and self.power == 1:\n            return True\n\n        if issubclass(other, AliasMeasurementUnit):\n            return other.aliased_generic_descriptor().is_equivalent(self)  # type: ignore[attr-defined]\n\n    elif isinstance(other, GenericDimension):\n        if self.unit_type == other.unit_type and self.power == other.power:\n            return True\n\n        if issubclass(other.unit_type, AliasMeasurementUnit):\n            return (\n                other.unit_type.aliased_generic_descriptor() ** other.power\n            ).is_equivalent(self)\n\n        if issubclass(self.unit_type, AliasMeasurementUnit):\n            return (\n                self.unit_type.aliased_generic_descriptor() ** self.power\n            ).is_equivalent(other)\n\n    elif isinstance(other, GenericCompositeDimension):\n        if (\n            other.denominator == []\n            and len(other.numerator) == 1\n            and other.numerator[0].is_equivalent(self)\n        ):\n            return True\n\n        if issubclass(self.unit_type, AliasMeasurementUnit):\n            return (\n                self.unit_type.aliased_generic_descriptor() ** self.power\n            ).is_equivalent(other)\n\n    return False\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.to_si","title":"<code>to_si()</code>","text":"<p>Create a Dimension with SI units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n...     KELVIN = \"K\"\n...     @classmethod\n...     def si(cls): return cls.KELVIN\n&gt;&gt;&gt; (TemperatureUnit**2).to_si()\n&lt;Dimension: K^2&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(self) -&gt; \"Dimension\":\n    \"\"\"\n    Create a Dimension with SI units.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        ...     KELVIN = \"K\"\n        ...     @classmethod\n        ...     def si(cls): return cls.KELVIN\n        &gt;&gt;&gt; (TemperatureUnit**2).to_si()\n        &lt;Dimension: K^2&gt;\n    \"\"\"\n    return Dimension(self.unit_type.to_si(), self.power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericUnitDescriptor","title":"<code>GenericUnitDescriptor</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Descriptor for a property unit that does not have a specific unit.</p> <p>e.g. a  generic descriptor can represent a Temperature unit that does not have a specific value like Celcius or Fahrenheit.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class GenericUnitDescriptor(Protocol):\n    \"\"\"\n    Descriptor for a property unit that does not have a specific unit.\n\n    e.g. a  generic descriptor can represent a Temperature unit that does not have a\n    specific value like Celcius or Fahrenheit.\n    \"\"\"\n\n    def to_si(self) -&gt; \"UnitDescriptor\":\n        \"\"\"\n        Create a unit descriptor with SI units.\n        \"\"\"\n\n    def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Create a generic composite with inverse units.\n        \"\"\"\n\n    def is_equivalent(self, other: \"GenericUnitDescriptor\") -&gt; bool:\n        \"\"\"\n        Returns True if this generic is equivalent to the given one, False otherwise.\n\n        A generic can be equivalent with another generic if the latter or the former\n        is an alias.\n        \"\"\"\n\n    def __mul__(\n        self, generic: \"GenericUnitDescriptor\"\n    ) -&gt; \"GenericCompositeDimension\": ...\n\n    def __truediv__(\n        self, generic: \"GenericUnitDescriptor\"\n    ) -&gt; \"GenericCompositeDimension\": ...\n\n    def __pow__(self, power: float) -&gt; \"GenericUnitDescriptor\": ...\n\n    def __eq__(self, generic) -&gt; bool: ...\n\n    def __hash__(self) -&gt; int: ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericUnitDescriptor.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Create a generic composite with inverse units.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericUnitDescriptor.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Returns True if this generic is equivalent to the given one, False otherwise.</p> <p>A generic can be equivalent with another generic if the latter or the former is an alias.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def is_equivalent(self, other: \"GenericUnitDescriptor\") -&gt; bool:\n    \"\"\"\n    Returns True if this generic is equivalent to the given one, False otherwise.\n\n    A generic can be equivalent with another generic if the latter or the former\n    is an alias.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericUnitDescriptor.to_si","title":"<code>to_si()</code>","text":"<p>Create a unit descriptor with SI units.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(self) -&gt; \"UnitDescriptor\":\n    \"\"\"\n    Create a unit descriptor with SI units.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit","title":"<code>MeasurementUnit</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Base class for all measurement units of physical quantities.</p> <p>Each measurement-unit class is an enumeration of the available units for a quantity.</p> <p>Subclasses should only enumerate measurement units of primitive physical quantities, i.e. units that cannot be produced from other units. e.g. length is an acceptable quantity, but volume is not because its' units are produced from length units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n...     KELVIN = \"K\"\n...     RANKINE = \"R\"\n...     FAHRENHEIT = \"F\"\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class MeasurementUnit(Enum, metaclass=MeasurementUnitMeta):\n    \"\"\"\n    Base class for all measurement units of physical quantities.\n\n    Each measurement-unit class is an enumeration of the available units for a\n    quantity.\n\n    Subclasses should only enumerate measurement units of primitive physical\n    quantities, i.e. units that cannot be produced from other units.\n    e.g. length is an acceptable quantity, but volume is not because its' units are\n    produced from length units.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        ...     KELVIN = \"K\"\n        ...     RANKINE = \"R\"\n        ...     FAHRENHEIT = \"F\"\n    \"\"\"\n\n    @classmethod\n    def si(cls) -&gt; \"MeasurementUnit\":\n        \"\"\"\n        Returns the SI unit of this measurement unit.\n        \"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; \"MeasurementUnit\":\n        \"\"\"\n        Create a MeasurementUnit from given descriptor.\n        If descriptor is already a MeasurementUnit, it returns the same object.\n\n        This function does not serve as a constructor for MeasurementUnit, rather it\n        is intended to be used to convert an unknown unit descriptor to a\n        MeasurementUnit.\n\n        Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n        to a MeasurementUnit instance.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n\n            &gt;&gt;&gt; celcius = MeasurementUnit.from_descriptor(TemperatureUnit.CELCIUS**2)\n            &gt;&gt;&gt; celcius\n            &lt;TemperatureUnit: C&gt;\n        \"\"\"\n        if isinstance(descriptor, Dimension):\n            return descriptor.unit\n        if isinstance(descriptor, MeasurementUnit):\n            return descriptor\n        raise UnitDescriptorTypeError(\n            f\"cannot create MeasurementUnit from descriptor: {descriptor}\"\n        )\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the MeasurementUnit is an instance of the generic, False\n        otherwise.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     METER = \"m\"\n\n            &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(TemperatureUnit)\n            True\n\n            &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(LengthUnit)\n            False\n        \"\"\"\n        return type(self) == generic  # pylint: disable=unidiomatic-typecheck\n\n    def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n        False otherwise.\n\n        A unit descriptor is an instance-equivalent of a generic if the generic of the\n        unit descriptor is equivalent to the generic.\n\n        Equivalence between generics is checked with the `is_equivalent` method.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n            ...     HECTARE = \"ha\"\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls): return LengthUnit**2\n\n            &gt;&gt;&gt; AreaUnit.HECTARE.isinstance_equivalent(AreaUnit)\n            True\n            &gt;&gt;&gt; AreaUnit.HECTARE.isinstance_equivalent(LengthUnit**2)\n            True\n        \"\"\"\n        return self.to_generic().is_equivalent(generic)\n\n    def to_generic(self) -&gt; GenericUnitDescriptor:\n        \"\"\"\n        Create a generic descriptor from this MeasurementUnit.\n\n        Examples:\n            &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n            ...     MOL = \"mol\"\n\n            &gt;&gt;&gt; AmountUnit.MOL.to_generic()\n            &lt;MeasurementUnit: AmountUnit&gt;\n        \"\"\"\n        return self.__class__\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     KELVIN = \"K\"\n            &gt;&gt;&gt; TemperatureUnit.KELVIN.inverse()\n            &lt;CompositeDimension:  / K&gt;\n        \"\"\"\n        return CompositeDimension([], [Dimension(self)])\n\n    def __mul__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between MeasurementUnit objects and other unit descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     FAHRENHEIT = \"F\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     HOUR = \"hr\"\n            &gt;&gt;&gt; TemperatureUnit.FAHRENHEIT * TimeUnit.HOUR\n            &lt;CompositeDimension: F * hr&gt;\n        \"\"\"\n        if isinstance(descriptor, MeasurementUnit):\n            return Dimension(self) * Dimension(descriptor)\n        if isinstance(descriptor, (Dimension, CompositeDimension)):\n            return Dimension(self) * descriptor\n        raise DescriptorBinaryOperationError(\n            f\"cannot multiply {self} with {descriptor}. \"\n        )\n\n    def __truediv__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines division between MeasurementUnit objects and other unit descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     FAHRENHEIT = \"F\"\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n            ...     HOUR = \"hr\"\n            &gt;&gt;&gt; TemperatureUnit.FAHRENHEIT / TimeUnit.HOUR\n            &lt;CompositeDimension: F / hr&gt;\n        \"\"\"\n        if isinstance(descriptor, MeasurementUnit):\n            return Dimension(self) / Dimension(descriptor)\n        if isinstance(descriptor, (Dimension, CompositeDimension)):\n            return Dimension(self) / descriptor\n        raise DescriptorBinaryOperationError(\n            f\"cannot divide {self} with {descriptor}. \"\n        )\n\n    def __pow__(self, power: float) -&gt; \"Dimension\":\n        \"\"\"\n        Defines exponentiation of MeasurementUnit objects.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n            ...     FEET = \"ft\"\n            &gt;&gt;&gt; LengthUnit.FEET**3\n            &lt;Dimension: ft^3&gt;\n        \"\"\"\n        return Dimension(self, power)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.value)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}: {str(self)}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.__mul__","title":"<code>__mul__(descriptor)</code>","text":"<p>Defines multiplication between MeasurementUnit objects and other unit descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     FAHRENHEIT = \"F\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     HOUR = \"hr\"\n&gt;&gt;&gt; TemperatureUnit.FAHRENHEIT * TimeUnit.HOUR\n&lt;CompositeDimension: F * hr&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between MeasurementUnit objects and other unit descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     FAHRENHEIT = \"F\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n        &gt;&gt;&gt; TemperatureUnit.FAHRENHEIT * TimeUnit.HOUR\n        &lt;CompositeDimension: F * hr&gt;\n    \"\"\"\n    if isinstance(descriptor, MeasurementUnit):\n        return Dimension(self) * Dimension(descriptor)\n    if isinstance(descriptor, (Dimension, CompositeDimension)):\n        return Dimension(self) * descriptor\n    raise DescriptorBinaryOperationError(\n        f\"cannot multiply {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation of MeasurementUnit objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     FEET = \"ft\"\n&gt;&gt;&gt; LengthUnit.FEET**3\n&lt;Dimension: ft^3&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"Dimension\":\n    \"\"\"\n    Defines exponentiation of MeasurementUnit objects.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     FEET = \"ft\"\n        &gt;&gt;&gt; LengthUnit.FEET**3\n        &lt;Dimension: ft^3&gt;\n    \"\"\"\n    return Dimension(self, power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.__truediv__","title":"<code>__truediv__(descriptor)</code>","text":"<p>Defines division between MeasurementUnit objects and other unit descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     FAHRENHEIT = \"F\"\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n...     HOUR = \"hr\"\n&gt;&gt;&gt; TemperatureUnit.FAHRENHEIT / TimeUnit.HOUR\n&lt;CompositeDimension: F / hr&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines division between MeasurementUnit objects and other unit descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     FAHRENHEIT = \"F\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n        &gt;&gt;&gt; TemperatureUnit.FAHRENHEIT / TimeUnit.HOUR\n        &lt;CompositeDimension: F / hr&gt;\n    \"\"\"\n    if isinstance(descriptor, MeasurementUnit):\n        return Dimension(self) / Dimension(descriptor)\n    if isinstance(descriptor, (Dimension, CompositeDimension)):\n        return Dimension(self) / descriptor\n    raise DescriptorBinaryOperationError(\n        f\"cannot divide {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create a MeasurementUnit from given descriptor. If descriptor is already a MeasurementUnit, it returns the same object.</p> <p>This function does not serve as a constructor for MeasurementUnit, rather it is intended to be used to convert an unknown unit descriptor to a MeasurementUnit.</p> <p>Raises <code>UnitDescriptorTypeError</code> if given descriptor cannot be translated to a MeasurementUnit instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n</code></pre> <pre><code>&gt;&gt;&gt; celcius = MeasurementUnit.from_descriptor(TemperatureUnit.CELCIUS**2)\n&gt;&gt;&gt; celcius\n&lt;TemperatureUnit: C&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; \"MeasurementUnit\":\n    \"\"\"\n    Create a MeasurementUnit from given descriptor.\n    If descriptor is already a MeasurementUnit, it returns the same object.\n\n    This function does not serve as a constructor for MeasurementUnit, rather it\n    is intended to be used to convert an unknown unit descriptor to a\n    MeasurementUnit.\n\n    Raises `UnitDescriptorTypeError` if given descriptor cannot be translated\n    to a MeasurementUnit instance.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; celcius = MeasurementUnit.from_descriptor(TemperatureUnit.CELCIUS**2)\n        &gt;&gt;&gt; celcius\n        &lt;TemperatureUnit: C&gt;\n    \"\"\"\n    if isinstance(descriptor, Dimension):\n        return descriptor.unit\n    if isinstance(descriptor, MeasurementUnit):\n        return descriptor\n    raise UnitDescriptorTypeError(\n        f\"cannot create MeasurementUnit from descriptor: {descriptor}\"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     KELVIN = \"K\"\n&gt;&gt;&gt; TemperatureUnit.KELVIN.inverse()\n&lt;CompositeDimension:  / K&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n        &gt;&gt;&gt; TemperatureUnit.KELVIN.inverse()\n        &lt;CompositeDimension:  / K&gt;\n    \"\"\"\n    return CompositeDimension([], [Dimension(self)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the MeasurementUnit is an instance of the generic, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n</code></pre> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n...     METER = \"m\"\n</code></pre> <pre><code>&gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(TemperatureUnit)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(LengthUnit)\nFalse\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the MeasurementUnit is an instance of the generic, False\n    otherwise.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(TemperatureUnit)\n        True\n\n        &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(LengthUnit)\n        False\n    \"\"\"\n    return type(self) == generic  # pylint: disable=unidiomatic-typecheck\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.isinstance_equivalent","title":"<code>isinstance_equivalent(generic)</code>","text":"<p>Returns True if the UnitDescriptor is an instance-equivalent of the generic, False otherwise.</p> <p>A unit descriptor is an instance-equivalent of a generic if the generic of the unit descriptor is equivalent to the generic.</p> <p>Equivalence between generics is checked with the <code>is_equivalent</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n...     HECTARE = \"ha\"\n...     @classmethod\n...     def aliased_generic_descriptor(cls): return LengthUnit**2\n</code></pre> <pre><code>&gt;&gt;&gt; AreaUnit.HECTARE.isinstance_equivalent(AreaUnit)\nTrue\n&gt;&gt;&gt; AreaUnit.HECTARE.isinstance_equivalent(LengthUnit**2)\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n    False otherwise.\n\n    A unit descriptor is an instance-equivalent of a generic if the generic of the\n    unit descriptor is equivalent to the generic.\n\n    Equivalence between generics is checked with the `is_equivalent` method.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n        ...     HECTARE = \"ha\"\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls): return LengthUnit**2\n\n        &gt;&gt;&gt; AreaUnit.HECTARE.isinstance_equivalent(AreaUnit)\n        True\n        &gt;&gt;&gt; AreaUnit.HECTARE.isinstance_equivalent(LengthUnit**2)\n        True\n    \"\"\"\n    return self.to_generic().is_equivalent(generic)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.si","title":"<code>si()</code>  <code>classmethod</code>","text":"<p>Returns the SI unit of this measurement unit.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@classmethod\ndef si(cls) -&gt; \"MeasurementUnit\":\n    \"\"\"\n    Returns the SI unit of this measurement unit.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this MeasurementUnit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n...     MOL = \"mol\"\n</code></pre> <pre><code>&gt;&gt;&gt; AmountUnit.MOL.to_generic()\n&lt;MeasurementUnit: AmountUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericUnitDescriptor:\n    \"\"\"\n    Create a generic descriptor from this MeasurementUnit.\n\n    Examples:\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n        ...     MOL = \"mol\"\n\n        &gt;&gt;&gt; AmountUnit.MOL.to_generic()\n        &lt;MeasurementUnit: AmountUnit&gt;\n    \"\"\"\n    return self.__class__\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta","title":"<code>MeasurementUnitMeta</code>","text":"<p>             Bases: <code>EnumMeta</code></p> <p>Metaclass for MeasurementUnit. Defines multiplication, division and exponent operations for MeasurementUnit class (and subclasses). These operations produce GenericUnitDescriptor(s).</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class MeasurementUnitMeta(EnumMeta):\n    \"\"\"\n    Metaclass for MeasurementUnit. Defines multiplication, division and exponent\n    operations for MeasurementUnit class (and subclasses). These operations produce\n    GenericUnitDescriptor(s).\n    \"\"\"\n\n    def to_si(cls) -&gt; \"MeasurementUnit\":\n        \"\"\"\n        Create a MeasurementUnit with SI units.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n            ...     CELCIUS = \"C\"\n            ...     KELVIN = \"K\"\n            ...     @classmethod\n            ...     def si(cls):\n            ...         return cls.KELVIN\n            &gt;&gt;&gt; TemperatureUnit.to_si()\n            &lt;TemperatureUnit: K&gt;\n        \"\"\"\n        if hasattr(cls, \"si\"):\n            return cls.si()\n        raise NotImplementedError\n\n    def inverse_generic(cls) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Create a generic composite with inverse units.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; TemperatureUnit.inverse_generic()\n            &lt;GenericCompositeDimension:  / TemperatureUnit&gt;\n        \"\"\"\n        return GenericCompositeDimension([], [GenericDimension(cls)])\n\n    # pylint: disable=too-many-return-statements\n    def is_equivalent(cls, other: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if this generic is equivalent to the given one, False otherwise.\n\n        A generic can be equivalent with another generic if the latter or the former\n        is an alias.\n\n        Examples:\n            &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n            &gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\n            True\n\n            &gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n            ...     @classmethod\n            ...     def aliased_generic_descriptor(cls):\n            ...         return ForceUnit * LengthUnit\n\n            &gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\n            True\n        \"\"\"\n        if isinstance(other, MeasurementUnitType):\n            return cls == other\n\n        if isinstance(other, GenericDimension):\n            if cls == other.unit_type and other.power == 1:\n                return True\n\n            if issubclass(other.unit_type, AliasMeasurementUnit):\n                return (\n                    other.unit_type.aliased_generic_descriptor() ** other.power\n                ).is_equivalent(cls)\n\n            if issubclass(cls, AliasMeasurementUnit):\n                return cls.aliased_generic_descriptor().is_equivalent(other)\n\n        elif isinstance(other, GenericCompositeDimension):\n            if (\n                other.denominator == []\n                and len(other.numerator) == 1\n                and other.numerator[0].is_equivalent(cls)\n            ):\n                return True\n\n            if issubclass(cls, AliasMeasurementUnit):\n                return cls.aliased_generic_descriptor().is_equivalent(other)\n\n        return False\n\n    def __mul__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines multiplication between MeasurementUnit types and other generic\n        descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; TemperatureUnit * TimeUnit\n            &lt;GenericCompositeDimension: TemperatureUnit * TimeUnit&gt;\n        \"\"\"\n        if isinstance(other, GenericCompositeDimension):\n            numerator = other.numerator.copy()\n            denominator = other.denominator.copy()\n            numerator.append(GenericDimension(cls))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(other, GenericDimension):\n            return GenericCompositeDimension(numerator=[GenericDimension(cls), other])\n        if isinstance(other, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[\n                    GenericDimension(cls),\n                    GenericDimension(other),\n                ]\n            )\n        raise DescriptorBinaryOperationError(f\"cannot multiply {cls} with {other}. \")\n\n    def __truediv__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines division between MeasurementUnit types and other generic\n        descriptors.\n\n        Examples:\n            &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; TemperatureUnit / TimeUnit\n            &lt;GenericCompositeDimension: TemperatureUnit / TimeUnit&gt;\n        \"\"\"\n        if isinstance(other, GenericCompositeDimension):\n            numerator = other.denominator.copy()\n            denominator = other.numerator.copy()\n            numerator.append(GenericDimension(cls))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(other, GenericDimension):\n            return GenericCompositeDimension(\n                numerator=[GenericDimension(cls)], denominator=[other]\n            )\n        if isinstance(other, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[GenericDimension(cls)],\n                denominator=[GenericDimension(other)],\n            )\n        raise DescriptorBinaryOperationError(f\"cannot divide {cls} with {other}. \")\n\n    def __pow__(cls, power: float) -&gt; \"GenericDimension\":\n        \"\"\"\n        Defines exponentiation of MeasurementUnit types.\n\n        Examples:\n            &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n            &gt;&gt;&gt; TimeUnit**3\n            &lt;GenericDimension: TimeUnit^3&gt;\n        \"\"\"\n        return GenericDimension(cls, power)\n\n    def __str__(cls) -&gt; str:\n        return cls.__name__\n\n    def __repr__(cls) -&gt; str:\n        return f\"&lt;MeasurementUnit: {str(cls)}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Defines multiplication between MeasurementUnit types and other generic descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; TemperatureUnit * TimeUnit\n&lt;GenericCompositeDimension: TemperatureUnit * TimeUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines multiplication between MeasurementUnit types and other generic\n    descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; TemperatureUnit * TimeUnit\n        &lt;GenericCompositeDimension: TemperatureUnit * TimeUnit&gt;\n    \"\"\"\n    if isinstance(other, GenericCompositeDimension):\n        numerator = other.numerator.copy()\n        denominator = other.denominator.copy()\n        numerator.append(GenericDimension(cls))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(other, GenericDimension):\n        return GenericCompositeDimension(numerator=[GenericDimension(cls), other])\n    if isinstance(other, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[\n                GenericDimension(cls),\n                GenericDimension(other),\n            ]\n        )\n    raise DescriptorBinaryOperationError(f\"cannot multiply {cls} with {other}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation of MeasurementUnit types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; TimeUnit**3\n&lt;GenericDimension: TimeUnit^3&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(cls, power: float) -&gt; \"GenericDimension\":\n    \"\"\"\n    Defines exponentiation of MeasurementUnit types.\n\n    Examples:\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; TimeUnit**3\n        &lt;GenericDimension: TimeUnit^3&gt;\n    \"\"\"\n    return GenericDimension(cls, power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Defines division between MeasurementUnit types and other generic descriptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; TemperatureUnit / TimeUnit\n&lt;GenericCompositeDimension: TemperatureUnit / TimeUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines division between MeasurementUnit types and other generic\n    descriptors.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; TemperatureUnit / TimeUnit\n        &lt;GenericCompositeDimension: TemperatureUnit / TimeUnit&gt;\n    \"\"\"\n    if isinstance(other, GenericCompositeDimension):\n        numerator = other.denominator.copy()\n        denominator = other.numerator.copy()\n        numerator.append(GenericDimension(cls))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(other, GenericDimension):\n        return GenericCompositeDimension(\n            numerator=[GenericDimension(cls)], denominator=[other]\n        )\n    if isinstance(other, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[GenericDimension(cls)],\n            denominator=[GenericDimension(other)],\n        )\n    raise DescriptorBinaryOperationError(f\"cannot divide {cls} with {other}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n&gt;&gt;&gt; TemperatureUnit.inverse_generic()\n&lt;GenericCompositeDimension:  / TemperatureUnit&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(cls) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Create a generic composite with inverse units.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; TemperatureUnit.inverse_generic()\n        &lt;GenericCompositeDimension:  / TemperatureUnit&gt;\n    \"\"\"\n    return GenericCompositeDimension([], [GenericDimension(cls)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Returns True if this generic is equivalent to the given one, False otherwise.</p> <p>A generic can be equivalent with another generic if the latter or the former is an alias.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n&gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return MassUnit * LengthUnit / (TimeUnit**2)\n</code></pre> <pre><code>&gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n...     @classmethod\n...     def aliased_generic_descriptor(cls):\n...         return ForceUnit * LengthUnit\n</code></pre> <pre><code>&gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\nTrue\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def is_equivalent(cls, other: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if this generic is equivalent to the given one, False otherwise.\n\n    A generic can be equivalent with another generic if the latter or the former\n    is an alias.\n\n    Examples:\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class ForceUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return MassUnit * LengthUnit / (TimeUnit**2)\n\n        &gt;&gt;&gt; ForceUnit.is_equivalent(MassUnit * LengthUnit / (TimeUnit**2))\n        True\n\n        &gt;&gt;&gt; class EnergyUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return ForceUnit * LengthUnit\n\n        &gt;&gt;&gt; EnergyUnit.is_equivalent(MassUnit * (LengthUnit**2) / (TimeUnit**2))\n        True\n    \"\"\"\n    if isinstance(other, MeasurementUnitType):\n        return cls == other\n\n    if isinstance(other, GenericDimension):\n        if cls == other.unit_type and other.power == 1:\n            return True\n\n        if issubclass(other.unit_type, AliasMeasurementUnit):\n            return (\n                other.unit_type.aliased_generic_descriptor() ** other.power\n            ).is_equivalent(cls)\n\n        if issubclass(cls, AliasMeasurementUnit):\n            return cls.aliased_generic_descriptor().is_equivalent(other)\n\n    elif isinstance(other, GenericCompositeDimension):\n        if (\n            other.denominator == []\n            and len(other.numerator) == 1\n            and other.numerator[0].is_equivalent(cls)\n        ):\n            return True\n\n        if issubclass(cls, AliasMeasurementUnit):\n            return cls.aliased_generic_descriptor().is_equivalent(other)\n\n    return False\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.to_si","title":"<code>to_si()</code>","text":"<p>Create a MeasurementUnit with SI units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n...     CELCIUS = \"C\"\n...     KELVIN = \"K\"\n...     @classmethod\n...     def si(cls):\n...         return cls.KELVIN\n&gt;&gt;&gt; TemperatureUnit.to_si()\n&lt;TemperatureUnit: K&gt;\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(cls) -&gt; \"MeasurementUnit\":\n    \"\"\"\n    Create a MeasurementUnit with SI units.\n\n    Examples:\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        ...     KELVIN = \"K\"\n        ...     @classmethod\n        ...     def si(cls):\n        ...         return cls.KELVIN\n        &gt;&gt;&gt; TemperatureUnit.to_si()\n        &lt;TemperatureUnit: K&gt;\n    \"\"\"\n    if hasattr(cls, \"si\"):\n        return cls.si()\n    raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor","title":"<code>UnitDescriptor</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Descriptor for a property unit that has a specific unit, e.g. cm^2 or ft^2.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class UnitDescriptor(Protocol):\n    \"\"\"\n    Descriptor for a property unit that has a specific unit, e.g. cm^2 or ft^2.\n    \"\"\"\n\n    def si(self) -&gt; \"UnitDescriptor\":\n        \"\"\"\n        Returns this descriptor with SI units.\n        \"\"\"\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the UnitDescriptor is an instance of the generic, False\n        otherwise.\n\n        A unit descriptor is an instance of a generic if the generic of the unit\n        descriptor is equal to the generic.\n\n        Equality between generics is checked with the `==` operator.\n        \"\"\"\n\n    def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n        False otherwise.\n\n        A unit descriptor is an instance-equivalent of a generic if the generic of the\n        unit descriptor is equivalent to the generic.\n\n        Equivalence between generics is checked with the `is_equivalent` method.\n        \"\"\"\n\n    def to_generic(self) -&gt; GenericUnitDescriptor:\n        \"\"\"\n        Create a generic descriptor from this UnitDescriptor.\n        \"\"\"\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n        \"\"\"\n\n    def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\": ...\n\n    def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\": ...\n\n    def __pow__(self, power: float) -&gt; \"UnitDescriptor\": ...\n\n    def __hash__(self) -&gt; int: ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the UnitDescriptor is an instance of the generic, False otherwise.</p> <p>A unit descriptor is an instance of a generic if the generic of the unit descriptor is equal to the generic.</p> <p>Equality between generics is checked with the <code>==</code> operator.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the UnitDescriptor is an instance of the generic, False\n    otherwise.\n\n    A unit descriptor is an instance of a generic if the generic of the unit\n    descriptor is equal to the generic.\n\n    Equality between generics is checked with the `==` operator.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.isinstance_equivalent","title":"<code>isinstance_equivalent(generic)</code>","text":"<p>Returns True if the UnitDescriptor is an instance-equivalent of the generic, False otherwise.</p> <p>A unit descriptor is an instance-equivalent of a generic if the generic of the unit descriptor is equivalent to the generic.</p> <p>Equivalence between generics is checked with the <code>is_equivalent</code> method.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance_equivalent(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the UnitDescriptor is an instance-equivalent of the generic,\n    False otherwise.\n\n    A unit descriptor is an instance-equivalent of a generic if the generic of the\n    unit descriptor is equivalent to the generic.\n\n    Equivalence between generics is checked with the `is_equivalent` method.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.si","title":"<code>si()</code>","text":"<p>Returns this descriptor with SI units.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def si(self) -&gt; \"UnitDescriptor\":\n    \"\"\"\n    Returns this descriptor with SI units.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this UnitDescriptor.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericUnitDescriptor:\n    \"\"\"\n    Create a generic descriptor from this UnitDescriptor.\n    \"\"\"\n</code></pre>"},{"location":"feedback/","title":"Feedback","text":""},{"location":"feedback/#got-bugs-or-an-idea-for-a-new-feature","title":"Got bugs or an idea for a new feature?","text":"<p>Great! (well, not if you've got bugs) open up an issue in the project's repo: issues.</p>"},{"location":"installation/","title":"Installation","text":"<p>You'll need a Python version bigger or equal to 3.8. If you're new to programming this page could help with learning resources.  </p> <p>Once you've got Python setup you can install <code>property-utils</code> from your IDE or via pip:  <pre><code>pip install property-utils\n</code></pre></p>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p><code>property-utils</code>'s only dependency is the typing-extensions library.</p>"},{"location":"property/","title":"property","text":"<p>This module defines the Property class and property arithmetics.</p>"},{"location":"property/#property_utils.properties.property.Property","title":"<code>Property</code>  <code>dataclass</code>","text":"<p>A Property describes a value with a unit of measurement.</p> <p>A Property can have any 'value' or 'unit'; validations are not applied to it. For example, a Property with length units and negative value is valid.</p> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>@dataclass\nclass Property:\n    \"\"\"\n    A Property describes a value with a unit of measurement.\n\n    A Property can have any 'value' or 'unit'; validations are not applied to it.\n    For example, a Property with length units and negative value is valid.\n    \"\"\"\n\n    value: float\n    unit: UnitDescriptor\n    unit_converter: Optional[Type[UnitConverter]] = None\n\n    def __init__(self, value: float, unit: UnitDescriptor) -&gt; None:\n        if not isinstance(value, (float, int)):\n            raise PropertyValidationError(\n                f\"cannot create Property; invalid 'value': {value}; expected numeric. \"\n            )\n        if not isinstance(unit, (MeasurementUnit, Dimension, CompositeDimension)):\n            raise PropertyValidationError(\n                f\"cannot create Property; invalid 'unit': {unit}. Expected an instance\"\n                \" of one of: MeasurementUnit, Dimension, CompositeDimension. \"\n            )\n        self.value = value\n        self.unit = unit\n\n    def eq(self, other: \"Property\", *, rel_tol=1e-9, abs_tol=0) -&gt; bool:\n        \"\"\"\n        Perform equality comparison between this and some other Property. This method\n        of testing equality is preferable to the equality operator '==' because float\n        point tolerance is taken into account.\n\n        rel_tol is the maximum difference for being considered \"close\", relative\n        to the magnitude of the input values.\n        abs_tol is the maximum difference for being considered \"close\", regardless of\n        the magnitude of the input values.\n        For the values to be considered close, the difference between them must be\n        smaller than at least one of the tolerances.\n\n        Raises `PropertyBinaryOperationError` if an error occurs during conversion\n        of other's units.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T1 = Property(33.333333, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; T2 = Property(100/3, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; T1 == T2\n            False\n            &gt;&gt;&gt; T1.eq(T2)\n            False\n            &gt;&gt;&gt; T1.eq(T2, rel_tol=0.1)\n            True\n        \"\"\"\n        if not isinstance(other, Property):\n            return False\n        if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n            return False\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUtilsException as exc:\n            raise PropertyBinaryOperationError(\n                f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n                exc,\n            ) from None\n        return isclose(self.value, prop.value, rel_tol=rel_tol, abs_tol=abs_tol)\n\n    def to_si(self) -&gt; Self:\n        \"\"\"\n        Create a new property with SI units.\n\n        Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n        for the unit.\n\n        Raises `InvalidUnitConversion` if any error occurs in the unit conversion.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T.to_si()\n            &lt;Property: 373.15 K&gt;\n        \"\"\"\n        if isinstance(self.unit, MeasurementUnit):\n            return self.to_unit(self.unit.si())\n        if isinstance(self.unit, Dimension):\n            return self.to_unit(self.unit.unit.si() ** self.unit.power)\n        if isinstance(self.unit, CompositeDimension):\n            return self.to_unit(self.unit.to_generic().to_si())\n        raise PropertyValidationError(\n            f\"cannot convert Property to SI; 'unit' is invalid: {self.unit}. \"\n        )\n\n    def to_unit(self, unit: UnitDescriptor) -&gt; Self:\n        \"\"\"\n        Create a new property with specified unit.\n\n        Raises `PropertyUnitConversionError` if the unit is not of the same type.\n\n        Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n        for the unit.\n\n        Raises `UnitConversionError` if any error occurs in the unit conversion.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T.to_unit(RelativeTemperatureUnit.FAHRENHEIT)\n            &lt;Property: 212.0 \u00b0F&gt;\n        \"\"\"\n        if not unit.isinstance_equivalent(self.unit.to_generic()):\n            raise PropertyUnitConversionError(\n                f\"cannot convert {self} to ({unit}) units; 'unit' should be an instance\"\n                f\" of {self.unit.to_generic()}. \"\n            )\n        try:\n            converter = self._converter()\n        except UndefinedConverterError:\n            raise PropertyUnitConversionError(\n                f\"cannot convert property {self} to units: {unit}; no unit converter \"\n                f\" found for {unit.to_generic()}. \"\n                \"Did you forget to @register_converter? \"\n            ) from None\n        try:\n            value = converter.convert(self.value, self.unit, unit)\n        except UnitConversionError as exc:\n            raise exc from None\n        return self.__class__(value=value, unit=unit)\n\n    def __neg__(self) -&gt; Self:\n        \"\"\"\n        Defines negation of properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T = Property(3, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; -T\n            &lt;Property: -3 \u00b0C&gt;\n        \"\"\"\n        return self.__class__(-self.value, self.unit)\n\n    def __mul__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines multiplication between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; 2*T\n            &lt;Property: 600 K&gt;\n            &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n            &gt;&gt;&gt; T * A\n            &lt;Property: 3000 (m^2) * K&gt;\n        \"\"\"\n        if isinstance(other, (float, int)):\n            return Property(self.value * other, self.unit)\n        if isinstance(other, Property):\n            return Property(\n                self.value * other.value, (self.unit * other.unit).simplified()\n            )\n        raise PropertyBinaryOperationError(\n            f\"cannot multiply {self} with {other}; \"\n            \"second operand must be numeric or Property. \"\n        )\n\n    def __rmul__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines multiplication between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; 2*T\n            &lt;Property: 600 K&gt;\n            &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n            &gt;&gt;&gt; T * A\n            &lt;Property: 3000 (m^2) * K&gt;\n        \"\"\"\n        return self.__mul__(other)\n\n    def __truediv__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines division between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; T/2\n            &lt;Property: 250.0 K&gt;\n            &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n            &gt;&gt;&gt; T / A\n            &lt;Property: 50.0 K / (m^2)&gt;\n        \"\"\"\n        if isinstance(other, (float, int)):\n            try:\n                value = self.value / other\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator is zero. \"\n                ) from None\n            return Property(value, self.unit)\n        if isinstance(other, Property):\n            try:\n                value = self.value / other.value\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator's value is zero. \"\n                ) from None\n            return Property(value, (self.unit / other.unit).simplified())\n        raise PropertyBinaryOperationError(\n            f\"cannot divide {self} with {other}; \"\n            \"denominator must be numeric or Property. \"\n        )\n\n    def __rtruediv__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines right division between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit\n            &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; 100/T\n            &lt;Property: 0.2  / K&gt;\n        \"\"\"\n        if isinstance(other, (float, int)):\n            try:\n                value = other / self.value\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator is zero. \"\n                ) from None\n            return Property(value, self.unit.inverse())\n        if isinstance(other, Property):\n            try:\n                value = other.value / self.value\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator's value is zero. \"\n                ) from None\n            return Property(value, (other.unit / self.unit).simplified())\n        raise PropertyBinaryOperationError(\n            f\"cannot divide {self} with {other}; \"\n            \"numerator must be numeric or Property. \"\n        )\n\n    def __add__(self, other) -&gt; Self:\n        \"\"\"\n        Defines addition between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n            &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; x1 + x2\n            &lt;Property: 20 m&gt;\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise PropertyBinaryOperationError(\n                f\"cannot add {other} to ({self}); {other} is not a {self.__class__}; \"\n                \"only same properties can be added to each other. \"\n            )\n        if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot add ({other}) to ({self}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot add ({other}) to ({self}); ({other}) does not have the same \"\n                f\"units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot add ({other}) to ({self});\", exc\n            ) from None\n        return self.__class__(self.value + prop.value, self.unit)\n\n    def __radd__(self, other) -&gt; Self:\n        \"\"\"\n        Defines right addition between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n            &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; x1 + x2\n            &lt;Property: 20 m&gt;\n        \"\"\"\n        return self.__add__(other)\n\n    def __sub__(self, other) -&gt; Self:\n        \"\"\"\n        Defines subtraction between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n            &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n            &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n            &gt;&gt;&gt; t1 - t2\n            &lt;Property: 1.0 min&gt;\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract {other} from ({self}); {other} is not a \"\n                f\"{self.__class__}; only same properties can be subtracted from each \"\n                \"other. \"\n            )\n        if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({other}) from ({self}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({other}) from ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({other}) from ({self});\", exc\n            ) from None\n        return self.__class__(self.value - prop.value, self.unit)\n\n    def __rsub__(self, other) -&gt; Self:\n        \"\"\"\n        Defines right subtraction between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n            &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n            &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n            &gt;&gt;&gt; t1 - t2\n            &lt;Property: 1.0 min&gt;\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract {self} from ({other}); {other} is not a \"\n                f\"{self.__class__}; only same properties can be subtracted from each \"\n                \"other. \"\n            )\n        if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({self}) from ({other}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n        return other.__add__(-self)\n\n    def __pow__(self, power) -&gt; \"Property\":\n        \"\"\"\n        Defines exponentiation for properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; L = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; L**3\n            &lt;Property: 125 (m^3)&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise PropertyExponentError(\n                f\"invalid exponent: {power}; expected numeric. \"\n            )\n        return Property(self.value**power, self.unit**power)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Defines equality between properties.\n        Prefer Property.eq instead.The equality operator returns False even for very\n        small differences between floating point values.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n            &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; L1 == L2\n            True\n\n            &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n            &gt;&gt;&gt; L2 == L3\n            False\n        \"\"\"\n        if not isinstance(other, Property):\n            return False\n        if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n            return False\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUtilsException as exc:\n            raise PropertyBinaryOperationError(\n                f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n                exc,\n            ) from None\n        return self.value == prop.value\n\n    def __ne__(self, other) -&gt; bool:\n        \"\"\"\n        Defines inequality between properties.\n        Prefer Property.eq instead.The inequality operator returns True even for very\n        small differences between floating point values.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n            &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; L1 != L2\n            False\n\n            &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n            &gt;&gt;&gt; L2 != L3\n            True\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __gt__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &gt; T2\n            False\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &gt; prop.value\n\n    def __ge__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(212, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &gt;= T2\n            True\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &gt;= prop.value\n\n    def __lt__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &lt; T2\n            True\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &lt; prop.value\n\n    def __le__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &lt;= T2\n            True\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &lt;= prop.value\n\n    def __str__(self) -&gt; str:\n        return f\"{self.value} {self.unit}\"\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Property: {str(self)}&gt;\"\n\n    def _converter(self) -&gt; Type[UnitConverter]:\n        \"\"\"\n        Raises `UndefinedConverter` if a converter is not defined.\n        \"\"\"\n        if self.unit_converter is None:\n            self.unit_converter = self._get_converter()\n        return self.unit_converter\n\n    def _get_converter(self) -&gt; Type[UnitConverter]:\n        \"\"\"\n        Raises `UndefinedConverter` if a converter is not defined.\n        \"\"\"\n        return get_converter(self.unit.to_generic())\n\n    def _validate_comparison_input(self, other) -&gt; None:\n        \"\"\"\n        Raises `PropertyBinaryOperationError` if other is not a Property or if it does\n        not have the same unit type as this Property.\n        \"\"\"\n        if not isinstance(other, Property):\n            raise PropertyBinaryOperationError(\n                f\"cannot compare {other} to ({self}); {other} is not a Property; \"\n                \"only properties can be compared to properties. \"\n            )\n        if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__add__","title":"<code>__add__(other)</code>","text":"<p>Defines addition between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n&gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; x1 + x2\n&lt;Property: 20 m&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __add__(self, other) -&gt; Self:\n    \"\"\"\n    Defines addition between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n        &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; x1 + x2\n        &lt;Property: 20 m&gt;\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        raise PropertyBinaryOperationError(\n            f\"cannot add {other} to ({self}); {other} is not a {self.__class__}; \"\n            \"only same properties can be added to each other. \"\n        )\n    if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n        raise PropertyBinaryOperationError(\n            f\"cannot add ({other}) to ({self}); \"\n            f\"({other}) must have ({self.unit.to_generic()}) units. \"\n        )\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot add ({other}) to ({self}); ({other}) does not have the same \"\n            f\"units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot add ({other}) to ({self});\", exc\n        ) from None\n    return self.__class__(self.value + prop.value, self.unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Defines equality between properties. Prefer Property.eq instead.The equality operator returns False even for very small differences between floating point values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n&gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; L1 == L2\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n&gt;&gt;&gt; L2 == L3\nFalse\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Defines equality between properties.\n    Prefer Property.eq instead.The equality operator returns False even for very\n    small differences between floating point values.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n        &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; L1 == L2\n        True\n\n        &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n        &gt;&gt;&gt; L2 == L3\n        False\n    \"\"\"\n    if not isinstance(other, Property):\n        return False\n    if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n        return False\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUtilsException as exc:\n        raise PropertyBinaryOperationError(\n            f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n            exc,\n        ) from None\n    return self.value == prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(212, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &gt;= T2\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __ge__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(212, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &gt;= T2\n        True\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &gt;= prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &gt; T2\nFalse\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __gt__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &gt; T2\n        False\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &gt; prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__le__","title":"<code>__le__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &lt;= T2\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __le__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &lt;= T2\n        True\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &lt;= prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &lt; T2\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __lt__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &lt; T2\n        True\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &lt; prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Defines multiplication between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; 2*T\n&lt;Property: 600 K&gt;\n&gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n&gt;&gt;&gt; T * A\n&lt;Property: 3000 (m^2) * K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __mul__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines multiplication between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; 2*T\n        &lt;Property: 600 K&gt;\n        &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n        &gt;&gt;&gt; T * A\n        &lt;Property: 3000 (m^2) * K&gt;\n    \"\"\"\n    if isinstance(other, (float, int)):\n        return Property(self.value * other, self.unit)\n    if isinstance(other, Property):\n        return Property(\n            self.value * other.value, (self.unit * other.unit).simplified()\n        )\n    raise PropertyBinaryOperationError(\n        f\"cannot multiply {self} with {other}; \"\n        \"second operand must be numeric or Property. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Defines inequality between properties. Prefer Property.eq instead.The inequality operator returns True even for very small differences between floating point values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n&gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; L1 != L2\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n&gt;&gt;&gt; L2 != L3\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __ne__(self, other) -&gt; bool:\n    \"\"\"\n    Defines inequality between properties.\n    Prefer Property.eq instead.The inequality operator returns True even for very\n    small differences between floating point values.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n        &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; L1 != L2\n        False\n\n        &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n        &gt;&gt;&gt; L2 != L3\n        True\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__neg__","title":"<code>__neg__()</code>","text":"<p>Defines negation of properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T = Property(3, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; -T\n&lt;Property: -3 \u00b0C&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"\n    Defines negation of properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T = Property(3, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; -T\n        &lt;Property: -3 \u00b0C&gt;\n    \"\"\"\n    return self.__class__(-self.value, self.unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; L = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; L**3\n&lt;Property: 125 (m^3)&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __pow__(self, power) -&gt; \"Property\":\n    \"\"\"\n    Defines exponentiation for properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; L = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; L**3\n        &lt;Property: 125 (m^3)&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise PropertyExponentError(\n            f\"invalid exponent: {power}; expected numeric. \"\n        )\n    return Property(self.value**power, self.unit**power)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Defines right addition between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n&gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; x1 + x2\n&lt;Property: 20 m&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __radd__(self, other) -&gt; Self:\n    \"\"\"\n    Defines right addition between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n        &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; x1 + x2\n        &lt;Property: 20 m&gt;\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__rmul__","title":"<code>__rmul__(other)</code>","text":"<p>Defines multiplication between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; 2*T\n&lt;Property: 600 K&gt;\n&gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n&gt;&gt;&gt; T * A\n&lt;Property: 3000 (m^2) * K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __rmul__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines multiplication between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; 2*T\n        &lt;Property: 600 K&gt;\n        &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n        &gt;&gt;&gt; T * A\n        &lt;Property: 3000 (m^2) * K&gt;\n    \"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__rsub__","title":"<code>__rsub__(other)</code>","text":"<p>Defines right subtraction between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import TimeUnit\n&gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n&gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n&gt;&gt;&gt; t1 - t2\n&lt;Property: 1.0 min&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __rsub__(self, other) -&gt; Self:\n    \"\"\"\n    Defines right subtraction between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n        &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n        &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n        &gt;&gt;&gt; t1 - t2\n        &lt;Property: 1.0 min&gt;\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract {self} from ({other}); {other} is not a \"\n            f\"{self.__class__}; only same properties can be subtracted from each \"\n            \"other. \"\n        )\n    if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({self}) from ({other}); \"\n            f\"({other}) must have ({self.unit.to_generic()}) units. \"\n        )\n    return other.__add__(-self)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__rtruediv__","title":"<code>__rtruediv__(other)</code>","text":"<p>Defines right division between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit\n&gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; 100/T\n&lt;Property: 0.2  / K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __rtruediv__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines right division between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit\n        &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; 100/T\n        &lt;Property: 0.2  / K&gt;\n    \"\"\"\n    if isinstance(other, (float, int)):\n        try:\n            value = other / self.value\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator is zero. \"\n            ) from None\n        return Property(value, self.unit.inverse())\n    if isinstance(other, Property):\n        try:\n            value = other.value / self.value\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator's value is zero. \"\n            ) from None\n        return Property(value, (other.unit / self.unit).simplified())\n    raise PropertyBinaryOperationError(\n        f\"cannot divide {self} with {other}; \"\n        \"numerator must be numeric or Property. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Defines subtraction between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import TimeUnit\n&gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n&gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n&gt;&gt;&gt; t1 - t2\n&lt;Property: 1.0 min&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __sub__(self, other) -&gt; Self:\n    \"\"\"\n    Defines subtraction between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n        &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n        &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n        &gt;&gt;&gt; t1 - t2\n        &lt;Property: 1.0 min&gt;\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract {other} from ({self}); {other} is not a \"\n            f\"{self.__class__}; only same properties can be subtracted from each \"\n            \"other. \"\n        )\n    if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({other}) from ({self}); \"\n            f\"({other}) must have ({self.unit.to_generic()}) units. \"\n        )\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({other}) from ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({other}) from ({self});\", exc\n        ) from None\n    return self.__class__(self.value - prop.value, self.unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Defines division between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; T/2\n&lt;Property: 250.0 K&gt;\n&gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n&gt;&gt;&gt; T / A\n&lt;Property: 50.0 K / (m^2)&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __truediv__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines division between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; T/2\n        &lt;Property: 250.0 K&gt;\n        &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n        &gt;&gt;&gt; T / A\n        &lt;Property: 50.0 K / (m^2)&gt;\n    \"\"\"\n    if isinstance(other, (float, int)):\n        try:\n            value = self.value / other\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator is zero. \"\n            ) from None\n        return Property(value, self.unit)\n    if isinstance(other, Property):\n        try:\n            value = self.value / other.value\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator's value is zero. \"\n            ) from None\n        return Property(value, (self.unit / other.unit).simplified())\n    raise PropertyBinaryOperationError(\n        f\"cannot divide {self} with {other}; \"\n        \"denominator must be numeric or Property. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.eq","title":"<code>eq(other, *, rel_tol=1e-09, abs_tol=0)</code>","text":"<p>Perform equality comparison between this and some other Property. This method of testing equality is preferable to the equality operator '==' because float point tolerance is taken into account.</p> <p>rel_tol is the maximum difference for being considered \"close\", relative to the magnitude of the input values. abs_tol is the maximum difference for being considered \"close\", regardless of the magnitude of the input values. For the values to be considered close, the difference between them must be smaller than at least one of the tolerances.</p> <p>Raises <code>PropertyBinaryOperationError</code> if an error occurs during conversion of other's units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T1 = Property(33.333333, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; T2 = Property(100/3, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; T1 == T2\nFalse\n&gt;&gt;&gt; T1.eq(T2)\nFalse\n&gt;&gt;&gt; T1.eq(T2, rel_tol=0.1)\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def eq(self, other: \"Property\", *, rel_tol=1e-9, abs_tol=0) -&gt; bool:\n    \"\"\"\n    Perform equality comparison between this and some other Property. This method\n    of testing equality is preferable to the equality operator '==' because float\n    point tolerance is taken into account.\n\n    rel_tol is the maximum difference for being considered \"close\", relative\n    to the magnitude of the input values.\n    abs_tol is the maximum difference for being considered \"close\", regardless of\n    the magnitude of the input values.\n    For the values to be considered close, the difference between them must be\n    smaller than at least one of the tolerances.\n\n    Raises `PropertyBinaryOperationError` if an error occurs during conversion\n    of other's units.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T1 = Property(33.333333, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; T2 = Property(100/3, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; T1 == T2\n        False\n        &gt;&gt;&gt; T1.eq(T2)\n        False\n        &gt;&gt;&gt; T1.eq(T2, rel_tol=0.1)\n        True\n    \"\"\"\n    if not isinstance(other, Property):\n        return False\n    if not self.unit.isinstance_equivalent(other.unit.to_generic()):\n        return False\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUtilsException as exc:\n        raise PropertyBinaryOperationError(\n            f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n            exc,\n        ) from None\n    return isclose(self.value, prop.value, rel_tol=rel_tol, abs_tol=abs_tol)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.to_si","title":"<code>to_si()</code>","text":"<p>Create a new property with SI units.</p> <p>Raises <code>ImpossiblePropertyUnitConverion</code> if there is no converter registered for the unit.</p> <p>Raises <code>InvalidUnitConversion</code> if any error occurs in the unit conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T.to_si()\n&lt;Property: 373.15 K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def to_si(self) -&gt; Self:\n    \"\"\"\n    Create a new property with SI units.\n\n    Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n    for the unit.\n\n    Raises `InvalidUnitConversion` if any error occurs in the unit conversion.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T.to_si()\n        &lt;Property: 373.15 K&gt;\n    \"\"\"\n    if isinstance(self.unit, MeasurementUnit):\n        return self.to_unit(self.unit.si())\n    if isinstance(self.unit, Dimension):\n        return self.to_unit(self.unit.unit.si() ** self.unit.power)\n    if isinstance(self.unit, CompositeDimension):\n        return self.to_unit(self.unit.to_generic().to_si())\n    raise PropertyValidationError(\n        f\"cannot convert Property to SI; 'unit' is invalid: {self.unit}. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.to_unit","title":"<code>to_unit(unit)</code>","text":"<p>Create a new property with specified unit.</p> <p>Raises <code>PropertyUnitConversionError</code> if the unit is not of the same type.</p> <p>Raises <code>ImpossiblePropertyUnitConverion</code> if there is no converter registered for the unit.</p> <p>Raises <code>UnitConversionError</code> if any error occurs in the unit conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T.to_unit(RelativeTemperatureUnit.FAHRENHEIT)\n&lt;Property: 212.0 \u00b0F&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def to_unit(self, unit: UnitDescriptor) -&gt; Self:\n    \"\"\"\n    Create a new property with specified unit.\n\n    Raises `PropertyUnitConversionError` if the unit is not of the same type.\n\n    Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n    for the unit.\n\n    Raises `UnitConversionError` if any error occurs in the unit conversion.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T.to_unit(RelativeTemperatureUnit.FAHRENHEIT)\n        &lt;Property: 212.0 \u00b0F&gt;\n    \"\"\"\n    if not unit.isinstance_equivalent(self.unit.to_generic()):\n        raise PropertyUnitConversionError(\n            f\"cannot convert {self} to ({unit}) units; 'unit' should be an instance\"\n            f\" of {self.unit.to_generic()}. \"\n        )\n    try:\n        converter = self._converter()\n    except UndefinedConverterError:\n        raise PropertyUnitConversionError(\n            f\"cannot convert property {self} to units: {unit}; no unit converter \"\n            f\" found for {unit.to_generic()}. \"\n            \"Did you forget to @register_converter? \"\n        ) from None\n    try:\n        value = converter.convert(self.value, self.unit, unit)\n    except UnitConversionError as exc:\n        raise exc from None\n    return self.__class__(value=value, unit=unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.p","title":"<code>p(value, unit=NonDimensionalUnit.NON_DIMENSIONAL)</code>","text":"<p>Create a property with a value and a unit. Default unit is non-dimensional, i.e. no unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units import KELVIN\n&gt;&gt;&gt; p(350, KELVIN)\n&lt;Property: 350 K&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; p(20.23)\n&lt;Property: 20.23 &gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def p(\n    value: float, unit: UnitDescriptor = NonDimensionalUnit.NON_DIMENSIONAL\n) -&gt; \"Property\":\n    \"\"\"\n    Create a property with a value and a unit.\n    Default unit is non-dimensional, i.e. no unit.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units import KELVIN\n        &gt;&gt;&gt; p(350, KELVIN)\n        &lt;Property: 350 K&gt;\n\n        &gt;&gt;&gt; p(20.23)\n        &lt;Property: 20.23 &gt;\n    \"\"\"\n    return Property(value, unit)\n</code></pre>"},{"location":"terminology/","title":"Terminology","text":""},{"location":"terminology/#unit-descriptors-or-just-units","title":"Unit descriptors (or just units)","text":"<p>Throughout <code>property-utils</code> the term unit descriptor is used to denote a specific measurement unit of a physical property; it can, for example, refer to Celcius (\u00b0C) but not to temperature units in general.</p>"},{"location":"terminology/#generic-unit-descriptors-or-just-generics","title":"Generic unit descriptors (or just generics)","text":"<p>Throughout <code>property-utils</code> the term generic descriptor is used to denote a type of measurement units; it can, for example, refer to length units but not to meters, inches, etc.</p>"},{"location":"usage/","title":"Usage","text":"<p>This sections assumes the reader is acquainted with the terms in Terminology.</p>"},{"location":"usage/#unit-arithmetics","title":"Unit arithmetics","text":""},{"location":"usage/#create-composite-units","title":"Create composite units","text":"<p>Units can be created by multiplying and dividing base units:</p> <pre><code>from property_utils.units import JOULE, MOL, KELVIN, METER\n\nthermal_capacity_units = JOULE / MOL / KELVIN\nmolar_volume_units = MOL / METER**3\nprint(\"thermal_capacity_units =\", thermal_capacity_units)\nprint(\"molar_volume_units =\", molar_volume_units)\n</code></pre> <p>Result:</p> <pre><code>thermal_capacity_units = J / K / mol\nmolar_volume_units = mol / (m^3)\n</code></pre>"},{"location":"usage/#compare-units","title":"Compare units","text":"<p>Units can be compared with other units. The <code>isinstance</code> method checks if a unit belongs to some specific unit type.</p> <pre><code>from property_utils.units import WATT, PowerUnit, EnergyUnit\n\nprint(WATT.isinstance(PowerUnit))\nprint(WATT.isinstance(EnergyUnit))\n</code></pre> <p>Result:</p> <pre><code>True\nFalse\n</code></pre> <p>The <code>isinstance_equivalent</code> method checks if a unit is equivalent to some other generic unit.</p> <pre><code>from property_utils.units import (\n    WATT,\n    PowerUnit,\n    EnergyUnit,\n    TimeUnit,\n    ForceUnit,\n    LengthUnit,\n    MassUnit,\n)\n\nprint(WATT.isinstance_equivalent(PowerUnit))\nprint(WATT.isinstance_equivalent(EnergyUnit / TimeUnit))\nprint(WATT.isinstance_equivalent(ForceUnit * LengthUnit / TimeUnit))\nprint(WATT.isinstance_equivalent(MassUnit * LengthUnit**2 / TimeUnit**3))\n</code></pre> <p>Result:</p> <pre><code>True\nTrue\nTrue\nTrue\n</code></pre>"},{"location":"usage/#si-units","title":"SI units","text":"<p>Any unit can be converted to si units with the <code>si</code> method.</p> <pre><code>from property_utils.units import BTU, RANKINE, FOOT, CENTI_METER, KILO_CALORIE\n\nprint((BTU / FOOT**2 / RANKINE).si())\nprint((CENTI_METER**3).si())\nprint(KILO_CALORIE.si())\n</code></pre> <p>Result:</p> <pre><code>J / (m^2) / K\n(m^3)\nJ\n</code></pre>"},{"location":"usage/#simplify-composite-units","title":"Simplify composite units","text":"<p>Composite units may contain same units in the numerator and denominator. The <code>simplified</code> method removes common units from the numerator and denominator.</p> <pre><code>from property_utils.units import METER, SECOND\n\nvelocity_units = METER / SECOND\nacceleration_units = velocity_units / SECOND\n\nprint(\"acceleration_units =\", acceleration_units)\nprint(\"acceleration_units simplified =\", acceleration_units.simplified())\n</code></pre> <p>Result:</p> <pre><code>acceleration_units = m / s / s\nacceleration_units simplified = m / (s^2)\n</code></pre> <p>The <code>simplified</code> method also merges common units.</p> <pre><code>from property_utils.units import METER\n\nlength_units = METER\narea_units = length_units * length_units\n\nprint(\"area_units =\", area_units)\nprint(\"area_units simplified =\", area_units.simplified())\n</code></pre> <p>Result:</p> <pre><code>area_units = m * m\narea_units simplified = (m^2)\n</code></pre>"},{"location":"usage/#unit-conversions","title":"Unit conversions","text":"<p>Any property can be converted to chosen units with <code>to_unit</code>:</p> <pre><code>from property_utils.properties import p\nfrom property_utils.units import WATT, METER, KELVIN, BTU, FOOT, RANKINE, HOUR\n\nheat_transfer_coeff = p(50, WATT / METER**2 / KELVIN)\nprint(\n    \"heat_transfer_coeff =\",\n    heat_transfer_coeff.to_unit(BTU / HOUR / FOOT**2 / RANKINE),\n)\n</code></pre> <p>Result:</p> <pre><code>heat_transfer_coeff = 8.805115955164156 Btu / (ft^2) / hr / \u00b0R\n</code></pre> <p>Converting to SI units is easier with <code>to_si</code>:</p> <pre><code>from property_utils.properties import p\nfrom property_utils.units import GRAM, CENTI_METER\n\narea_density = p(12, GRAM / CENTI_METER**2)\n\nprint(\"area_density =\", area_density)\nprint(\"area_density (SI) =\", area_density.to_si())\n</code></pre> <p>Result:</p> <pre><code>area_density = 12 g / (cm^2)\narea_density (SI) = 120.0 kg / (m^2)\n</code></pre>"},{"location":"usage/#property-arithmetics","title":"Property arithmetics","text":""},{"location":"usage/#addition-subtraction","title":"Addition - Subtraction","text":"<p>Properties can be added and subtracted to and from each other:</p> <pre><code>from property_utils.properties import p\nfrom property_utils.units import BAR\n\npressure_1 = p(15, BAR)\npressure_2 = p(2, BAR)\nprint(\"pressure_1 + pressure_2 =\", pressure_1 + pressure_2)\nprint(\"pressure_1 - pressure_2 =\", pressure_1 - pressure_2)\n</code></pre> <p>Result:</p> <pre><code>pressure_1 + pressure_2 = 17 bar\npressure_1 - pressure_2 = 13 bar\n</code></pre> <p>Properties with different units can be added to each other. The result is always calculated in the units  of the left operand.</p> <pre><code>from property_utils.properties import p\nfrom property_utils.units import BAR, PSI\n\npressure_1 = p(5, BAR)\npressure_2 = p(30, PSI)\nprint(\"pressure_1 + pressure_2 =\", pressure_1 + pressure_2)\nprint(\"pressure_2 + pressure_1 =\", pressure_2 + pressure_1)\n</code></pre> <p>Result:</p> <pre><code>pressure_1 + pressure_2 = 7.068423447648202 bar\npressure_2 + pressure_1 = 102.519 psi\n</code></pre>"},{"location":"usage/#multiplication-division","title":"Multiplication - Division","text":"<p>Properties can be multiplied and divided by numerics:</p> <pre><code>from property_utils.properties import p\nfrom property_utils.units import KELVIN\n\ntemperature = p(773.15, KELVIN)\nprint(\"2*temperature =\", 2*temperature)\nprint(\"temperature/2 =\", temperature/2)\n</code></pre> <p>Result:</p> <pre><code>2*temperature = 1546.3 K\ntemperature/2 = 386.575 K\n</code></pre> <p>Properties can also be multiplied and divided with each other:</p> <pre><code>from property_utils.properties import p\nfrom property_utils.units import KELVIN, JOULE, KILO_GRAM\n\nthermal_capacity = p(4200, JOULE/KELVIN/KILO_GRAM)\ntemperature_diff = p(57, KELVIN)\nenthalpy = thermal_capacity * temperature_diff\nprint(\"enthalpy =\", thermal_capacity*temperature_diff)\n</code></pre> <p>Result:</p> <pre><code>enthalpy = 239400 J / kg\n</code></pre>"},{"location":"validated_property/","title":"validated property","text":""},{"location":"validated_property/#property_utils.properties.validated_property.ValidatedProperty","title":"<code>ValidatedProperty</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Property</code></p> <p>A ValidatedProperty applies custom validations on its' value.</p> <p>Inherit from this class and implement the <code>validate_value</code> method to apply a validation to the property's value.</p> <p>You should also define the <code>generic_unit_descriptor</code> class variable. A validation is applied upon initialization for the type of the unit; if its' generic type does not match the <code>generic_unit_descriptor</code> a PropertyValidationError` is raised.</p> <p><code>default_units</code> class variable is the default units with which properties will be created; if it is not defined the default it to use SI units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit, AbsoluteTemperatureUnit\n&gt;&gt;&gt; class Distance(ValidatedProperty):\n...     generic_unit_descriptor = LengthUnit\n</code></pre> <pre><code>&gt;&gt;&gt; class NauticalDistance(Distance):\n...     default_units = LengthUnit.NAUTICAL_MILE\n</code></pre> <pre><code>&gt;&gt;&gt; Distance(5) # defaults to SI units\n&lt;Distance: 5 m&gt;\n&gt;&gt;&gt; NauticalDistance(45.2)\n&lt;NauticalDistance: 45.2 NM&gt;\n</code></pre> Source code in <code>src/property_utils/properties/validated_property.py</code> <pre><code>@dataclass\nclass ValidatedProperty(Property):\n    \"\"\"\n    A ValidatedProperty applies custom validations on its' value.\n\n    Inherit from this class and implement the `validate_value` method to apply a\n    validation to the property's value.\n\n    You should also define the `generic_unit_descriptor` class variable. A validation\n    is applied upon initialization for the type of the unit; if its' generic type\n    does not match the `generic_unit_descriptor` a PropertyValidationError` is raised.\n\n    `default_units` class variable is the default units with which properties will be\n    created; if it is not defined the default it to use SI units.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit, AbsoluteTemperatureUnit\n        &gt;&gt;&gt; class Distance(ValidatedProperty):\n        ...     generic_unit_descriptor = LengthUnit\n\n        &gt;&gt;&gt; class NauticalDistance(Distance):\n        ...     default_units = LengthUnit.NAUTICAL_MILE\n\n        &gt;&gt;&gt; Distance(5) # defaults to SI units\n        &lt;Distance: 5 m&gt;\n        &gt;&gt;&gt; NauticalDistance(45.2)\n        &lt;NauticalDistance: 45.2 NM&gt;\n    \"\"\"\n\n    generic_unit_descriptor: ClassVar[GenericUnitDescriptor]\n    default_units: ClassVar[Optional[UnitDescriptor]] = None\n\n    def __init__(self, value: float, unit: Optional[UnitDescriptor] = None) -&gt; None:\n        if unit is None:\n            unit = self.default_units if self.default_units is not None else unit\n            unit = self.generic_unit_descriptor.to_si() if unit is None else unit\n\n        super().__init__(value, unit)\n        if not unit.isinstance(self.generic_unit_descriptor):\n            raise PropertyValidationError(\n                f\"cannot create {self.__class__.__name__} with {unit} units; \"\n                f\"expected {self.generic_unit_descriptor} units. \"\n            )\n        self.validate_value(value)\n\n    @abstractmethod\n    def validate_value(self, value: float) -&gt; None:\n        \"\"\"\n        Validate the `value` for this property. This validation takes place after\n        initialization; hence all initialized attributes are available.\n\n        The only exception this method should raise is `PropertyValidationError`.\n        \"\"\"\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}: {self.value} {self.unit}&gt;\"\n\n    def __setattr__(self, __name: str, __value: Any) -&gt; None:\n        if __name == \"value\":\n            self.validate_value(__value)\n        super().__setattr__(__name, __value)\n</code></pre>"},{"location":"validated_property/#property_utils.properties.validated_property.ValidatedProperty.validate_value","title":"<code>validate_value(value)</code>  <code>abstractmethod</code>","text":"<p>Validate the <code>value</code> for this property. This validation takes place after initialization; hence all initialized attributes are available.</p> <p>The only exception this method should raise is <code>PropertyValidationError</code>.</p> Source code in <code>src/property_utils/properties/validated_property.py</code> <pre><code>@abstractmethod\ndef validate_value(self, value: float) -&gt; None:\n    \"\"\"\n    Validate the `value` for this property. This validation takes place after\n    initialization; hence all initialized attributes are available.\n\n    The only exception this method should raise is `PropertyValidationError`.\n    \"\"\"\n</code></pre>"}]}