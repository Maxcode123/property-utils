{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is property-utils?","text":"<p><code>property-utils</code> is a python library that aims at making programming with physical properties easier.  It was created to be used by scientists and engineers with little programming experience.</p>"},{"location":"converter_types/","title":"converter types","text":"<p>This module defines: * Functions to fetch and register unit converters * Unit converter protocol * Base abstract classes for different types of unit converters</p> <p>Converters implement a 2-step process to convert 'from_unit' to 'to_unit'. 1. Convert the 'from_unit' to a reference unit. 2. Convert the reference unit to the 'to_unit'.</p>"},{"location":"converter_types/#property_utils.units.converter_types.AbsoluteUnitConverter","title":"<code>AbsoluteUnitConverter</code>","text":"<p>Base converter class for measurement units that are absolute, i.e. not relative.</p> <p>e.g. Pressure units are absolute because the following applies: unit_i = unit_j * constant, where unit_i and unit_j can be any pressure units.</p> <p>Temperature units are not absolute because the above equation does not apply when converting from a relative temperature to an absolute temperature (e.g. from Celcius to Kelvin, or Fahrenheit to Rankine).</p> <p>Use the 'register_converter' decorator when subclassing and define the 'reference_unit' and 'conversion_map' attributes. It does not matter what unit you shall choose to be the reference; although you have to define the conversion map accordingly. The conversion map is a dictionary that holds the conversion factors from the reference unit to other units. e.g. in the below example: 1 in = 2.54 cm</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class AbsoluteUnitConverter(metaclass=ABCMeta):\n    \"\"\"\n    Base converter class for measurement units that are absolute, i.e. not relative.\n\n    e.g.\n    Pressure units are absolute because the following applies:\n    unit_i = unit_j * constant,\n    where unit_i and unit_j can be any pressure units.\n\n    Temperature units are not absolute because the above equation does not apply when\n    converting from a relative temperature to an absolute temperature (e.g. from Celcius\n    to Kelvin, or Fahrenheit to Rankine).\n\n    Use the 'register_converter' decorator when subclassing and define the\n    'reference_unit' and 'conversion_map' attributes. It does not matter what unit you\n    shall choose to be the reference; although you have to define the conversion map\n    accordingly. The conversion map is a dictionary that holds the conversion factors\n    from the reference unit to other units. e.g. in the below example: 1 in = 2.54 cm\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n    \"\"\"\n\n    generic_unit_descriptor: MeasurementUnitType\n    reference_unit: MeasurementUnit\n    conversion_map: Dict[MeasurementUnit, float]\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from an absolute unit to another absolute unit.\n        Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n        an instance of the generic that is registered with the converter or if 'value'\n        is not a numeric.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; assert LengthUnitConverter.convert(2, LengthUnit.INCH, LengthUnit.CENTI_METER) == 5.08\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n\n    @classmethod\n    def get_factor(\n        cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Get the multiplication factor for the conversion from 'from_descriptor' to\n        'to_descriptor'.\n        Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n        an instance of the generic that is registered with the converter.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; assert LengthUnitConverter.get_factor(LengthUnit.CENTI_METER, LengthUnit.INCH) == 1/2.54\n        \"\"\"\n        if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        from_unit = MeasurementUnit.from_descriptor(from_descriptor)\n        to_unit = MeasurementUnit.from_descriptor(to_descriptor)\n        try:\n            return cls._to_reference(from_unit) * cls.conversion_map[to_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert to {to_unit}; unit is not registered in {cls.__name__}'s conversion map. \",\n            ) from None\n\n    @classmethod\n    def _to_reference(cls, from_unit: MeasurementUnit) -&gt; float:\n        try:\n            return 1 / cls.conversion_map[from_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert from {from_unit}; unit is not registered in {cls.__name__}'s conversion map. \",\n            ) from None\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.AbsoluteUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from an absolute unit to another absolute unit. Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not an instance of the generic that is registered with the converter or if 'value' is not a numeric.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>assert LengthUnitConverter.convert(2, LengthUnit.INCH, LengthUnit.CENTI_METER) == 5.08</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from an absolute unit to another absolute unit.\n    Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n    an instance of the generic that is registered with the converter or if 'value'\n    is not a numeric.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; assert LengthUnitConverter.convert(2, LengthUnit.INCH, LengthUnit.CENTI_METER) == 5.08\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.AbsoluteUnitConverter.get_factor","title":"<code>get_factor(from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Get the multiplication factor for the conversion from 'from_descriptor' to 'to_descriptor'. Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not an instance of the generic that is registered with the converter.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>assert LengthUnitConverter.get_factor(LengthUnit.CENTI_METER, LengthUnit.INCH) == 1/2.54</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef get_factor(\n    cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n) -&gt; float:\n    \"\"\"\n    Get the multiplication factor for the conversion from 'from_descriptor' to\n    'to_descriptor'.\n    Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n    an instance of the generic that is registered with the converter.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; assert LengthUnitConverter.get_factor(LengthUnit.CENTI_METER, LengthUnit.INCH) == 1/2.54\n    \"\"\"\n    if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n        )\n    if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n        )\n    from_unit = MeasurementUnit.from_descriptor(from_descriptor)\n    to_unit = MeasurementUnit.from_descriptor(to_descriptor)\n    try:\n        return cls._to_reference(from_unit) * cls.conversion_map[to_unit]\n    except KeyError:\n        raise UnitConversionError(\n            f\"cannot convert to {to_unit}; unit is not registered in {cls.__name__}'s conversion map. \",\n        ) from None\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.CompositeUnitConverter","title":"<code>CompositeUnitConverter</code>","text":"<p>Base converter for composite units.</p> <p>Use the 'register_converter' decorator when subclassing. This converter requires the converters for the individul measurement units to be defined.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>class TimeUnit(MeasurementUnit): ...     SECOND = \"s\" ...     MINUTE = \"min\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>@register_converter(TimeUnit) ... class TimeUnitConverter(AbsoluteUnitConverter): ...     reference_unit = TimeUnit.MINUTE ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}</p> <p>@register_converter(LengthUnit / TimeUnit) ... class VelocityUnitConverter(CompositeUnitConverter): ...</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class CompositeUnitConverter(metaclass=ABCMeta):\n    \"\"\"\n    Base converter for composite units.\n\n    Use the 'register_converter' decorator when subclassing. This converter requires\n    the converters for the individul measurement units to be defined.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n    ...     MINUTE = \"min\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; @register_converter(TimeUnit)\n    ... class TimeUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = TimeUnit.MINUTE\n    ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n    &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n    ... class VelocityUnitConverter(CompositeUnitConverter): ...\n    \"\"\"\n\n    generic_unit_descriptor: GenericUnitDescriptor\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from a composite unit to another composite unit.\n\n        Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n        an instance of the generic that is registered with the converter or if 'value'\n        is not a numeric.\n\n        Raises 'ConverterDependenciesError' if a converter for an invdividual unit has\n        not been defined/registered.\n\n        Raises 'UnsupportedConverterError' if an individual unit is a relative unit.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        ...     MINUTE = \"min\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(TimeUnit)\n        ... class TimeUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = TimeUnit.MINUTE\n        ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n        ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n        &gt;&gt;&gt; assert VelocityUnitConverter.convert(100, LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.CENTI_METER/TimeUnit.SECOND) == 254\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n\n    @classmethod\n    def get_factor(\n        cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Get the multiplication factor for the conversion from 'from_descriptor' to\n        'to_descriptor'.\n\n        Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n        an instance of the generic that is registered with the converter.\n\n        Raises 'ConverterDependenciesError' if a converter for an invdividual unit has\n        not been defined/registered.\n\n        Raises 'UnsupportedConverterError' if an individual unit is a relative unit.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        ...     MINUTE = \"min\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(TimeUnit)\n        ... class TimeUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = TimeUnit.MINUTE\n        ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n        ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n        &gt;&gt;&gt; assert VelocityUnitConverter.get_factor(LengthUnit.INCH/TimeUnit.MINUTE, LengthUnit.CENTI_METER/TimeUnit.SECOND) == 2.54/60\n        \"\"\"\n        if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        from_dimension = CompositeDimension.from_descriptor(from_descriptor)\n        to_dimension = CompositeDimension.from_descriptor(to_descriptor)\n        return cls._get_numerator_factor(\n            from_dimension, to_dimension\n        ) / cls._get_denominator_factor(from_dimension, to_dimension)\n\n    @classmethod\n    def _get_numerator_factor(\n        cls, from_dimension: CompositeDimension, to_dimension: CompositeDimension\n    ) -&gt; float:\n        numerator_factor = 1.0\n        for from_d in from_dimension.numerator:\n            to_d = to_dimension.get_numerator(from_d.to_generic())\n            if to_d is None:\n                raise UnitConversionError(\n                    f\"cannot convert from {from_dimension} to {to_dimension}\"\n                )\n            try:\n                converter = get_converter(type(from_d.unit))\n            except UndefinedConverterError:\n                raise ConverterDependenciesError(\n                    f\"converter {cls.__name__} depends on a converter for \"\n                    f\"{type(from_d.unit)}. Did you forget to register \"\n                    f\" a converter for {type(from_d.unit)}? \"\n                ) from None\n            if not issubclass(converter, AbsoluteUnitConverter):\n                # NOTE: provide a link to documentation for the error.\n                raise UnsupportedConverterError(\n                    f\"converter {cls.__name__} is not supported since \"\n                    f\"{type(from_d.unit)} is not an absolute unit;\"\n                    \" conversion between composite relative units is invalid. \"\n                )\n            factor = (converter.get_factor(from_d.unit, to_d.unit)) ** from_d.power\n            numerator_factor *= factor\n        return numerator_factor\n\n    @classmethod\n    def _get_denominator_factor(\n        cls, from_dimension: CompositeDimension, to_dimension: CompositeDimension\n    ) -&gt; float:\n        denominator_factor = 1.0\n\n        for from_d in from_dimension.denominator:\n            to_d = to_dimension.get_denominator(from_d.to_generic())\n            if to_d is None:\n                raise UnitConversionError(\n                    f\"cannot convert from {from_dimension} to {to_dimension}\"\n                )\n            try:\n                converter = get_converter(type(from_d.unit))\n            except UndefinedConverterError:\n                raise ConverterDependenciesError(\n                    f\"converter {cls.__name__} depends on a converter for \"\n                    f\"{type(from_d.unit)}. Did you forget to register \"\n                    f\" a converter for {type(from_d.unit)}? \"\n                ) from None\n            if not issubclass(converter, AbsoluteUnitConverter):\n                # NOTE: provide a link to documentation for the error.\n                raise UnsupportedConverterError(\n                    f\"converter {cls.__name__} is not supported since \"\n                    f\"{type(from_d.unit)} is not an absolute unit;\"\n                    \" conversion between composite relative units is invalid. \"\n                )\n            factor = (converter.get_factor(from_d.unit, to_d.unit)) ** from_d.power\n            denominator_factor *= factor\n        return denominator_factor\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.CompositeUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from a composite unit to another composite unit.</p> <p>Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not an instance of the generic that is registered with the converter or if 'value' is not a numeric.</p> <p>Raises 'ConverterDependenciesError' if a converter for an invdividual unit has not been defined/registered.</p> <p>Raises 'UnsupportedConverterError' if an individual unit is a relative unit.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>class TimeUnit(MeasurementUnit): ...     SECOND = \"s\" ...     MINUTE = \"min\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>@register_converter(TimeUnit) ... class TimeUnitConverter(AbsoluteUnitConverter): ...     reference_unit = TimeUnit.MINUTE ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}</p> <p>@register_converter(LengthUnit / TimeUnit) ... class VelocityUnitConverter(CompositeUnitConverter): ...</p> <p>assert VelocityUnitConverter.convert(100, LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.CENTI_METER/TimeUnit.SECOND) == 254</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from a composite unit to another composite unit.\n\n    Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n    an instance of the generic that is registered with the converter or if 'value'\n    is not a numeric.\n\n    Raises 'ConverterDependenciesError' if a converter for an invdividual unit has\n    not been defined/registered.\n\n    Raises 'UnsupportedConverterError' if an individual unit is a relative unit.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n    ...     MINUTE = \"min\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; @register_converter(TimeUnit)\n    ... class TimeUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = TimeUnit.MINUTE\n    ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n    &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n    ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n    &gt;&gt;&gt; assert VelocityUnitConverter.convert(100, LengthUnit.INCH/TimeUnit.SECOND, LengthUnit.CENTI_METER/TimeUnit.SECOND) == 254\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.CompositeUnitConverter.get_factor","title":"<code>get_factor(from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Get the multiplication factor for the conversion from 'from_descriptor' to 'to_descriptor'.</p> <p>Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not an instance of the generic that is registered with the converter.</p> <p>Raises 'ConverterDependenciesError' if a converter for an invdividual unit has not been defined/registered.</p> <p>Raises 'UnsupportedConverterError' if an individual unit is a relative unit.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>class TimeUnit(MeasurementUnit): ...     SECOND = \"s\" ...     MINUTE = \"min\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>@register_converter(TimeUnit) ... class TimeUnitConverter(AbsoluteUnitConverter): ...     reference_unit = TimeUnit.MINUTE ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}</p> <p>@register_converter(LengthUnit / TimeUnit) ... class VelocityUnitConverter(CompositeUnitConverter): ...</p> <p>assert VelocityUnitConverter.get_factor(LengthUnit.INCH/TimeUnit.MINUTE, LengthUnit.CENTI_METER/TimeUnit.SECOND) == 2.54/60</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef get_factor(\n    cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n) -&gt; float:\n    \"\"\"\n    Get the multiplication factor for the conversion from 'from_descriptor' to\n    'to_descriptor'.\n\n    Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n    an instance of the generic that is registered with the converter.\n\n    Raises 'ConverterDependenciesError' if a converter for an invdividual unit has\n    not been defined/registered.\n\n    Raises 'UnsupportedConverterError' if an individual unit is a relative unit.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n    ...     MINUTE = \"min\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; @register_converter(TimeUnit)\n    ... class TimeUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = TimeUnit.MINUTE\n    ...     conversion_map = {TimeUnit.MINUTE: 1, TimeUnit.SECOND: 60}\n\n    &gt;&gt;&gt; @register_converter(LengthUnit / TimeUnit)\n    ... class VelocityUnitConverter(CompositeUnitConverter): ...\n\n    &gt;&gt;&gt; assert VelocityUnitConverter.get_factor(LengthUnit.INCH/TimeUnit.MINUTE, LengthUnit.CENTI_METER/TimeUnit.SECOND) == 2.54/60\n    \"\"\"\n    if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n        )\n    if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n        )\n    from_dimension = CompositeDimension.from_descriptor(from_descriptor)\n    to_dimension = CompositeDimension.from_descriptor(to_descriptor)\n    return cls._get_numerator_factor(\n        from_dimension, to_dimension\n    ) / cls._get_denominator_factor(from_dimension, to_dimension)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.ExponentiatedUnitConverter","title":"<code>ExponentiatedUnitConverter</code>","text":"<p>Base converter for exponentiated absolute measurement units.</p> <p>Use the 'register_converter' decorator when subclassing. This converter requires the converter for the measurement unit that is exponentiated to be defined.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>@register_converter(LengthUnit**2) ... class AreaUnitConverter(ExponentiatedUnitConverter): ...</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class ExponentiatedUnitConverter(metaclass=ABCMeta):\n    \"\"\"\n    Base converter for exponentiated absolute measurement units.\n\n    Use the 'register_converter' decorator when subclassing. This converter requires\n    the converter for the measurement unit that is exponentiated to be defined.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; @register_converter(LengthUnit**2)\n    ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n    \"\"\"\n\n    generic_unit_descriptor: GenericDimension\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from an absolute exponentiated unit to another absolute\n        exponentiated unit. In order to use this converter a converter must exist for\n        the base unit.\n\n        Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n        an instance of the generic that is registered with the converter or if 'value'\n        is not a numeric.\n\n        Raises 'ConverterDependenciesError' if a converter for the base unit has not\n        been defined/registered.\n\n        Raises 'UnsupportedConverterError' if the base unit is a relative unit.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit**2)\n        ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n        &gt;&gt;&gt; assert AreaUnitConverter.convert(10, LengthUnit.INCH**2, LengthUnit.CENTI_METER**2) == 64.516\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n\n    @classmethod\n    def get_factor(\n        cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n    ) -&gt; float:\n        \"\"\"\n        Get the multiplication factor for the conversion from 'from_descriptor' to\n        'to_descriptor'.\n\n        Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n        an instance of the generic that is registered with the converter.\n\n        Raises 'ConverterDependenciesError' if a converter for the base unit has not\n        been defined/registered.\n\n        Raises 'UnsupportedConverterError' if the base unit is a relative unit.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        ...     INCH = \"in\"\n\n        &gt;&gt;&gt; @register_converter(LengthUnit)\n        ... class LengthUnitConverter(AbsoluteUnitConverter):\n        ...     reference_unit = LengthUnit.INCH\n        ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n        &gt;&gt;&gt; @register_converter(LengthUnit**2)\n        ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n        &gt;&gt;&gt; assert AreaUnitConverter.get_factor(LengthUnit.INCH**2, LengthUnit.CENTI_METER**2) == 6.4516\n        \"\"\"\n        if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        from_dimension = Dimension.from_descriptor(from_descriptor)\n        to_dimension = Dimension.from_descriptor(to_descriptor)\n        try:\n            converter = get_converter(cls.generic_unit_descriptor.unit_type)\n        except UndefinedConverterError:\n            raise ConverterDependenciesError(\n                f\"converter {cls.__name__} depends on a converter for \"\n                f\"{cls.generic_unit_descriptor.unit_type}. Did you forget to register \"\n                f\" a converter for {cls.generic_unit_descriptor.unit_type}? \"\n            ) from None\n        if not issubclass(converter, AbsoluteUnitConverter):\n            # NOTE: provide a link to documentation for the error.\n            raise UnsupportedConverterError(\n                f\"converter {cls.__name__} is not supported since \"\n                f\"{cls.generic_unit_descriptor.unit_type} is not an absolute unit;\"\n                \" conversion between exponentiated relative units is invalid. \"\n            )\n        factor = converter.get_factor(from_dimension.unit, to_dimension.unit)\n        return factor**to_dimension.power\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.ExponentiatedUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from an absolute exponentiated unit to another absolute exponentiated unit. In order to use this converter a converter must exist for the base unit.</p> <p>Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not an instance of the generic that is registered with the converter or if 'value' is not a numeric.</p> <p>Raises 'ConverterDependenciesError' if a converter for the base unit has not been defined/registered.</p> <p>Raises 'UnsupportedConverterError' if the base unit is a relative unit.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>@register_converter(LengthUnit**2) ... class AreaUnitConverter(ExponentiatedUnitConverter): ...</p> <p>assert AreaUnitConverter.convert(10, LengthUnit.INCH2, LengthUnit.CENTI_METER2) == 64.516</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from an absolute exponentiated unit to another absolute\n    exponentiated unit. In order to use this converter a converter must exist for\n    the base unit.\n\n    Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n    an instance of the generic that is registered with the converter or if 'value'\n    is not a numeric.\n\n    Raises 'ConverterDependenciesError' if a converter for the base unit has not\n    been defined/registered.\n\n    Raises 'UnsupportedConverterError' if the base unit is a relative unit.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; @register_converter(LengthUnit**2)\n    ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n    &gt;&gt;&gt; assert AreaUnitConverter.convert(10, LengthUnit.INCH**2, LengthUnit.CENTI_METER**2) == 64.516\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.ExponentiatedUnitConverter.get_factor","title":"<code>get_factor(from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Get the multiplication factor for the conversion from 'from_descriptor' to 'to_descriptor'.</p> <p>Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not an instance of the generic that is registered with the converter.</p> <p>Raises 'ConverterDependenciesError' if a converter for the base unit has not been defined/registered.</p> <p>Raises 'UnsupportedConverterError' if the base unit is a relative unit.</p> <p>class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" ...     INCH = \"in\"</p> <p>@register_converter(LengthUnit) ... class LengthUnitConverter(AbsoluteUnitConverter): ...     reference_unit = LengthUnit.INCH ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}</p> <p>@register_converter(LengthUnit**2) ... class AreaUnitConverter(ExponentiatedUnitConverter): ...</p> <p>assert AreaUnitConverter.get_factor(LengthUnit.INCH2, LengthUnit.CENTI_METER2) == 6.4516</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef get_factor(\n    cls, from_descriptor: UnitDescriptor, to_descriptor: UnitDescriptor\n) -&gt; float:\n    \"\"\"\n    Get the multiplication factor for the conversion from 'from_descriptor' to\n    'to_descriptor'.\n\n    Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n    an instance of the generic that is registered with the converter.\n\n    Raises 'ConverterDependenciesError' if a converter for the base unit has not\n    been defined/registered.\n\n    Raises 'UnsupportedConverterError' if the base unit is a relative unit.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    ...     INCH = \"in\"\n\n    &gt;&gt;&gt; @register_converter(LengthUnit)\n    ... class LengthUnitConverter(AbsoluteUnitConverter):\n    ...     reference_unit = LengthUnit.INCH\n    ...     conversion_map = {LengthUnit.INCH: 1, LengthUnit.CENTI_METER: 2.54}\n\n    &gt;&gt;&gt; @register_converter(LengthUnit**2)\n    ... class AreaUnitConverter(ExponentiatedUnitConverter): ...\n\n    &gt;&gt;&gt; assert AreaUnitConverter.get_factor(LengthUnit.INCH**2, LengthUnit.CENTI_METER**2) == 6.4516\n    \"\"\"\n    if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n        )\n    if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n        raise UnitConversionError(\n            f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n        )\n    from_dimension = Dimension.from_descriptor(from_descriptor)\n    to_dimension = Dimension.from_descriptor(to_descriptor)\n    try:\n        converter = get_converter(cls.generic_unit_descriptor.unit_type)\n    except UndefinedConverterError:\n        raise ConverterDependenciesError(\n            f\"converter {cls.__name__} depends on a converter for \"\n            f\"{cls.generic_unit_descriptor.unit_type}. Did you forget to register \"\n            f\" a converter for {cls.generic_unit_descriptor.unit_type}? \"\n        ) from None\n    if not issubclass(converter, AbsoluteUnitConverter):\n        # NOTE: provide a link to documentation for the error.\n        raise UnsupportedConverterError(\n            f\"converter {cls.__name__} is not supported since \"\n            f\"{cls.generic_unit_descriptor.unit_type} is not an absolute unit;\"\n            \" conversion between exponentiated relative units is invalid. \"\n        )\n    factor = converter.get_factor(from_dimension.unit, to_dimension.unit)\n    return factor**to_dimension.power\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.RelativeUnitConverter","title":"<code>RelativeUnitConverter</code>","text":"<p>Base converter class for measurement units that are relative.</p> <p>e.g. Temperature units are relative because conversion from one unit to another is not necessarily performed with multiplication with a single factor.</p> <p>Use the 'register_converter' decorator when subclassing and define the 'reference_unit', 'conversion_map' and 'reference_conversion_map' attributes. It does not matter what unit you shall choose to be the reference; although you have to define the conversion map and reference conversion map accordingly. The conversion map is a dictionary that holds the conversion functions that convert other units to the reference unit. The reference conversion map is a dictionary that holds the conversion functions that convert the reference unit to other units.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"\u00b0C\" ...     FAHRENHEIT = \"\u00b0F\"</p> <p>@register_converter(TemperatureUnit) ... class TemperatureUnitConverter(RelativeUnitConverter): ...     reference_unit = TemperatureUnit.CELCIUS ...     conversion_map = { ...             TemperatureUnit.CELCIUS: lambda t: t, ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8, ...                 } ...     reference_conversion_map = { ...             TemperatureUnit.CELCIUS: lambda t: t, ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32, ...                 }</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class RelativeUnitConverter(\n    metaclass=ABCMeta\n):  # pylint: disable=too-few-public-methods\n    \"\"\"\n    Base converter class for measurement units that are relative.\n\n    e.g. Temperature units are relative because conversion from one unit to another\n    is not necessarily performed with multiplication with a single factor.\n\n    Use the 'register_converter' decorator when subclassing and define the\n    'reference_unit', 'conversion_map' and 'reference_conversion_map' attributes. It\n    does not matter what unit you shall choose to be the reference; although you have to\n    define the conversion map and reference conversion map accordingly. The conversion\n    map is a dictionary that holds the conversion functions that convert other units to\n    the reference unit. The reference conversion map is a dictionary that holds the\n    conversion functions that convert the reference unit to other units.\n\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"\u00b0C\"\n    ...     FAHRENHEIT = \"\u00b0F\"\n\n    &gt;&gt;&gt; @register_converter(TemperatureUnit)\n    ... class TemperatureUnitConverter(RelativeUnitConverter):\n    ...     reference_unit = TemperatureUnit.CELCIUS\n    ...     conversion_map = {\n    ...             TemperatureUnit.CELCIUS: lambda t: t,\n    ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n    ...                 }\n    ...     reference_conversion_map = {\n    ...             TemperatureUnit.CELCIUS: lambda t: t,\n    ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n    ...                 }\n    \"\"\"\n\n    generic_unit_descriptor: MeasurementUnitType\n    reference_unit: MeasurementUnit\n    reference_conversion_map: Dict[MeasurementUnit, Callable[[float], float]]\n    conversion_map: Dict[MeasurementUnit, Callable[[float], float]]\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from a relative unit to another relative unit.\n\n        Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n        an instance of the generic that is registered with the converter or if 'value'\n        is not a numeric.\n\n        Raises 'ConversionFunctionError' if an error occurs when calling a function\n        provided in the conversion_map or reference_conversion_map.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"\u00b0C\"\n        ...     FAHRENHEIT = \"\u00b0F\"\n\n        &gt;&gt;&gt; @register_converter(TemperatureUnit)\n        ... class TemperatureUnitConverter(RelativeUnitConverter):\n        ...     reference_unit = TemperatureUnit.CELCIUS\n        ...     conversion_map = {\n        ...             TemperatureUnit.CELCIUS: lambda t: t,\n        ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n        ...                 }\n        ...     reference_conversion_map = {\n        ...             TemperatureUnit.CELCIUS: lambda t: t,\n        ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n        ...                 }\n\n        &gt;&gt;&gt; assert TemperatureUnitConverter.convert(100, TemperatureUnit.CELCIUS, TemperatureUnit.FAHRENHEIT) == 212\n        \"\"\"\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        return cls._from_reference(\n            cls._to_reference(value, from_descriptor), to_descriptor\n        )\n\n    @classmethod\n    def _to_reference(cls, value: float, from_descriptor: UnitDescriptor) -&gt; float:\n        if not from_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'from_descriptor; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        from_unit = MeasurementUnit.from_descriptor(from_descriptor)\n        try:\n            conversion_func = cls.conversion_map[from_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert from {from_unit}; unit is not in {cls.__name__}'s conversion map. \",\n            ) from None\n        try:\n            return conversion_func(value)\n        except Exception as exc:\n            raise ConversionFunctionError(\n                f\"an error occured in a conversion function of {cls.__name__}. \", exc\n            ) from exc\n\n    @classmethod\n    def _from_reference(cls, value: float, to_descriptor: UnitDescriptor) -&gt; float:\n        if not to_descriptor.isinstance(cls.generic_unit_descriptor):\n            raise UnitConversionError(\n                f\"invalid 'to_descriptor'; expected an instance of {cls.generic_unit_descriptor}. \"\n            )\n        to_unit = MeasurementUnit.from_descriptor(to_descriptor)\n        try:\n            conversion_func = cls.reference_conversion_map[to_unit]\n        except KeyError:\n            raise UnitConversionError(\n                f\"cannot convert to {to_unit}; unit is not registered in {cls.__name__}'s reference conversion map. \",\n            ) from None\n        try:\n            return conversion_func(value)\n        except Exception as exc:\n            raise ConversionFunctionError(\n                f\"an error occured in a conversion function of {cls.__name__}. \", exc\n            ) from exc\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.RelativeUnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from a relative unit to another relative unit.</p> <p>Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not an instance of the generic that is registered with the converter or if 'value' is not a numeric.</p> <p>Raises 'ConversionFunctionError' if an error occurs when calling a function provided in the conversion_map or reference_conversion_map.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"\u00b0C\" ...     FAHRENHEIT = \"\u00b0F\"</p> <p>@register_converter(TemperatureUnit) ... class TemperatureUnitConverter(RelativeUnitConverter): ...     reference_unit = TemperatureUnit.CELCIUS ...     conversion_map = { ...             TemperatureUnit.CELCIUS: lambda t: t, ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8, ...                 } ...     reference_conversion_map = { ...             TemperatureUnit.CELCIUS: lambda t: t, ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32, ...                 }</p> <p>assert TemperatureUnitConverter.convert(100, TemperatureUnit.CELCIUS, TemperatureUnit.FAHRENHEIT) == 212</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from a relative unit to another relative unit.\n\n    Raises 'UnitConversionError' if 'from_descriptor' or 'to_descriptor' are not\n    an instance of the generic that is registered with the converter or if 'value'\n    is not a numeric.\n\n    Raises 'ConversionFunctionError' if an error occurs when calling a function\n    provided in the conversion_map or reference_conversion_map.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"\u00b0C\"\n    ...     FAHRENHEIT = \"\u00b0F\"\n\n    &gt;&gt;&gt; @register_converter(TemperatureUnit)\n    ... class TemperatureUnitConverter(RelativeUnitConverter):\n    ...     reference_unit = TemperatureUnit.CELCIUS\n    ...     conversion_map = {\n    ...             TemperatureUnit.CELCIUS: lambda t: t,\n    ...             TemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n    ...                 }\n    ...     reference_conversion_map = {\n    ...             TemperatureUnit.CELCIUS: lambda t: t,\n    ...             TemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n    ...                 }\n\n    &gt;&gt;&gt; assert TemperatureUnitConverter.convert(100, TemperatureUnit.CELCIUS, TemperatureUnit.FAHRENHEIT) == 212\n    \"\"\"\n    if not isinstance(value, (float, int)):\n        raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n    return cls._from_reference(\n        cls._to_reference(value, from_descriptor), to_descriptor\n    )\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.UnitConverter","title":"<code>UnitConverter</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Protocol of classes that convert a value from one unit to another.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>class UnitConverter(Protocol):  # pylint: disable=too-few-public-methods\n    \"\"\"Protocol of classes that convert a value from one unit to another.\"\"\"\n\n    generic_unit_descriptor: GenericUnitDescriptor\n\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        \"\"\"\n        Convert a value from a unit descriptor to its' corresponding value in a\n        different unit descriptor.\n        \"\"\"\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.UnitConverter.convert","title":"<code>convert(value, from_descriptor, to_descriptor)</code>  <code>classmethod</code>","text":"<p>Convert a value from a unit descriptor to its' corresponding value in a different unit descriptor.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>@classmethod\ndef convert(\n    cls,\n    value: float,\n    from_descriptor: UnitDescriptor,\n    to_descriptor: UnitDescriptor,\n) -&gt; float:\n    \"\"\"\n    Convert a value from a unit descriptor to its' corresponding value in a\n    different unit descriptor.\n    \"\"\"\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.get_converter","title":"<code>get_converter(generic)</code>","text":"<p>Get converter for given generic descriptor.</p> <p>Raises 'PropertyUtilsTypeError' if argument is not a generic unit descriptor.</p> <p>Raises 'UndefinedConverterError' if a converter has not been defined for the given generic.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>def get_converter(generic: GenericUnitDescriptor) -&gt; ConverterType:\n    \"\"\"\n    Get converter for given generic descriptor.\n\n    Raises 'PropertyUtilsTypeError' if argument is not a generic unit descriptor.\n\n    Raises 'UndefinedConverterError' if a converter has not been defined for the given generic.\n    \"\"\"\n    if not isinstance(\n        generic, (MeasurementUnitType, GenericDimension, GenericCompositeDimension)\n    ):\n        raise PropertyUtilsTypeError(\n            f\"cannot get converter; argument: {generic} is not a generic unit descriptor. \"\n        )\n    if isinstance(generic, GenericDimension) and generic.power == 1:\n        generic = generic.unit_type\n    elif isinstance(generic, GenericDimension) and generic not in _converters:\n        register_converter(generic)(\n            type(f\"{generic}_Converter\", (ExponentiatedUnitConverter,), {})\n        )\n    elif isinstance(generic, GenericCompositeDimension) and generic not in _converters:\n        register_converter(generic)(\n            type(f\"{generic}_Converter\", (CompositeUnitConverter,), {})\n        )\n    try:\n        return _converters[generic]\n    except KeyError:\n        raise UndefinedConverterError(\n            f\"a converter has not been defined for {generic}\"\n        ) from None\n</code></pre>"},{"location":"converter_types/#property_utils.units.converter_types.register_converter","title":"<code>register_converter(generic)</code>","text":"<p>Decorate a converter class to register the generic descriptor of the units it operates on. This decorator also sets the 'generic_unit_descriptor' attribute of the decorated class.</p> <p>Raises 'PropertyUtilsTypeError' if argument is not a generic unit descriptor.</p> <p>Raises 'PropertyUtilsValueError' if generic has already a converter registered.</p> Source code in <code>src/property_utils/units/converter_types.py</code> <pre><code>def register_converter(generic: GenericUnitDescriptor) -&gt; Callable:\n    \"\"\"\n    Decorate a converter class to register the generic descriptor of the units it\n    operates on.\n    This decorator also sets the 'generic_unit_descriptor' attribute of the decorated\n    class.\n\n    Raises 'PropertyUtilsTypeError' if argument is not a generic unit descriptor.\n\n    Raises 'PropertyUtilsValueError' if generic has already a converter registered.\n    \"\"\"\n    if not isinstance(\n        generic, (MeasurementUnitType, GenericDimension, GenericCompositeDimension)\n    ):\n        raise PropertyUtilsTypeError(\n            f\"cannot get converter; argument: {generic} is not a generic unit descriptor. \"\n        )\n\n    if generic in _converters:\n        raise PropertyUtilsValueError(\n            f\"cannot register converter twice; {generic} has already got a converter. \"\n        )\n\n    def wrapper(cls: ConverterType) -&gt; ConverterType:\n        _converters[generic] = cls\n        cls.generic_unit_descriptor = generic\n        return cls\n\n    return wrapper\n</code></pre>"},{"location":"converters/","title":"converters","text":"<p>This module defines unit converters for the units in 'property_utils.units.units' as well as some converters for common exponentiated units (area and volume).</p>"},{"location":"converters/#property_utils.units.converters.AbsoluteTemperatureUnitConverter","title":"<code>AbsoluteTemperatureUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert absolute temperature with this converter.</p> <p>AbsoluteTemperatureUnitConverter.convert(10, AbsoluteTemperatureUnit.KELVIN, AbsoluteTemperatureUnit.RANKINE) 18.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(AbsoluteTemperatureUnit)\nclass AbsoluteTemperatureUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert absolute temperature with this converter.\n\n    &gt;&gt;&gt; AbsoluteTemperatureUnitConverter.convert(10, AbsoluteTemperatureUnit.KELVIN, AbsoluteTemperatureUnit.RANKINE)\n    18.0\n    \"\"\"\n\n    reference_unit = AbsoluteTemperatureUnit.KELVIN\n    conversion_map = {\n        AbsoluteTemperatureUnit.KELVIN: 1,\n        AbsoluteTemperatureUnit.RANKINE: 1.8,\n    }\n\n    @override\n    @classmethod\n    def convert(\n        cls,\n        value: float,\n        from_descriptor: UnitDescriptor,\n        to_descriptor: UnitDescriptor,\n    ) -&gt; float:\n        if not isinstance(value, (float, int)):\n            raise UnitConversionError(f\"invalid 'value': {value}; expected numeric. \")\n        if from_descriptor.isinstance(\n            RelativeTemperatureUnit\n        ) or to_descriptor.isinstance(RelativeTemperatureUnit):\n            return RelativeTemperatureUnitConverter.convert(\n                value, from_descriptor, to_descriptor\n            )\n        return value * cls.get_factor(from_descriptor, to_descriptor)\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasEnergyUnitConverter","title":"<code>AliasEnergyUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert energy units with this converter.</p> <p>AliasEnergyUnitConverter.convert(2500, EnergyUnit.JOULE, EnergyUnit.KILO_JOULE) 2.5</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(EnergyUnit)\nclass AliasEnergyUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert energy units with this converter.\n\n    &gt;&gt;&gt; AliasEnergyUnitConverter.convert(2500, EnergyUnit.JOULE, EnergyUnit.KILO_JOULE)\n    2.5\n    \"\"\"\n\n    reference_unit = EnergyUnit.JOULE\n    conversion_map = {\n        EnergyUnit.JOULE: 1,\n        EnergyUnit.KILO_JOULE: UnitPrefix.KILO.inverse(),\n        EnergyUnit.MEGA_JOULE: UnitPrefix.MEGA.inverse(),\n        EnergyUnit.GIGA_JOULE: UnitPrefix.GIGA.inverse(),\n        EnergyUnit.CALORIE: 1 / 4.184,\n        EnergyUnit.KILO_CALORIE: (1 / 4.184) * UnitPrefix.KILO.inverse(),\n        EnergyUnit.BTU: 1 / 1055.0,\n        EnergyUnit.ELECTRONVOLT: 6.242e18,\n        EnergyUnit.WATTHOUR: 1 / 3600,\n        EnergyUnit.KILO_WATTHOUR: (1 / 3600) * UnitPrefix.KILO.inverse(),\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasForceUnitConverter","title":"<code>AliasForceUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert force units with this converter.</p> <p>AliasForceUnitConverter.convert(2, ForceUnit.NEWTON, ForceUnit.DYNE) 200000.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(ForceUnit)\nclass AliasForceUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert force units with this converter.\n\n    &gt;&gt;&gt; AliasForceUnitConverter.convert(2, ForceUnit.NEWTON, ForceUnit.DYNE)\n    200000.0\n    \"\"\"\n\n    reference_unit = ForceUnit.NEWTON\n    conversion_map = {ForceUnit.NEWTON: 1, ForceUnit.DYNE: 100_000}\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasPowerUnitConverter","title":"<code>AliasPowerUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert power units with this converter.</p> <p>AliasPowerUnitConverter.convert(5, PowerUnit.KILO_WATT, PowerUnit.WATT) 5000.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PowerUnit)\nclass AliasPowerUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert power units with this converter.\n\n    &gt;&gt;&gt; AliasPowerUnitConverter.convert(5, PowerUnit.KILO_WATT, PowerUnit.WATT)\n    5000.0\n    \"\"\"\n\n    reference_unit = PowerUnit.WATT\n    conversion_map = {\n        PowerUnit.WATT: 1,\n        PowerUnit.KILO_WATT: UnitPrefix.KILO.inverse(),\n        PowerUnit.MEGA_WATT: UnitPrefix.MEGA.inverse(),\n        PowerUnit.GIGA_WATT: UnitPrefix.GIGA.inverse(),\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AliasPressureUnitConverter","title":"<code>AliasPressureUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert pressure units with this converter.</p> <p>AliasPressureUnitConverter.convert(2, PressureUnit.BAR, PressureUnit.KILO_PASCAL) 200.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PressureUnit)\nclass AliasPressureUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert pressure units with this converter.\n\n    &gt;&gt;&gt; AliasPressureUnitConverter.convert(2, PressureUnit.BAR, PressureUnit.KILO_PASCAL)\n    200.0\n    \"\"\"\n\n    reference_unit = PressureUnit.BAR\n    conversion_map = {\n        PressureUnit.MILLI_BAR: UnitPrefix.MILLI.inverse(),\n        PressureUnit.BAR: 1,\n        PressureUnit.PSI: 14.5038,\n        PressureUnit.PASCAL: 100_000,\n        PressureUnit.KILO_PASCAL: 100,\n        PressureUnit.MEGA_PASCAL: 0.1,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AmountUnitConverter","title":"<code>AmountUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert amount units with this converter.</p> <p>AmountUnitConverter.convert(2000, AmountUnit.MOL, AmountUnit.KILO_MOL) 2.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(AmountUnit)\nclass AmountUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert amount units with this converter.\n\n    &gt;&gt;&gt; AmountUnitConverter.convert(2000, AmountUnit.MOL, AmountUnit.KILO_MOL)\n    2.0\n    \"\"\"\n\n    reference_unit = AmountUnit.MOL\n    conversion_map = {AmountUnit.MOL: 1, AmountUnit.KILO_MOL: UnitPrefix.KILO.inverse()}\n</code></pre>"},{"location":"converters/#property_utils.units.converters.AreaUnitConverter","title":"<code>AreaUnitConverter</code>","text":"<p>             Bases: <code>ExponentiatedUnitConverter</code></p> <p>Convert area units with this converter.</p> <p>AreaUnitConverter.convert(1, LengthUnit.METER2, LengthUnit.CENTI_METER2) 10000.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(LengthUnit**2)\nclass AreaUnitConverter(ExponentiatedUnitConverter):\n    \"\"\"\n    Convert area units with this converter.\n\n    &gt;&gt;&gt; AreaUnitConverter.convert(1, LengthUnit.METER**2, LengthUnit.CENTI_METER**2)\n    10000.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.ElectricCurrentUnitConverter","title":"<code>ElectricCurrentUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert electric current units with this converter.</p> <p>ElectricCurrentUnitConverter.convert(1000, ElectricCurrentUnit.MILLI_AMPERE, ElectricCurrentUnit.AMPERE) 1.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(ElectricCurrentUnit)\nclass ElectricCurrentUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert electric current units with this converter.\n\n    &gt;&gt;&gt; ElectricCurrentUnitConverter.convert(1000, ElectricCurrentUnit.MILLI_AMPERE, ElectricCurrentUnit.AMPERE)\n    1.0\n    \"\"\"\n\n    reference_unit = ElectricCurrentUnit.AMPERE\n    conversion_map = {\n        ElectricCurrentUnit.MILLI_AMPERE: UnitPrefix.MILLI.inverse(),\n        ElectricCurrentUnit.AMPERE: 1,\n        ElectricCurrentUnit.KILO_AMPERE: UnitPrefix.KILO.inverse(),\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.EnergyUnitConverter","title":"<code>EnergyUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert energy units (mass * length^2 / time^2) with this converter.</p> <p>from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER2) / (TimeUnit.MINUTE2) to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER2) / (TimeUnit.MINUTE2) EnergyUnitConverter.convert(25, from_unit, to_unit) 250.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(EnergyUnit.aliased_generic_descriptor())\nclass EnergyUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert energy units (mass * length^2 / time^2) with this converter.\n\n    &gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER**2) / (TimeUnit.MINUTE**2)\n    &gt;&gt;&gt; to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER**2) / (TimeUnit.MINUTE**2)\n    &gt;&gt;&gt; EnergyUnitConverter.convert(25, from_unit, to_unit)\n    250.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.ForceUnitConverter","title":"<code>ForceUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert force units (mass * length / time^2) with this converter.</p> <p>from_unit = MassUnit.KILO_GRAM * LengthUnit.CENTI_METER / (TimeUnit.SECOND2) to_unit = MassUnit.GRAM * LengthUnit.METER / (TimeUnit.SECOND2) ForceUnitConverter.convert(100, from_unit, to_unit) 1000.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(ForceUnit.aliased_generic_descriptor())\nclass ForceUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert force units (mass * length / time^2) with this converter.\n\n    &gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * LengthUnit.CENTI_METER / (TimeUnit.SECOND**2)\n    &gt;&gt;&gt; to_unit = MassUnit.GRAM * LengthUnit.METER / (TimeUnit.SECOND**2)\n    &gt;&gt;&gt; ForceUnitConverter.convert(100, from_unit, to_unit)\n    1000.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.LengthUnitConverter","title":"<code>LengthUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert length units with this converter.</p> <p>LengthUnitConverter.convert(2000, LengthUnit.MILLI_METER, LengthUnit.METER) 2.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(LengthUnit)\nclass LengthUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert length units with this converter.\n\n    &gt;&gt;&gt; LengthUnitConverter.convert(2000, LengthUnit.MILLI_METER, LengthUnit.METER)\n    2.0\n    \"\"\"\n\n    reference_unit = LengthUnit.METER\n    conversion_map = {\n        LengthUnit.MILLI_METER: UnitPrefix.MILLI.inverse(),\n        LengthUnit.CENTI_METER: UnitPrefix.CENTI.inverse(),\n        LengthUnit.METER: 1,\n        LengthUnit.KILO_METER: UnitPrefix.KILO.inverse(),\n        LengthUnit.INCH: 39.37,\n        LengthUnit.FOOT: 3.281,\n        LengthUnit.YARD: 1.094,\n        LengthUnit.MILE: 1 / 1609,\n        LengthUnit.NAUTICAL_MILE: 1 / 1852,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.MassUnitConverter","title":"<code>MassUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert mass units with this converter.</p> <p>MassUnitConverter.convert(10, MassUnit.KILO_GRAM, MassUnit.GRAM) 10000.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(MassUnit)\nclass MassUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert mass units with this converter.\n\n    &gt;&gt;&gt; MassUnitConverter.convert(10, MassUnit.KILO_GRAM, MassUnit.GRAM)\n    10000.0\n    \"\"\"\n\n    reference_unit = MassUnit.KILO_GRAM\n    conversion_map = {\n        MassUnit.MILLI_GRAM: UnitPrefix.KILO * UnitPrefix.MILLI.inverse(),\n        MassUnit.GRAM: UnitPrefix.KILO,\n        MassUnit.KILO_GRAM: 1,\n        MassUnit.METRIC_TONNE: 1 / 1_000.0,\n        MassUnit.POUND: 2.205,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.PowerUnitConverter","title":"<code>PowerUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert power units (mass * length^2 / time^3) with this converter.</p> <p>from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER2) / (TimeUnit.MINUTE3) to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER2) / (TimeUnit.MINUTE3) PowerUnitConverter.convert(15, from_unit, to_unit) 150.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PowerUnit.aliased_generic_descriptor())\nclass PowerUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert power units (mass * length^2 / time^3) with this converter.\n\n    &gt;&gt;&gt; from_unit = MassUnit.KILO_GRAM * (LengthUnit.METER**2) / (TimeUnit.MINUTE**3)\n    &gt;&gt;&gt; to_unit = MassUnit.METRIC_TONNE * (LengthUnit.CENTI_METER**2) / (TimeUnit.MINUTE**3)\n    &gt;&gt;&gt; PowerUnitConverter.convert(15, from_unit, to_unit)\n    150.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.PressureUnitConverter","title":"<code>PressureUnitConverter</code>","text":"<p>             Bases: <code>CompositeUnitConverter</code></p> <p>Convert pressure units (mass / length / time^2) with this converter.</p> <p>from_unit = MassUnit.GRAM / LengthUnit.CENTI_METER / (TimeUnit.HOUR2) to_unit = MassUnit.KILO_GRAM / LengthUnit.METER / (TimeUnit.HOUR2) PressureUnitConverter.convert(50, from_unit, to_unit) 5.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(PressureUnit.aliased_generic_descriptor())\nclass PressureUnitConverter(CompositeUnitConverter):\n    \"\"\"\n    Convert pressure units (mass / length / time^2) with this converter.\n\n    &gt;&gt;&gt; from_unit = MassUnit.GRAM / LengthUnit.CENTI_METER / (TimeUnit.HOUR**2)\n    &gt;&gt;&gt; to_unit = MassUnit.KILO_GRAM / LengthUnit.METER / (TimeUnit.HOUR**2)\n    &gt;&gt;&gt; PressureUnitConverter.convert(50, from_unit, to_unit)\n    5.0\n    \"\"\"\n</code></pre>"},{"location":"converters/#property_utils.units.converters.RelativeTemperatureUnitConverter","title":"<code>RelativeTemperatureUnitConverter</code>","text":"<p>             Bases: <code>RelativeUnitConverter</code></p> <p>Convert temperature units with this converter.</p> <p>RelativeTemperatureUnitConverter.convert(100, RelativeTemperatureUnit.CELCIUS, RelativeTemperatureUnit.FAHRENHEIT) 212.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(RelativeTemperatureUnit)\nclass RelativeTemperatureUnitConverter(\n    RelativeUnitConverter\n):  # pylint: disable=too-few-public-methods\n    \"\"\"\n    Convert temperature units with this converter.\n\n    &gt;&gt;&gt; RelativeTemperatureUnitConverter.convert(100, RelativeTemperatureUnit.CELCIUS, RelativeTemperatureUnit.FAHRENHEIT)\n    212.0\n    \"\"\"\n\n    reference_unit = RelativeTemperatureUnit.CELCIUS\n    conversion_map = {\n        RelativeTemperatureUnit.CELCIUS: lambda t: t,\n        AbsoluteTemperatureUnit.KELVIN: lambda t: t - 273.15,\n        RelativeTemperatureUnit.FAHRENHEIT: lambda t: (t - 32) / 1.8,\n        AbsoluteTemperatureUnit.RANKINE: lambda t: (t / 1.8) - 273.15,\n    }\n    reference_conversion_map = {\n        RelativeTemperatureUnit.CELCIUS: lambda t: t,\n        AbsoluteTemperatureUnit.KELVIN: lambda t: t + 273.15,\n        RelativeTemperatureUnit.FAHRENHEIT: lambda t: (t * 1.8) + 32,\n        AbsoluteTemperatureUnit.RANKINE: lambda t: (t + 273.15) * 1.8,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.TimeUnitConverter","title":"<code>TimeUnitConverter</code>","text":"<p>             Bases: <code>AbsoluteUnitConverter</code></p> <p>Convert time units with this converter.</p> <p>TimeUnitConverter.convert(1, TimeUnit.HOUR, TimeUnit.SECOND) 3600.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(TimeUnit)\nclass TimeUnitConverter(AbsoluteUnitConverter):\n    \"\"\"\n    Convert time units with this converter.\n\n    &gt;&gt;&gt; TimeUnitConverter.convert(1, TimeUnit.HOUR, TimeUnit.SECOND)\n    3600.0\n    \"\"\"\n\n    reference_unit = TimeUnit.SECOND\n    conversion_map = {\n        TimeUnit.MILLI_SECOND: UnitPrefix.MILLI.inverse(),\n        TimeUnit.SECOND: 1,\n        TimeUnit.MINUTE: 1 / 60.0,\n        TimeUnit.HOUR: 1 / 60.0 / 60.0,\n        TimeUnit.DAY: 1 / 60.0 / 60.0 / 24.0,\n        TimeUnit.WEEK: 1 / 60.0 / 60.0 / 24.0 / 7,\n        TimeUnit.MONTH: 1 / 60.0 / 60.0 / 24.0 / (365 / 12),\n        TimeUnit.YEAR: 1 / 60.0 / 60.0 / 24.0 / 365,\n    }\n</code></pre>"},{"location":"converters/#property_utils.units.converters.UnitPrefix","title":"<code>UnitPrefix</code>","text":"<p>             Bases: <code>float</code>, <code>Enum</code></p> <p>Enumeration of unit prefixes. Handy when converting to and fro prefixed units.</p> <p>centimeters = 225 meters = centimeters * UnitPrefix.CENTI assert meters == 2.25</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>class UnitPrefix(float, Enum):\n    \"\"\"\n    Enumeration of unit prefixes.\n    Handy when converting to and fro prefixed units.\n    &gt;&gt;&gt; centimeters = 225\n    &gt;&gt;&gt; meters = centimeters * UnitPrefix.CENTI\n    &gt;&gt;&gt; assert meters == 2.25\n    \"\"\"\n\n    PICO = 1e-12\n    NANO = 1e-9\n    MICRO = 1e-6\n    MILLI = 1e-3\n    CENTI = 1e-2\n    DECI = 1e-1\n    DECA = 1e1\n    HECTO = 1e2\n    KILO = 1e3\n    MEGA = 1e6\n    GIGA = 1e9\n    TERA = 1e12\n\n    def inverse(self) -&gt; float:\n        \"\"\"\n        Return the inverse of the unit prefix. Use when prefixing a unit.\n        &gt;&gt;&gt; meters = 50.26\n        &gt;&gt;&gt; centimeters = meters * UnitPrefix.CENTI.inverse()\n        &gt;&gt;&gt; assert centimeters == 5026\n        \"\"\"\n        return 1 / self.value\n</code></pre>"},{"location":"converters/#property_utils.units.converters.UnitPrefix.inverse","title":"<code>inverse()</code>","text":"<p>Return the inverse of the unit prefix. Use when prefixing a unit.</p> <p>meters = 50.26 centimeters = meters * UnitPrefix.CENTI.inverse() assert centimeters == 5026</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>def inverse(self) -&gt; float:\n    \"\"\"\n    Return the inverse of the unit prefix. Use when prefixing a unit.\n    &gt;&gt;&gt; meters = 50.26\n    &gt;&gt;&gt; centimeters = meters * UnitPrefix.CENTI.inverse()\n    &gt;&gt;&gt; assert centimeters == 5026\n    \"\"\"\n    return 1 / self.value\n</code></pre>"},{"location":"converters/#property_utils.units.converters.VolumeUnitConverter","title":"<code>VolumeUnitConverter</code>","text":"<p>             Bases: <code>ExponentiatedUnitConverter</code></p> <p>Convert volume units with this converter.</p> <p>VolumeUnitConverter.convert(1, LengthUnit.METER3, LengthUnit.CENTI_METER3) 1000000.0</p> Source code in <code>src/property_utils/units/converters.py</code> <pre><code>@register_converter(LengthUnit**3)\nclass VolumeUnitConverter(ExponentiatedUnitConverter):\n    \"\"\"\n    Convert volume units with this converter.\n\n    &gt;&gt;&gt; VolumeUnitConverter.convert(1, LengthUnit.METER**3, LengthUnit.CENTI_METER**3)\n    1000000.0\n    \"\"\"\n</code></pre>"},{"location":"descriptors/","title":"descriptors","text":"<p>This module includes definitions for generic unit descriptors and unit descriptors.</p> <p>A unit descriptor is an interface that describes a measurement unit. It can represent anything like \u00b0C, m^3, mol/m^3/s etc.</p> <p>A generic unit descriptor is an interface that describes a generic measurement unit. It can represent e.g. a temperature unit, a volume unit, a reaction rate unit etc.</p>"},{"location":"descriptors/#property_utils.units.descriptors.AliasMeasurementUnit","title":"<code>AliasMeasurementUnit</code>","text":"<p>             Bases: <code>MeasurementUnit</code></p> <p>Base class for common composite units of physical quantities.</p> <p>Subclasses of <code>MeasurementUnit</code> represent only primitive physical quantities. However, many common physical properties have composite units (e.g. pressure, force, energy, etc), thus subclasses of this class alias composite units as primitive ones.</p> <p>Only very common composite units should be aliased.</p> <p>e.g. you can create an alias for pressure units, instead of using mass * length / (     time^2) units.</p> <pre><code>class PressureUnit(AliasMeasurementUnit):\n    BAR = \"bar\"\n    PASCAL = \"Pa\"\n    KILO_PASCAL = \"kPa\"\n    PSI = \"psi\"\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class AliasMeasurementUnit(MeasurementUnit):\n    \"\"\"\n    Base class for common composite units of physical quantities.\n\n    Subclasses of `MeasurementUnit` represent only primitive physical quantities.\n    However, many common physical properties have composite units (e.g. pressure, force,\n    energy, etc), thus subclasses of this class alias composite units as primitive ones.\n\n    Only very common composite units should be aliased.\n\n    e.g. you can create an alias for pressure units, instead of using mass * length / (\n        time^2) units.\n\n    ```\n    class PressureUnit(AliasMeasurementUnit):\n        BAR = \"bar\"\n        PASCAL = \"Pa\"\n        KILO_PASCAL = \"kPa\"\n        PSI = \"psi\"\n    ```\n    \"\"\"\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; MeasurementUnit:\n        \"\"\"\n        Create an AliasMeasurementUnit from given descriptor.\n        If descriptor is already an AliasMeasurementUnit, it returns the same object.\n\n        This function does not serve as a constructor for AliasMeasurementUnit, rather\n        it is intended to be used to convert an unknown unit descriptor to an\n        AliasMeasurementUnit.\n\n        Subclasses should implement aliased_generic_descriptor and alias_mapping\n        methods.\n\n        Raises UnitDescriptorTypeError if given descriptor cannot be translated\n        to an AliasMeasurementUnit  instance.\n\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     BAR = \"bar\"\n\n        &gt;&gt;&gt; bar = MeasurementUnit.from_descriptor(PressureUnit.BAR**(-1))\n        &gt;&gt;&gt; assert bar == PressureUnit.BAR\n        \"\"\"\n        if isinstance(descriptor, Dimension) and isinstance(\n            descriptor.unit, AliasMeasurementUnit\n        ):\n            return descriptor.unit\n        if isinstance(descriptor, AliasMeasurementUnit):\n            return descriptor\n        raise UnitDescriptorTypeError(\n            f\"cannot create AliasMeasurementUnit from descriptor {descriptor}\"\n        )\n\n    @classmethod\n    def aliased_generic_descriptor(cls) -&gt; GenericUnitDescriptor:\n        \"\"\"\n        Implement this method by returning the generic of the unit descriptor that this\n        measurement unit aliases.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n        ...     @classmethod\n        ...     def aliased_generic_descriptor(cls):\n        ...         return LengthUnit**2\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.AliasMeasurementUnit.aliased_generic_descriptor","title":"<code>aliased_generic_descriptor()</code>  <code>classmethod</code>","text":"<p>Implement this method by returning the generic of the unit descriptor that this measurement unit aliases.</p> <p>class LengthUnit(MeasurementUnit): ... class AreaUnit(AliasMeasurementUnit): ...     @classmethod ...     def aliased_generic_descriptor(cls): ...         return LengthUnit**2</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@classmethod\ndef aliased_generic_descriptor(cls) -&gt; GenericUnitDescriptor:\n    \"\"\"\n    Implement this method by returning the generic of the unit descriptor that this\n    measurement unit aliases.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class AreaUnit(AliasMeasurementUnit):\n    ...     @classmethod\n    ...     def aliased_generic_descriptor(cls):\n    ...         return LengthUnit**2\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.AliasMeasurementUnit.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create an AliasMeasurementUnit from given descriptor. If descriptor is already an AliasMeasurementUnit, it returns the same object.</p> <p>This function does not serve as a constructor for AliasMeasurementUnit, rather it is intended to be used to convert an unknown unit descriptor to an AliasMeasurementUnit.</p> <p>Subclasses should implement aliased_generic_descriptor and alias_mapping methods.</p> <p>Raises UnitDescriptorTypeError if given descriptor cannot be translated to an AliasMeasurementUnit  instance.</p> <p>class PressureUnit(AliasMeasurementUnit): ...     BAR = \"bar\"</p> <p>bar = MeasurementUnit.from_descriptor(PressureUnit.BAR**(-1)) assert bar == PressureUnit.BAR</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; MeasurementUnit:\n    \"\"\"\n    Create an AliasMeasurementUnit from given descriptor.\n    If descriptor is already an AliasMeasurementUnit, it returns the same object.\n\n    This function does not serve as a constructor for AliasMeasurementUnit, rather\n    it is intended to be used to convert an unknown unit descriptor to an\n    AliasMeasurementUnit.\n\n    Subclasses should implement aliased_generic_descriptor and alias_mapping\n    methods.\n\n    Raises UnitDescriptorTypeError if given descriptor cannot be translated\n    to an AliasMeasurementUnit  instance.\n\n    &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n    ...     BAR = \"bar\"\n\n    &gt;&gt;&gt; bar = MeasurementUnit.from_descriptor(PressureUnit.BAR**(-1))\n    &gt;&gt;&gt; assert bar == PressureUnit.BAR\n    \"\"\"\n    if isinstance(descriptor, Dimension) and isinstance(\n        descriptor.unit, AliasMeasurementUnit\n    ):\n        return descriptor.unit\n    if isinstance(descriptor, AliasMeasurementUnit):\n        return descriptor\n    raise UnitDescriptorTypeError(\n        f\"cannot create AliasMeasurementUnit from descriptor {descriptor}\"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension","title":"<code>CompositeDimension</code>  <code>dataclass</code>","text":"<p>A CompositeDimension represents a measurement unit that is composed from other measurement units.</p> <p>Objects of this class can represent either multiplication or division between two Dimension objects.</p> <p>Create objects by multiplying and diving Dimension or MeasurementUnit objects:</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\"</p> <p>class AmountUnit(MeasurementUnit): ...     KILO_MOL = \"kmol\"</p> <p>molal_volume_dimension = (LengthUnit.METER**3) / AmountUnit.KILO_MOL assert type(molal_volume_dimension) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass CompositeDimension:\n    \"\"\"\n    A CompositeDimension represents a measurement unit that is composed from other\n    measurement units.\n\n    Objects of this class can represent either multiplication or division between two\n    Dimension objects.\n\n    Create objects by multiplying and diving Dimension or MeasurementUnit objects:\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n\n    &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n    ...     KILO_MOL = \"kmol\"\n\n    &gt;&gt;&gt; molal_volume_dimension = (LengthUnit.METER**3) / AmountUnit.KILO_MOL\n    &gt;&gt;&gt; assert type(molal_volume_dimension) == CompositeDimension\n    \"\"\"\n\n    Default = TypeVar(\"Default\")  # default return type for `get` functions.\n\n    numerator: List[Dimension] = field(default_factory=list)\n    denominator: List[Dimension] = field(default_factory=list)\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a CompositeDimension from given descriptor.\n        If descriptor is already a CompositeDimension, it returns the same object.\n\n        This function does not serve as a constructor for CompositeDimension, rather it\n        is intended to be used to convert an unknown unit descriptor to a\n        CompositeDimension.\n\n        Raises UnitDescriptorTypeError if given descriptor cannot be translated\n        to a CompositeDimension instance.\n        \"\"\"\n        if not isinstance(descriptor, CompositeDimension):\n            raise UnitDescriptorTypeError(\n                f\"cannot create CompositeDimension from descriptor {descriptor}\"\n            )\n        return descriptor\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the CompositeDimension is an instance of the generic, False\n        otherwise.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.METER).isinstance(TemperatureUnit / LengthUnit)\n        True\n\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.METER).isinstance(TemperatureUnit**2)\n        False\n        \"\"\"\n        if not isinstance(generic, GenericCompositeDimension):\n            return False\n        return self.to_generic() == generic\n\n    def to_generic(self) -&gt; GenericCompositeDimension:\n        \"\"\"\n        Create a generic descriptor from this CompositeDimension.\n\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n        ...     MOL = \"mol\"\n\n        &gt;&gt;&gt; class MassUnit(MeasurementUnit):\n        ...     KILO_GRAM = \"kg\"\n\n        &gt;&gt;&gt; (AmountUnit.MOL / MassUnit.KILO_GRAM).to_generic()\n        &lt;GenericCompositeDimension: AmountUnit / MassUnit&gt;\n        \"\"\"\n        return GenericCompositeDimension(\n            numerator=[n.to_generic() for n in self.numerator],\n            denominator=[d.to_generic() for d in self.denominator],\n        )\n\n    def get_numerator(\n        self,\n        generic: Union[MeasurementUnitType, GenericDimension],\n        default: Optional[Default] = None,\n    ) -&gt; Union[Dimension, Optional[Default]]:\n        \"\"\"\n        Get a dimension from the numerator. If the dimension is not found it returns\n        the default.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n        &gt;&gt;&gt; composite.get_numerator(TemperatureUnit)\n        &lt;Dimension: K&gt;\n        &gt;&gt;&gt; composite.get_numerator(LengthUnit, \"default\")\n        'default'\n        \"\"\"\n        for n in self.numerator:\n            if n.isinstance(generic):\n                return n\n        return default\n\n    def get_denominator(\n        self,\n        generic: Union[MeasurementUnitType, GenericDimension],\n        default: Optional[Default] = None,\n    ) -&gt; Union[Dimension, Optional[Default]]:\n        \"\"\"\n        Get a dimension from the denominator. If the dimension is not found it returns\n        the default.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n        &gt;&gt;&gt; composite.get_denominator(LengthUnit**3)\n        &lt;Dimension: m^3&gt;\n        &gt;&gt;&gt; composite.get_denominator(LengthUnit, \"default\")\n        'default'\n        \"\"\"\n        for d in self.denominator:\n            if d.isinstance(generic):\n                return d\n        return default\n\n    def simplify(self) -&gt; None:\n        \"\"\"\n        Simplify the composite by merging common dimensions.\n\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     BAR = \"bar\"\n        ...     PASCAL = \"Pa\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: K / (bar^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: Pa * Pa * m / s&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: (Pa^2) * m / s&gt;\n        \"\"\"\n        exponents: Dict[MeasurementUnit, float] = {}\n        for n in self.numerator:\n            if n.unit in exponents:\n                exponents[n.unit] += n.power\n            else:\n                exponents[n.unit] = n.power\n\n        for d in self.denominator:\n            if d.unit in exponents:\n                exponents[d.unit] -= d.power\n            else:\n                exponents[d.unit] = 0 - d.power\n\n        numerator = []\n        denominator = []\n        for unit, exponent in exponents.items():\n            if exponent &gt; 0:\n                numerator.append(Dimension(unit) ** exponent)\n            elif exponent &lt; 0:\n                denominator.append(Dimension(unit) ** abs(exponent))\n\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def simplified(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Returns a simplified version of this composite dimension as a new object.\n\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n        ...     BAR = \"bar\"\n        ...     PASCAL = \"Pa\"\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;CompositeDimension: K / (bar^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n        &gt;&gt;&gt; composite\n        &lt;CompositeDimension: Pa * Pa * m / s&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;CompositeDimension: (Pa^2) * m / s&gt;\n        \"\"\"\n        copy = replace(self)\n        copy.simplify()\n        return copy\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n\n        &gt;&gt;&gt; (LengthUnit.METER / TimeUnit.SECOND).inverse()\n        &lt;CompositeDimension: s / m&gt;\n        \"\"\"\n        return CompositeDimension(self._denominator_copy(), self._numerator_copy())\n\n    def _numerator_copy(self) -&gt; List[Dimension]:\n        return [replace(n) for n in self.numerator]\n\n    def _denominator_copy(self) -&gt; List[Dimension]:\n        return [replace(d) for d in self.denominator]\n\n    def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS / LengthUnit.CENTI_METER) * TimeUnit.SECOND) == CompositeDimension\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(descriptor, CompositeDimension):\n            numerator.extend(descriptor.numerator)\n            denominator.extend(descriptor.denominator)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            numerator.append(descriptor)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, MeasurementUnit):\n            numerator.append(Dimension(descriptor))\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        raise DescriptorBinaryOperationError(\n            f\"cannot multiply {self} with {descriptor}. \"\n        )\n\n    def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     CENTI_METER = \"cm\"\n        &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS * LengthUnit.CENTI_METER) / TimeUnit.SECOND) == CompositeDimension\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(descriptor, CompositeDimension):\n            numerator.extend(descriptor.denominator)\n            denominator.extend(descriptor.numerator)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            denominator.append(descriptor)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, MeasurementUnit):\n            denominator.append(Dimension(descriptor))\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        raise DescriptorBinaryOperationError(\n            f\"cannot divide {self} with {descriptor}. \"\n        )\n\n    def __pow__(self, power: float) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines exponentiation for CompositeDimension(s).\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n\n        &gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR)**2\n        &lt;CompositeDimension: (C^2) / (hr^2)&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        numerator = [n**power for n in self._numerator_copy()]\n        denominator = [d**power for d in self._denominator_copy()]\n        return CompositeDimension(numerator, denominator)\n\n    def __eq__(self, dimension) -&gt; bool:\n        \"\"\"\n        Defines equality for CompositeDimension(s).\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n        &gt;&gt;&gt; assert (TemperatureUnit.CELCIUS / TimeUnit.HOUR) != (TimeUnit.HOUR / TemperatureUnit.CELCIUS)\n        \"\"\"\n        if not isinstance(dimension, CompositeDimension):\n            return False\n        return Counter(self.numerator) == Counter(dimension.numerator) and (\n            Counter(self.denominator) == Counter(dimension.denominator)\n        )\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __str__(self):\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return numerators + denominators\n\n    def __repr__(self) -&gt; str:\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return f\"&lt;CompositeDimension: {numerators + denominators}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__eq__","title":"<code>__eq__(dimension)</code>","text":"<p>Defines equality for CompositeDimension(s).</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" class TimeUnit(MeasurementUnit): ...     HOUR = \"hr\" assert (TemperatureUnit.CELCIUS / TimeUnit.HOUR) != (TimeUnit.HOUR / TemperatureUnit.CELCIUS)</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, dimension) -&gt; bool:\n    \"\"\"\n    Defines equality for CompositeDimension(s).\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     HOUR = \"hr\"\n    &gt;&gt;&gt; assert (TemperatureUnit.CELCIUS / TimeUnit.HOUR) != (TimeUnit.HOUR / TemperatureUnit.CELCIUS)\n    \"\"\"\n    if not isinstance(dimension, CompositeDimension):\n        return False\n    return Counter(self.numerator) == Counter(dimension.numerator) and (\n        Counter(self.denominator) == Counter(dimension.denominator)\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__mul__","title":"<code>__mul__(descriptor)</code>","text":"<p>Defines multiplication between CompositeDimension(s) and other unit descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" class TimeUnit(MeasurementUnit): ...     SECOND = \"s\" class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" assert type((TemperatureUnit.CELCIUS / LengthUnit.CENTI_METER) * TimeUnit.SECOND) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS / LengthUnit.CENTI_METER) * TimeUnit.SECOND) == CompositeDimension\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(descriptor, CompositeDimension):\n        numerator.extend(descriptor.numerator)\n        denominator.extend(descriptor.denominator)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        numerator.append(descriptor)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, MeasurementUnit):\n        numerator.append(Dimension(descriptor))\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    raise DescriptorBinaryOperationError(\n        f\"cannot multiply {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for CompositeDimension(s).</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" class TimeUnit(MeasurementUnit): ...     HOUR = \"hr\"</p> <p>(TemperatureUnit.CELCIUS / TimeUnit.HOUR)**2  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines exponentiation for CompositeDimension(s).\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     HOUR = \"hr\"\n\n    &gt;&gt;&gt; (TemperatureUnit.CELCIUS / TimeUnit.HOUR)**2\n    &lt;CompositeDimension: (C^2) / (hr^2)&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    numerator = [n**power for n in self._numerator_copy()]\n    denominator = [d**power for d in self._denominator_copy()]\n    return CompositeDimension(numerator, denominator)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.__truediv__","title":"<code>__truediv__(descriptor)</code>","text":"<p>Defines multiplication between CompositeDimension(s) and other unit descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" class TimeUnit(MeasurementUnit): ...     SECOND = \"s\" class LengthUnit(MeasurementUnit): ...     CENTI_METER = \"cm\" assert type((TemperatureUnit.CELCIUS * LengthUnit.CENTI_METER) / TimeUnit.SECOND) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between CompositeDimension(s) and other unit descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     CENTI_METER = \"cm\"\n    &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS * LengthUnit.CENTI_METER) / TimeUnit.SECOND) == CompositeDimension\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(descriptor, CompositeDimension):\n        numerator.extend(descriptor.denominator)\n        denominator.extend(descriptor.numerator)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        denominator.append(descriptor)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, MeasurementUnit):\n        denominator.append(Dimension(descriptor))\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    raise DescriptorBinaryOperationError(\n        f\"cannot divide {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create a CompositeDimension from given descriptor. If descriptor is already a CompositeDimension, it returns the same object.</p> <p>This function does not serve as a constructor for CompositeDimension, rather it is intended to be used to convert an unknown unit descriptor to a CompositeDimension.</p> <p>Raises UnitDescriptorTypeError if given descriptor cannot be translated to a CompositeDimension instance.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a CompositeDimension from given descriptor.\n    If descriptor is already a CompositeDimension, it returns the same object.\n\n    This function does not serve as a constructor for CompositeDimension, rather it\n    is intended to be used to convert an unknown unit descriptor to a\n    CompositeDimension.\n\n    Raises UnitDescriptorTypeError if given descriptor cannot be translated\n    to a CompositeDimension instance.\n    \"\"\"\n    if not isinstance(descriptor, CompositeDimension):\n        raise UnitDescriptorTypeError(\n            f\"cannot create CompositeDimension from descriptor {descriptor}\"\n        )\n    return descriptor\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.get_denominator","title":"<code>get_denominator(generic, default=None)</code>","text":"<p>Get a dimension from the denominator. If the dimension is not found it returns the default.</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\"</p> <p>class TemperatureUnit(MeasurementUnit): ...     KELVIN = \"K\"</p> <p>composite = TemperatureUnit.KELVIN / (LengthUnit.METER3) composite.get_denominator(LengthUnit3)  composite.get_denominator(LengthUnit, \"default\") 'default' Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def get_denominator(\n    self,\n    generic: Union[MeasurementUnitType, GenericDimension],\n    default: Optional[Default] = None,\n) -&gt; Union[Dimension, Optional[Default]]:\n    \"\"\"\n    Get a dimension from the denominator. If the dimension is not found it returns\n    the default.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     KELVIN = \"K\"\n\n    &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n    &gt;&gt;&gt; composite.get_denominator(LengthUnit**3)\n    &lt;Dimension: m^3&gt;\n    &gt;&gt;&gt; composite.get_denominator(LengthUnit, \"default\")\n    'default'\n    \"\"\"\n    for d in self.denominator:\n        if d.isinstance(generic):\n            return d\n    return default\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.get_numerator","title":"<code>get_numerator(generic, default=None)</code>","text":"<p>Get a dimension from the numerator. If the dimension is not found it returns the default.</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\"</p> <p>class TemperatureUnit(MeasurementUnit): ...     KELVIN = \"K\"</p> <p>composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3) composite.get_numerator(TemperatureUnit)  composite.get_numerator(LengthUnit, \"default\") 'default' Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def get_numerator(\n    self,\n    generic: Union[MeasurementUnitType, GenericDimension],\n    default: Optional[Default] = None,\n) -&gt; Union[Dimension, Optional[Default]]:\n    \"\"\"\n    Get a dimension from the numerator. If the dimension is not found it returns\n    the default.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     KELVIN = \"K\"\n\n    &gt;&gt;&gt; composite = TemperatureUnit.KELVIN / (LengthUnit.METER**3)\n    &gt;&gt;&gt; composite.get_numerator(TemperatureUnit)\n    &lt;Dimension: K&gt;\n    &gt;&gt;&gt; composite.get_numerator(LengthUnit, \"default\")\n    'default'\n    \"\"\"\n    for n in self.numerator:\n        if n.isinstance(generic):\n            return n\n    return default\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\" class TimeUnit(MeasurementUnit): ...     SECOND = \"s\"</p> <p>(LengthUnit.METER / TimeUnit.SECOND).inverse()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n\n    &gt;&gt;&gt; (LengthUnit.METER / TimeUnit.SECOND).inverse()\n    &lt;CompositeDimension: s / m&gt;\n    \"\"\"\n    return CompositeDimension(self._denominator_copy(), self._numerator_copy())\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the CompositeDimension is an instance of the generic, False otherwise.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\"</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\"</p> <p>(TemperatureUnit.CELCIUS / LengthUnit.METER).isinstance(TemperatureUnit / LengthUnit) True</p> <p>(TemperatureUnit.CELCIUS * LengthUnit.METER).isinstance(TemperatureUnit**2) False</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the CompositeDimension is an instance of the generic, False\n    otherwise.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n\n    &gt;&gt;&gt; (TemperatureUnit.CELCIUS / LengthUnit.METER).isinstance(TemperatureUnit / LengthUnit)\n    True\n\n    &gt;&gt;&gt; (TemperatureUnit.CELCIUS * LengthUnit.METER).isinstance(TemperatureUnit**2)\n    False\n    \"\"\"\n    if not isinstance(generic, GenericCompositeDimension):\n        return False\n    return self.to_generic() == generic\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.simplified","title":"<code>simplified()</code>","text":"<p>Returns a simplified version of this composite dimension as a new object.</p> <p>class PressureUnit(AliasMeasurementUnit): ...     BAR = \"bar\" ...     PASCAL = \"Pa\"</p> <p>class TemperatureUnit(MeasurementUnit): ...     KELVIN = \"K\"</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\"</p> <p>class TimeUnit(MeasurementUnit): ...     SECOND = \"s\"</p> <p>composite = (PressureUnit.BAR(-2)) / (TemperatureUnit.KELVIN(-1)) composite  composite.simplified()  <p>composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND composite  composite.simplified()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplified(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Returns a simplified version of this composite dimension as a new object.\n\n    &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n    ...     BAR = \"bar\"\n    ...     PASCAL = \"Pa\"\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     KELVIN = \"K\"\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n\n    &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n    &gt;&gt;&gt; composite\n    &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n    &gt;&gt;&gt; composite.simplified()\n    &lt;CompositeDimension: K / (bar^2)&gt;\n\n    &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n    &gt;&gt;&gt; composite\n    &lt;CompositeDimension: Pa * Pa * m / s&gt;\n    &gt;&gt;&gt; composite.simplified()\n    &lt;CompositeDimension: (Pa^2) * m / s&gt;\n    \"\"\"\n    copy = replace(self)\n    copy.simplify()\n    return copy\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.simplify","title":"<code>simplify()</code>","text":"<p>Simplify the composite by merging common dimensions.</p> <p>class PressureUnit(AliasMeasurementUnit): ...     BAR = \"bar\" ...     PASCAL = \"Pa\"</p> <p>class TemperatureUnit(MeasurementUnit): ...     KELVIN = \"K\"</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\"</p> <p>class TimeUnit(MeasurementUnit): ...     SECOND = \"s\"</p> <p>composite = (PressureUnit.BAR(-2)) / (TemperatureUnit.KELVIN(-1)) composite  composite.simplify() composite  <p>composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND composite  composite.simplify() composite  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplify(self) -&gt; None:\n    \"\"\"\n    Simplify the composite by merging common dimensions.\n\n    &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit):\n    ...     BAR = \"bar\"\n    ...     PASCAL = \"Pa\"\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     KELVIN = \"K\"\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n\n    &gt;&gt;&gt; composite = (PressureUnit.BAR**(-2)) / (TemperatureUnit.KELVIN**(-1))\n    &gt;&gt;&gt; composite\n    &lt;CompositeDimension: (bar^-2) / (K^-1)&gt;\n    &gt;&gt;&gt; composite.simplify()\n    &gt;&gt;&gt; composite\n    &lt;CompositeDimension: K / (bar^2)&gt;\n\n    &gt;&gt;&gt; composite = PressureUnit.PASCAL * LengthUnit.METER * PressureUnit.PASCAL /TimeUnit.SECOND\n    &gt;&gt;&gt; composite\n    &lt;CompositeDimension: Pa * Pa * m / s&gt;\n    &gt;&gt;&gt; composite.simplify()\n    &gt;&gt;&gt; composite\n    &lt;CompositeDimension: (Pa^2) * m / s&gt;\n    \"\"\"\n    exponents: Dict[MeasurementUnit, float] = {}\n    for n in self.numerator:\n        if n.unit in exponents:\n            exponents[n.unit] += n.power\n        else:\n            exponents[n.unit] = n.power\n\n    for d in self.denominator:\n        if d.unit in exponents:\n            exponents[d.unit] -= d.power\n        else:\n            exponents[d.unit] = 0 - d.power\n\n    numerator = []\n    denominator = []\n    for unit, exponent in exponents.items():\n        if exponent &gt; 0:\n            numerator.append(Dimension(unit) ** exponent)\n        elif exponent &lt; 0:\n            denominator.append(Dimension(unit) ** abs(exponent))\n\n    self.numerator = numerator\n    self.denominator = denominator\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.CompositeDimension.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this CompositeDimension.</p> <p>class AmountUnit(MeasurementUnit): ...     MOL = \"mol\"</p> <p>class MassUnit(MeasurementUnit): ...     KILO_GRAM = \"kg\"</p> <p>(AmountUnit.MOL / MassUnit.KILO_GRAM).to_generic()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericCompositeDimension:\n    \"\"\"\n    Create a generic descriptor from this CompositeDimension.\n\n    &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n    ...     MOL = \"mol\"\n\n    &gt;&gt;&gt; class MassUnit(MeasurementUnit):\n    ...     KILO_GRAM = \"kg\"\n\n    &gt;&gt;&gt; (AmountUnit.MOL / MassUnit.KILO_GRAM).to_generic()\n    &lt;GenericCompositeDimension: AmountUnit / MassUnit&gt;\n    \"\"\"\n    return GenericCompositeDimension(\n        numerator=[n.to_generic() for n in self.numerator],\n        denominator=[d.to_generic() for d in self.denominator],\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension","title":"<code>Dimension</code>  <code>dataclass</code>","text":"<p>A Dimension is a wrapper around MeasurementUnit.</p> <p>Objects of this class can represent either a simple MeasurementUnit or a MeasurementUnit to some power.</p> <p>class TimeUnit(MeasurementUnit): ...     SECOND = \"s\"</p> <p>assert type(TimeUnit.SECOND**2) == Dimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass Dimension:\n    \"\"\"\n    A Dimension is a wrapper around MeasurementUnit.\n\n    Objects of this class can represent either a simple MeasurementUnit or a\n    MeasurementUnit to some power.\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n\n    &gt;&gt;&gt; assert type(TimeUnit.SECOND**2) == Dimension\n    \"\"\"\n\n    unit: MeasurementUnit\n    power: float = 1\n\n    def __init__(self, unit: MeasurementUnit, power: float = 1) -&gt; None:\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.unit = unit\n        self.power = power\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; \"Dimension\":\n        \"\"\"\n        Create a Dimension from given descriptor.\n        If descriptor is already a Dimension, it returns the same object.\n\n        This function does not serve as a constructor for Dimension, rather it\n        is intended to be used to convert an unknown unit descriptor to a Dimension.\n\n        Raises UnitDescriptorTypeError if given descriptor cannot be translated\n        to a Dimension instance.\n        \"\"\"\n        if isinstance(descriptor, Dimension):\n            return descriptor\n        if isinstance(descriptor, MeasurementUnit):\n            return Dimension(descriptor)\n        raise UnitDescriptorTypeError(\n            f\"cannot create Dimension from descriptor: {descriptor}\"\n        )\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the Dimension is an instance of the generic, False\n        otherwise.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit)\n        True\n\n        &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit**2)\n        False\n        \"\"\"\n        if isinstance(generic, MeasurementUnitType):\n            generic = GenericDimension(generic)\n        if not isinstance(generic, GenericDimension):\n            return False\n        if isinstance(self.unit, generic.unit_type) and self.power == generic.power:\n            return True\n        return False\n\n    def to_generic(self) -&gt; GenericDimension:\n        \"\"\"\n        Create a generic descriptor from this Dimension.\n\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n        ...     MOL = \"mol\"\n\n        &gt;&gt;&gt; (AmountUnit.MOL**3.56).to_generic()\n        &lt;GenericDimension: AmountUnit^3.56&gt;\n        \"\"\"\n        return GenericDimension(type(self.unit), self.power)\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        &gt;&gt;&gt; (LengthUnit.METER**2).inverse()\n        &lt;CompositeDimension:  / (m^2)&gt;\n        \"\"\"\n        return CompositeDimension([], [replace(self)])\n\n    def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between Dimension(s) and other unit descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     MINUTE = \"min\"\n        &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS**3) * TimeUnit.MINUTE) == CompositeDimension\n        \"\"\"\n        if isinstance(descriptor, CompositeDimension):\n            numerator = descriptor.numerator.copy()\n            denominator = descriptor.denominator.copy()\n            numerator.append(self)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            return CompositeDimension(numerator=[self, descriptor])\n        if isinstance(descriptor, MeasurementUnit):\n            return CompositeDimension(numerator=[self, Dimension(descriptor)])\n        raise DescriptorBinaryOperationError(\n            f\"cannot multiply {self} with {descriptor}. \"\n        )\n\n    def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines division between Dimension(s) and other unit descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     MINUTE = \"min\"\n        &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS**3) / TimeUnit.MINUTE) == CompositeDimension\n        \"\"\"\n        if isinstance(descriptor, CompositeDimension):\n            numerator = descriptor.denominator.copy()\n            denominator = descriptor.numerator.copy()\n            numerator.append(self)\n            return CompositeDimension(numerator=numerator, denominator=denominator)\n        if isinstance(descriptor, Dimension):\n            return CompositeDimension(numerator=[self], denominator=[descriptor])\n        if isinstance(descriptor, MeasurementUnit):\n            return CompositeDimension(\n                numerator=[self], denominator=[Dimension(descriptor)]\n            )\n        raise DescriptorBinaryOperationError(\n            f\"cannot divide {self} with  {descriptor}. \"\n        )\n\n    def __pow__(self, power: float) -&gt; \"Dimension\":\n        \"\"\"\n        Defines exponentiation for Dimension(s).\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        &gt;&gt;&gt; assert type((TimeUnit.SECOND**2)**3) == Dimension\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.power *= power\n        return self\n\n    def __eq__(self, dimension) -&gt; bool:\n        \"\"\"\n        Defines equality for Dimension(s).\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n        &gt;&gt;&gt; assert (TemperatureUnit.KELVIN**2) != TemperatureUnit.KELVIN\n        \"\"\"\n        if not isinstance(dimension, Dimension):\n            return False\n        return self.unit == dimension.unit and self.power == dimension.power\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __repr__(self) -&gt; str:\n        if self.power != 1:\n            return f\"&lt;Dimension: {self.unit.value}^{self.power}&gt;\"\n        return f\"&lt;Dimension: {self.unit.value}&gt;\"\n\n    def __str__(self) -&gt; str:\n        s = self.unit.value\n        if self.power != 1:\n            return f\"({s}^{self.power})\"\n        return s\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__eq__","title":"<code>__eq__(dimension)</code>","text":"<p>Defines equality for Dimension(s).</p> <p>class TemperatureUnit(MeasurementUnit): ...     KELVIN = \"K\" assert (TemperatureUnit.KELVIN**2) != TemperatureUnit.KELVIN</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, dimension) -&gt; bool:\n    \"\"\"\n    Defines equality for Dimension(s).\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     KELVIN = \"K\"\n    &gt;&gt;&gt; assert (TemperatureUnit.KELVIN**2) != TemperatureUnit.KELVIN\n    \"\"\"\n    if not isinstance(dimension, Dimension):\n        return False\n    return self.unit == dimension.unit and self.power == dimension.power\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__mul__","title":"<code>__mul__(descriptor)</code>","text":"<p>Defines multiplication between Dimension(s) and other unit descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" class TimeUnit(MeasurementUnit): ...     MINUTE = \"min\" assert type((TemperatureUnit.CELCIUS**3) * TimeUnit.MINUTE) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between Dimension(s) and other unit descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     MINUTE = \"min\"\n    &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS**3) * TimeUnit.MINUTE) == CompositeDimension\n    \"\"\"\n    if isinstance(descriptor, CompositeDimension):\n        numerator = descriptor.numerator.copy()\n        denominator = descriptor.denominator.copy()\n        numerator.append(self)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        return CompositeDimension(numerator=[self, descriptor])\n    if isinstance(descriptor, MeasurementUnit):\n        return CompositeDimension(numerator=[self, Dimension(descriptor)])\n    raise DescriptorBinaryOperationError(\n        f\"cannot multiply {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for Dimension(s).</p> <p>class TimeUnit(MeasurementUnit): ...     SECOND = \"s\" assert type((TimeUnit.SECOND2)3) == Dimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"Dimension\":\n    \"\"\"\n    Defines exponentiation for Dimension(s).\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n    &gt;&gt;&gt; assert type((TimeUnit.SECOND**2)**3) == Dimension\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    self.power *= power\n    return self\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.__truediv__","title":"<code>__truediv__(descriptor)</code>","text":"<p>Defines division between Dimension(s) and other unit descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" class TimeUnit(MeasurementUnit): ...     MINUTE = \"min\" assert type((TemperatureUnit.CELCIUS**3) / TimeUnit.MINUTE) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines division between Dimension(s) and other unit descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     MINUTE = \"min\"\n    &gt;&gt;&gt; assert type((TemperatureUnit.CELCIUS**3) / TimeUnit.MINUTE) == CompositeDimension\n    \"\"\"\n    if isinstance(descriptor, CompositeDimension):\n        numerator = descriptor.denominator.copy()\n        denominator = descriptor.numerator.copy()\n        numerator.append(self)\n        return CompositeDimension(numerator=numerator, denominator=denominator)\n    if isinstance(descriptor, Dimension):\n        return CompositeDimension(numerator=[self], denominator=[descriptor])\n    if isinstance(descriptor, MeasurementUnit):\n        return CompositeDimension(\n            numerator=[self], denominator=[Dimension(descriptor)]\n        )\n    raise DescriptorBinaryOperationError(\n        f\"cannot divide {self} with  {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create a Dimension from given descriptor. If descriptor is already a Dimension, it returns the same object.</p> <p>This function does not serve as a constructor for Dimension, rather it is intended to be used to convert an unknown unit descriptor to a Dimension.</p> <p>Raises UnitDescriptorTypeError if given descriptor cannot be translated to a Dimension instance.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; \"Dimension\":\n    \"\"\"\n    Create a Dimension from given descriptor.\n    If descriptor is already a Dimension, it returns the same object.\n\n    This function does not serve as a constructor for Dimension, rather it\n    is intended to be used to convert an unknown unit descriptor to a Dimension.\n\n    Raises UnitDescriptorTypeError if given descriptor cannot be translated\n    to a Dimension instance.\n    \"\"\"\n    if isinstance(descriptor, Dimension):\n        return descriptor\n    if isinstance(descriptor, MeasurementUnit):\n        return Dimension(descriptor)\n    raise UnitDescriptorTypeError(\n        f\"cannot create Dimension from descriptor: {descriptor}\"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\" (LengthUnit.METER**2).inverse()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n    &gt;&gt;&gt; (LengthUnit.METER**2).inverse()\n    &lt;CompositeDimension:  / (m^2)&gt;\n    \"\"\"\n    return CompositeDimension([], [replace(self)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the Dimension is an instance of the generic, False otherwise.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\"</p> <p>Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit) True</p> <p>Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit**2) False</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the Dimension is an instance of the generic, False\n    otherwise.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n\n    &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit)\n    True\n\n    &gt;&gt;&gt; Dimension(TemperatureUnit.CELCIUS).isinstance(TemperatureUnit**2)\n    False\n    \"\"\"\n    if isinstance(generic, MeasurementUnitType):\n        generic = GenericDimension(generic)\n    if not isinstance(generic, GenericDimension):\n        return False\n    if isinstance(self.unit, generic.unit_type) and self.power == generic.power:\n        return True\n    return False\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.Dimension.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this Dimension.</p> <p>class AmountUnit(MeasurementUnit): ...     MOL = \"mol\"</p> <p>(AmountUnit.MOL**3.56).to_generic()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericDimension:\n    \"\"\"\n    Create a generic descriptor from this Dimension.\n\n    &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n    ...     MOL = \"mol\"\n\n    &gt;&gt;&gt; (AmountUnit.MOL**3.56).to_generic()\n    &lt;GenericDimension: AmountUnit^3.56&gt;\n    \"\"\"\n    return GenericDimension(type(self.unit), self.power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension","title":"<code>GenericCompositeDimension</code>  <code>dataclass</code>","text":"<p>A <code>GenericCompositeDimension</code> represents a generic measurement unit that is composed from other generic measurement units.</p> <p>Objects of this class can represent either multiplication or division between two <code>GenericDimension</code> objects.</p> <p>Create objects by multiplying and diving GenericDimension or MeasurementUnitMeta class objects:</p> <p>class LengthUnit(MeasurementUnit): ... class AmountUnit(MeasurementUnit): ...</p> <p>generic_molal_volume_dimension = (LengthUnit**3) / AmountUnit assert type(generic_molal_volume_dimension) == GenericCompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass GenericCompositeDimension:\n    \"\"\"\n    A `GenericCompositeDimension` represents a generic measurement unit that is composed\n    from other generic measurement units.\n\n    Objects of this class can represent either multiplication or division between two\n    `GenericDimension` objects.\n\n    Create objects by multiplying and diving GenericDimension or MeasurementUnitMeta\n    class objects:\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class AmountUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; generic_molal_volume_dimension = (LengthUnit**3) / AmountUnit\n    &gt;&gt;&gt; assert type(generic_molal_volume_dimension) == GenericCompositeDimension\n    \"\"\"\n\n    numerator: List[GenericDimension] = field(default_factory=list)\n    denominator: List[GenericDimension] = field(default_factory=list)\n\n    def to_si(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a CompositeDimension with SI units.\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n        ...     @classmethod\n        ...     def si(cls): return cls.KELVIN\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     SECOND = \"s\"\n        ...     @classmethod\n        ...     def si(cls): return cls.SECOND\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n        ...     @classmethod\n        ...     def si(cls): return cls.METER\n        &gt;&gt;&gt; assert type((TemperatureUnit * LengthUnit / TimeUnit).to_si()) == CompositeDimension\n        \"\"\"\n        return CompositeDimension(\n            [n.to_si() for n in self.numerator], [d.to_si() for d in self.denominator]\n        )\n\n    def simplify(self) -&gt; None:\n        \"\"\"\n        Simplify the composite by merging common dimensions.\n\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit / TimeUnit\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n        &gt;&gt;&gt; composite.simplify()\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n        \"\"\"\n        exponents: Dict[MeasurementUnitType, float] = {}\n        for n in self.numerator:\n            if n.unit_type in exponents:\n                exponents[n.unit_type] += n.power\n            else:\n                exponents[n.unit_type] = n.power\n\n        for d in self.denominator:\n            if d.unit_type in exponents:\n                exponents[d.unit_type] -= d.power\n            else:\n                exponents[d.unit_type] = 0 - d.power\n\n        numerator = []\n        denominator = []\n        for unit_type, exponent in exponents.items():\n            if exponent &gt; 0:\n                numerator.append(GenericDimension(unit_type) ** exponent)\n            elif exponent &lt; 0:\n                denominator.append(GenericDimension(unit_type) ** abs(exponent))\n\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def simplified(self) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Returns a simplified version of this composite generic as a new object.\n\n        &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n        &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit /TimeUnit\n        &gt;&gt;&gt; composite\n        &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n        &gt;&gt;&gt; composite.simplified()\n        &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n        \"\"\"\n        copy = replace(self)\n        copy.simplify()\n        return copy\n\n    def inverse_generic(self):\n        \"\"\"\n        Create a generic composite with inverse units.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; (LengthUnit / TimeUnit).inverse_generic()\n        &lt;GenericCompositeDimension: TimeUnit / LengthUnit&gt;\n        \"\"\"\n        return GenericCompositeDimension(\n            self._denominator_copy(), self._numerator_copy()\n        )\n\n    def _numerator_copy(self) -&gt; List[GenericDimension]:\n        return [replace(n) for n in self.numerator]\n\n    def _denominator_copy(self) -&gt; List[GenericDimension]:\n        return [replace(d) for d in self.denominator]\n\n    def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines multiplication between GenericCompositeDimension(s) and other generic\n        descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type((TemperatureUnit / LengthUnit) * TimeUnit) == GenericCompositeDimension\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(generic, GenericCompositeDimension):\n            numerator.extend(generic.numerator)\n            denominator.extend(generic.denominator)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n\n        if isinstance(generic, GenericDimension):\n            numerator.append(generic)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n\n        if isinstance(generic, MeasurementUnitType):\n            numerator.append(GenericDimension(generic))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n\n    def __truediv__(\n        self, generic: GenericUnitDescriptor\n    ) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines division between GenericCompositeDimension(s) and other generic\n        descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type((TemperatureUnit * LengthUnit) / TimeUnit) == GenericCompositeDimension\n        \"\"\"\n        numerator = self.numerator.copy()\n        denominator = self.denominator.copy()\n        if isinstance(generic, GenericCompositeDimension):\n            numerator.extend(generic.denominator)\n            denominator.extend(generic.numerator)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, GenericDimension):\n            denominator.append(generic)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, MeasurementUnitType):\n            denominator.append(GenericDimension(generic))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n\n    def __pow__(self, power: float) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines exponentiation for GenericCompositeDimension(s).\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n        &gt;&gt;&gt; (TemperatureUnit / TimeUnit)**2\n        &lt;GenericCompositeDimension: (TemperatureUnit^2) / (TimeUnit^2)&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        numerator = [n**power for n in self._numerator_copy()]\n        denominator = [d**power for d in self._denominator_copy()]\n        return GenericCompositeDimension(numerator, denominator)\n\n    def __eq__(self, generic) -&gt; bool:\n        \"\"\"\n        Defines equality for GenericCompositeDimension(s).\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert (TemperatureUnit / TimeUnit) != (TimeUnit / TemperatureUnit)\n        \"\"\"\n        if not isinstance(generic, GenericCompositeDimension):\n            return False\n        return Counter(self.numerator) == Counter(generic.numerator) and (\n            Counter(self.denominator) == Counter(generic.denominator)\n        )\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __str__(self) -&gt; str:\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return numerators + denominators\n\n    def __repr__(self) -&gt; str:\n        numerators = \" * \".join(sorted([str(n) for n in self.numerator]))\n        denominators = \" / \".join(sorted([str(d) for d in self.denominator]))\n        if len(denominators) &gt; 0:\n            denominators = \" / \" + denominators\n        return f\"&lt;GenericCompositeDimension: {numerators + denominators}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__eq__","title":"<code>__eq__(generic)</code>","text":"<p>Defines equality for GenericCompositeDimension(s).</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ... assert (TemperatureUnit / TimeUnit) != (TimeUnit / TemperatureUnit)</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, generic) -&gt; bool:\n    \"\"\"\n    Defines equality for GenericCompositeDimension(s).\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert (TemperatureUnit / TimeUnit) != (TimeUnit / TemperatureUnit)\n    \"\"\"\n    if not isinstance(generic, GenericCompositeDimension):\n        return False\n    return Counter(self.numerator) == Counter(generic.numerator) and (\n        Counter(self.denominator) == Counter(generic.denominator)\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__mul__","title":"<code>__mul__(generic)</code>","text":"<p>Defines multiplication between GenericCompositeDimension(s) and other generic descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ... class LengthUnit(MeasurementUnit): ... assert type((TemperatureUnit / LengthUnit) * TimeUnit) == GenericCompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines multiplication between GenericCompositeDimension(s) and other generic\n    descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type((TemperatureUnit / LengthUnit) * TimeUnit) == GenericCompositeDimension\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(generic, GenericCompositeDimension):\n        numerator.extend(generic.numerator)\n        denominator.extend(generic.denominator)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n\n    if isinstance(generic, GenericDimension):\n        numerator.append(generic)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n\n    if isinstance(generic, MeasurementUnitType):\n        numerator.append(GenericDimension(generic))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for GenericCompositeDimension(s).</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ...</p> <p>(TemperatureUnit / TimeUnit)**2  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines exponentiation for GenericCompositeDimension(s).\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; (TemperatureUnit / TimeUnit)**2\n    &lt;GenericCompositeDimension: (TemperatureUnit^2) / (TimeUnit^2)&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    numerator = [n**power for n in self._numerator_copy()]\n    denominator = [d**power for d in self._denominator_copy()]\n    return GenericCompositeDimension(numerator, denominator)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.__truediv__","title":"<code>__truediv__(generic)</code>","text":"<p>Defines division between GenericCompositeDimension(s) and other generic descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ... class LengthUnit(MeasurementUnit): ... assert type((TemperatureUnit * LengthUnit) / TimeUnit) == GenericCompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(\n    self, generic: GenericUnitDescriptor\n) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines division between GenericCompositeDimension(s) and other generic\n    descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type((TemperatureUnit * LengthUnit) / TimeUnit) == GenericCompositeDimension\n    \"\"\"\n    numerator = self.numerator.copy()\n    denominator = self.denominator.copy()\n    if isinstance(generic, GenericCompositeDimension):\n        numerator.extend(generic.denominator)\n        denominator.extend(generic.numerator)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, GenericDimension):\n        denominator.append(generic)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, MeasurementUnitType):\n        denominator.append(GenericDimension(generic))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> <p>class LengthUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ...</p> <p>(LengthUnit / TimeUnit).inverse_generic()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(self):\n    \"\"\"\n    Create a generic composite with inverse units.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; (LengthUnit / TimeUnit).inverse_generic()\n    &lt;GenericCompositeDimension: TimeUnit / LengthUnit&gt;\n    \"\"\"\n    return GenericCompositeDimension(\n        self._denominator_copy(), self._numerator_copy()\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.simplified","title":"<code>simplified()</code>","text":"<p>Returns a simplified version of this composite generic as a new object.</p> <p>class PressureUnit(AliasMeasurementUnit): ...</p> <p>class TemperatureUnit(MeasurementUnit): ...</p> <p>class LengthUnit(MeasurementUnit): ...</p> <p>class TimeUnit(MeasurementUnit): ...</p> <p>composite = (PressureUnit(-2)) / (TemperatureUnit(-1)) composite  composite.simplified()  <p>composite = PressureUnit * LengthUnit * PressureUnit /TimeUnit composite  composite.simplified()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplified(self) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Returns a simplified version of this composite generic as a new object.\n\n    &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n    &gt;&gt;&gt; composite\n    &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n    &gt;&gt;&gt; composite.simplified()\n    &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n    &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit /TimeUnit\n    &gt;&gt;&gt; composite\n    &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n    &gt;&gt;&gt; composite.simplified()\n    &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n    \"\"\"\n    copy = replace(self)\n    copy.simplify()\n    return copy\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.simplify","title":"<code>simplify()</code>","text":"<p>Simplify the composite by merging common dimensions.</p> <p>class PressureUnit(AliasMeasurementUnit): ...</p> <p>class TemperatureUnit(MeasurementUnit): ...</p> <p>class LengthUnit(MeasurementUnit): ...</p> <p>class TimeUnit(MeasurementUnit): ...</p> <p>composite = (PressureUnit(-2)) / (TemperatureUnit(-1)) composite  composite.simplify() composite  <p>composite = PressureUnit * LengthUnit * PressureUnit / TimeUnit composite  composite.simplify() composite  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def simplify(self) -&gt; None:\n    \"\"\"\n    Simplify the composite by merging common dimensions.\n\n    &gt;&gt;&gt; class PressureUnit(AliasMeasurementUnit): ...\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n\n    &gt;&gt;&gt; composite = (PressureUnit**(-2)) / (TemperatureUnit**(-1))\n    &gt;&gt;&gt; composite\n    &lt;GenericCompositeDimension: (PressureUnit^-2) / (TemperatureUnit^-1)&gt;\n    &gt;&gt;&gt; composite.simplify()\n    &gt;&gt;&gt; composite\n    &lt;GenericCompositeDimension: TemperatureUnit / (PressureUnit^2)&gt;\n\n    &gt;&gt;&gt; composite = PressureUnit * LengthUnit * PressureUnit / TimeUnit\n    &gt;&gt;&gt; composite\n    &lt;GenericCompositeDimension: LengthUnit * PressureUnit * PressureUnit / TimeUnit&gt;\n    &gt;&gt;&gt; composite.simplify()\n    &gt;&gt;&gt; composite\n    &lt;GenericCompositeDimension: (PressureUnit^2) * LengthUnit / TimeUnit&gt;\n    \"\"\"\n    exponents: Dict[MeasurementUnitType, float] = {}\n    for n in self.numerator:\n        if n.unit_type in exponents:\n            exponents[n.unit_type] += n.power\n        else:\n            exponents[n.unit_type] = n.power\n\n    for d in self.denominator:\n        if d.unit_type in exponents:\n            exponents[d.unit_type] -= d.power\n        else:\n            exponents[d.unit_type] = 0 - d.power\n\n    numerator = []\n    denominator = []\n    for unit_type, exponent in exponents.items():\n        if exponent &gt; 0:\n            numerator.append(GenericDimension(unit_type) ** exponent)\n        elif exponent &lt; 0:\n            denominator.append(GenericDimension(unit_type) ** abs(exponent))\n\n    self.numerator = numerator\n    self.denominator = denominator\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericCompositeDimension.to_si","title":"<code>to_si()</code>","text":"<p>Create a CompositeDimension with SI units.</p> <p>class TemperatureUnit(MeasurementUnit): ...     KELVIN = \"K\" ...     @classmethod ...     def si(cls): return cls.KELVIN class TimeUnit(MeasurementUnit): ...     SECOND = \"s\" ...     @classmethod ...     def si(cls): return cls.SECOND class LengthUnit(MeasurementUnit): ...     METER = \"m\" ...     @classmethod ...     def si(cls): return cls.METER assert type((TemperatureUnit * LengthUnit / TimeUnit).to_si()) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a CompositeDimension with SI units.\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     KELVIN = \"K\"\n    ...     @classmethod\n    ...     def si(cls): return cls.KELVIN\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     SECOND = \"s\"\n    ...     @classmethod\n    ...     def si(cls): return cls.SECOND\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n    ...     @classmethod\n    ...     def si(cls): return cls.METER\n    &gt;&gt;&gt; assert type((TemperatureUnit * LengthUnit / TimeUnit).to_si()) == CompositeDimension\n    \"\"\"\n    return CompositeDimension(\n        [n.to_si() for n in self.numerator], [d.to_si() for d in self.denominator]\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension","title":"<code>GenericDimension</code>  <code>dataclass</code>","text":"<p>Represents a generic property unit or a generic property unit to some power.</p> <p>e.g. a generic dimension can be a temperature dimension or a volume dimension (length dimension to the 3rd power).</p> <p>class MassUnit(MeasurementUnit): ... assert type(MassUnit**2) == GenericDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@dataclass\nclass GenericDimension:\n    \"\"\"\n    Represents a generic property unit or a generic property unit to some power.\n\n    e.g. a generic dimension can be a temperature dimension or a volume dimension\n    (length dimension to the 3rd power).\n\n    &gt;&gt;&gt; class MassUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type(MassUnit**2) == GenericDimension\n    \"\"\"\n\n    unit_type: MeasurementUnitType\n    power: float = 1\n\n    def __init__(self, unit_type: MeasurementUnitType, power: float = 1) -&gt; None:\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.unit_type = unit_type\n        self.power = power\n\n    def to_si(self) -&gt; \"Dimension\":\n        \"\"\"\n        Create a Dimension with SI units.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        ...     KELVIN = \"K\"\n        ...     @classmethod\n        ...     def si(cls): return cls.KELVIN\n        &gt;&gt;&gt; assert type((TemperatureUnit**2).to_si()) == Dimension\n        \"\"\"\n        return Dimension(self.unit_type.to_si(), self.power)\n\n    def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Create a generic composite with inverse units.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; (LengthUnit**2).inverse_generic()\n        &lt;GenericCompositeDimension:  / (LengthUnit^2)&gt;\n        \"\"\"\n        return GenericCompositeDimension([], [replace(self)])\n\n    def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines multiplication between GenericDimension(s) and other generic\n        descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type((TemperatureUnit**2) * TimeUnit) == GenericCompositeDimension\n        \"\"\"\n        if isinstance(generic, GenericCompositeDimension):\n            numerator = generic.numerator.copy()\n            denominator = generic.denominator.copy()\n            numerator.append(self)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, GenericDimension):\n            return GenericCompositeDimension(numerator=[self, generic])\n        if isinstance(generic, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[self, GenericDimension(generic)]\n            )\n        raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n\n    def __truediv__(\n        self, generic: GenericUnitDescriptor\n    ) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines division between GenericDimension(s) and other generic descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type(TemperatureUnit / (TimeUnit**2)) == GenericCompositeDimension\n        \"\"\"\n        if isinstance(generic, GenericCompositeDimension):\n            numerator = generic.denominator.copy()\n            denominator = generic.numerator.copy()\n            numerator.append(self)\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(generic, GenericDimension):\n            return GenericCompositeDimension(numerator=[self], denominator=[generic])\n        if isinstance(generic, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[self], denominator=[GenericDimension(generic)]\n            )\n        raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n\n    def __pow__(self, power: float) -&gt; \"GenericDimension\":\n        \"\"\"\n        Defines exponentiation of GenericDimension.\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type((TimeUnit**2)**3) == GenericDimension\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise DescriptorExponentError(\n                f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n                \" expected float or int. \"\n            )\n        self.power *= power\n        return self\n\n    def __eq__(self, generic) -&gt; bool:\n        \"\"\"\n        Defines equality for GenericDimension(s).\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert (TemperatureUnit**2) != TemperatureUnit\n        \"\"\"\n        if not isinstance(generic, GenericDimension):\n            return False\n        return self.unit_type == generic.unit_type and self.power == generic.power\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __str__(self) -&gt; str:\n        s = self.unit_type.__name__\n        if self.power != 1:\n            return f\"({s}^{self.power})\"\n        return s\n\n    def __repr__(self) -&gt; str:\n        if self.power != 1:\n            return f\"&lt;GenericDimension: {self.unit_type.__name__}^{self.power}&gt;\"\n        return f\"&lt;GenericDimension: {self.unit_type.__name__}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__eq__","title":"<code>__eq__(generic)</code>","text":"<p>Defines equality for GenericDimension(s).</p> <p>class TemperatureUnit(MeasurementUnit): ... assert (TemperatureUnit**2) != TemperatureUnit</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __eq__(self, generic) -&gt; bool:\n    \"\"\"\n    Defines equality for GenericDimension(s).\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert (TemperatureUnit**2) != TemperatureUnit\n    \"\"\"\n    if not isinstance(generic, GenericDimension):\n        return False\n    return self.unit_type == generic.unit_type and self.power == generic.power\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__mul__","title":"<code>__mul__(generic)</code>","text":"<p>Defines multiplication between GenericDimension(s) and other generic descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ... assert type((TemperatureUnit**2) * TimeUnit) == GenericCompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, generic: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines multiplication between GenericDimension(s) and other generic\n    descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type((TemperatureUnit**2) * TimeUnit) == GenericCompositeDimension\n    \"\"\"\n    if isinstance(generic, GenericCompositeDimension):\n        numerator = generic.numerator.copy()\n        denominator = generic.denominator.copy()\n        numerator.append(self)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, GenericDimension):\n        return GenericCompositeDimension(numerator=[self, generic])\n    if isinstance(generic, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[self, GenericDimension(generic)]\n        )\n    raise DescriptorBinaryOperationError(f\"cannot multiply {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation of GenericDimension.</p> <p>class TimeUnit(MeasurementUnit): ... assert type((TimeUnit2)3) == GenericDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"GenericDimension\":\n    \"\"\"\n    Defines exponentiation of GenericDimension.\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type((TimeUnit**2)**3) == GenericDimension\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise DescriptorExponentError(\n            f\"invalid exponent: {{ value: {power}, type: {type(power)} }};\"\n            \" expected float or int. \"\n        )\n    self.power *= power\n    return self\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.__truediv__","title":"<code>__truediv__(generic)</code>","text":"<p>Defines division between GenericDimension(s) and other generic descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ... assert type(TemperatureUnit / (TimeUnit**2)) == GenericCompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(\n    self, generic: GenericUnitDescriptor\n) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines division between GenericDimension(s) and other generic descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type(TemperatureUnit / (TimeUnit**2)) == GenericCompositeDimension\n    \"\"\"\n    if isinstance(generic, GenericCompositeDimension):\n        numerator = generic.denominator.copy()\n        denominator = generic.numerator.copy()\n        numerator.append(self)\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(generic, GenericDimension):\n        return GenericCompositeDimension(numerator=[self], denominator=[generic])\n    if isinstance(generic, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[self], denominator=[GenericDimension(generic)]\n        )\n    raise DescriptorBinaryOperationError(f\"cannot divide {self} with {generic}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> <p>class LengthUnit(MeasurementUnit): ... (LengthUnit**2).inverse_generic()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Create a generic composite with inverse units.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; (LengthUnit**2).inverse_generic()\n    &lt;GenericCompositeDimension:  / (LengthUnit^2)&gt;\n    \"\"\"\n    return GenericCompositeDimension([], [replace(self)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericDimension.to_si","title":"<code>to_si()</code>","text":"<p>Create a Dimension with SI units.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" ...     KELVIN = \"K\" ...     @classmethod ...     def si(cls): return cls.KELVIN assert type((TemperatureUnit**2).to_si()) == Dimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(self) -&gt; \"Dimension\":\n    \"\"\"\n    Create a Dimension with SI units.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    ...     KELVIN = \"K\"\n    ...     @classmethod\n    ...     def si(cls): return cls.KELVIN\n    &gt;&gt;&gt; assert type((TemperatureUnit**2).to_si()) == Dimension\n    \"\"\"\n    return Dimension(self.unit_type.to_si(), self.power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericUnitDescriptor","title":"<code>GenericUnitDescriptor</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Descriptor for a property unit that does not have a specific unit.</p> <p>e.g. a  generic descriptor can represent a Temperature unit that does not have a specific value like Celcius or Fahrenheit.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class GenericUnitDescriptor(Protocol):\n    \"\"\"\n    Descriptor for a property unit that does not have a specific unit.\n\n    e.g. a  generic descriptor can represent a Temperature unit that does not have a\n    specific value like Celcius or Fahrenheit.\n    \"\"\"\n\n    def to_si(self) -&gt; \"UnitDescriptor\":\n        \"\"\"\n        Create a unit descriptor with SI units.\n        \"\"\"\n\n    def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Create a generic composite with inverse units.\n        \"\"\"\n\n    def __mul__(\n        self, generic: \"GenericUnitDescriptor\"\n    ) -&gt; \"GenericCompositeDimension\": ...\n\n    def __truediv__(\n        self, generic: \"GenericUnitDescriptor\"\n    ) -&gt; \"GenericCompositeDimension\": ...\n\n    def __pow__(self, power: float) -&gt; \"GenericUnitDescriptor\": ...\n\n    def __eq__(self, generic) -&gt; bool: ...\n\n    def __hash__(self) -&gt; int: ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericUnitDescriptor.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(self) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Create a generic composite with inverse units.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.GenericUnitDescriptor.to_si","title":"<code>to_si()</code>","text":"<p>Create a unit descriptor with SI units.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(self) -&gt; \"UnitDescriptor\":\n    \"\"\"\n    Create a unit descriptor with SI units.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit","title":"<code>MeasurementUnit</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Base class for all measurement units of physical quantities.</p> <p>Each measurement-unit class is an enumeration of the available units for a quantity.</p> <p>Subclasses should only enumerate measurement units of primitive physical quantities, i.e. units that cannot be produced from other units. e.g. length is an acceptable quantity, but volume is not because its' units are produced from length units.</p> <pre><code>class TemperatureUnit(MeasurementUnit):\n    CELCIUS = \"C\"\n    KELVIN = \"K\"\n    RANKINE = \"R\"\n    FAHRENHEIT = \"F\"\n</code></pre> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class MeasurementUnit(Enum, metaclass=MeasurementUnitMeta):\n    \"\"\"\n    Base class for all measurement units of physical quantities.\n\n    Each measurement-unit class is an enumeration of the available units for a\n    quantity.\n\n    Subclasses should only enumerate measurement units of primitive physical\n    quantities, i.e. units that cannot be produced from other units.\n    e.g. length is an acceptable quantity, but volume is not because its' units are\n    produced from length units.\n\n    ```\n    class TemperatureUnit(MeasurementUnit):\n        CELCIUS = \"C\"\n        KELVIN = \"K\"\n        RANKINE = \"R\"\n        FAHRENHEIT = \"F\"\n    ```\n    \"\"\"\n\n    @classmethod\n    def si(cls) -&gt; \"MeasurementUnit\":\n        \"\"\"\n        Returns the SI unit of this measurement unit.\n        \"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def from_descriptor(descriptor: UnitDescriptor) -&gt; \"MeasurementUnit\":\n        \"\"\"\n        Create a MeasurementUnit from given descriptor.\n        If descriptor is already a MeasurementUnit, it returns the same object.\n\n        This function does not serve as a constructor for MeasurementUnit, rather it\n        is intended to be used to convert an unknown unit descriptor to a\n        MeasurementUnit.\n\n        Raises UnitDescriptorTypeError if given descriptor cannot be translated\n        to a MeasurementUnit instance.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; celcius = MeasurementUnit.from_descriptor(TemperatureUnit.CELCIUS**2)\n        &gt;&gt;&gt; assert celcius == TemperatureUnit.CELCIUS\n        \"\"\"\n        if isinstance(descriptor, Dimension):\n            return descriptor.unit\n        if isinstance(descriptor, MeasurementUnit):\n            return descriptor\n        raise UnitDescriptorTypeError(\n            f\"cannot create MeasurementUnit from descriptor: {descriptor}\"\n        )\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the MeasurementUnit is an instance of the generic, False\n        otherwise.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     METER = \"m\"\n\n        &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(TemperatureUnit)\n        True\n\n        &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(LengthUnit)\n        False\n        \"\"\"\n        return type(self) == generic  # pylint: disable=unidiomatic-typecheck\n\n    def to_generic(self) -&gt; GenericUnitDescriptor:\n        \"\"\"\n        Create a generic descriptor from this MeasurementUnit.\n\n        &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n        ...     MOL = \"mol\"\n\n        &gt;&gt;&gt; AmountUnit.MOL.to_generic()\n        &lt;MeasurementUnit: AmountUnit&gt;\n        \"\"\"\n        return self.__class__\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     KELVIN = \"K\"\n        &gt;&gt;&gt; TemperatureUnit.KELVIN.inverse()\n        &lt;CompositeDimension:  / K&gt;\n        \"\"\"\n        return CompositeDimension([], [Dimension(self)])\n\n    def __mul__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines multiplication between MeasurementUnit objects and other unit descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     FAHRENHEIT = \"F\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n        &gt;&gt;&gt; assert type(TemperatureUnit.FAHRENHEIT * TimeUnit.HOUR) == CompositeDimension\n        \"\"\"\n        if isinstance(descriptor, MeasurementUnit):\n            return Dimension(self) * Dimension(descriptor)\n        if isinstance(descriptor, (Dimension, CompositeDimension)):\n            return Dimension(self) * descriptor\n        raise DescriptorBinaryOperationError(\n            f\"cannot multiply {self} with {descriptor}. \"\n        )\n\n    def __truediv__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Defines division between MeasurementUnit objects and other unit descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     FAHRENHEIT = \"F\"\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n        ...     HOUR = \"hr\"\n        &gt;&gt;&gt; assert type(TemperatureUnit.FAHRENHEIT / TimeUnit.HOUR) == CompositeDimension\n        \"\"\"\n        if isinstance(descriptor, MeasurementUnit):\n            return Dimension(self) / Dimension(descriptor)\n        if isinstance(descriptor, (Dimension, CompositeDimension)):\n            return Dimension(self) / descriptor\n        raise DescriptorBinaryOperationError(\n            f\"cannot divide {self} with {descriptor}. \"\n        )\n\n    def __pow__(self, power: float) -&gt; \"Dimension\":\n        \"\"\"\n        Defines exponentiation of MeasurementUnit objects.\n\n        &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n        ...     FEET = \"ft\"\n        &gt;&gt;&gt; assert type(LengthUnit.FEET**3) == Dimension\n        \"\"\"\n        return Dimension(self, power)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.value)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}: {str(self)}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.__mul__","title":"<code>__mul__(descriptor)</code>","text":"<p>Defines multiplication between MeasurementUnit objects and other unit descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ...     FAHRENHEIT = \"F\" class TimeUnit(MeasurementUnit): ...     HOUR = \"hr\" assert type(TemperatureUnit.FAHRENHEIT * TimeUnit.HOUR) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines multiplication between MeasurementUnit objects and other unit descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     FAHRENHEIT = \"F\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     HOUR = \"hr\"\n    &gt;&gt;&gt; assert type(TemperatureUnit.FAHRENHEIT * TimeUnit.HOUR) == CompositeDimension\n    \"\"\"\n    if isinstance(descriptor, MeasurementUnit):\n        return Dimension(self) * Dimension(descriptor)\n    if isinstance(descriptor, (Dimension, CompositeDimension)):\n        return Dimension(self) * descriptor\n    raise DescriptorBinaryOperationError(\n        f\"cannot multiply {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation of MeasurementUnit objects.</p> <p>class LengthUnit(MeasurementUnit): ...     FEET = \"ft\" assert type(LengthUnit.FEET**3) == Dimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(self, power: float) -&gt; \"Dimension\":\n    \"\"\"\n    Defines exponentiation of MeasurementUnit objects.\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     FEET = \"ft\"\n    &gt;&gt;&gt; assert type(LengthUnit.FEET**3) == Dimension\n    \"\"\"\n    return Dimension(self, power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.__truediv__","title":"<code>__truediv__(descriptor)</code>","text":"<p>Defines division between MeasurementUnit objects and other unit descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ...     FAHRENHEIT = \"F\" class TimeUnit(MeasurementUnit): ...     HOUR = \"hr\" assert type(TemperatureUnit.FAHRENHEIT / TimeUnit.HOUR) == CompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(self, descriptor: UnitDescriptor) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Defines division between MeasurementUnit objects and other unit descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     FAHRENHEIT = \"F\"\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit):\n    ...     HOUR = \"hr\"\n    &gt;&gt;&gt; assert type(TemperatureUnit.FAHRENHEIT / TimeUnit.HOUR) == CompositeDimension\n    \"\"\"\n    if isinstance(descriptor, MeasurementUnit):\n        return Dimension(self) / Dimension(descriptor)\n    if isinstance(descriptor, (Dimension, CompositeDimension)):\n        return Dimension(self) / descriptor\n    raise DescriptorBinaryOperationError(\n        f\"cannot divide {self} with {descriptor}. \"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.from_descriptor","title":"<code>from_descriptor(descriptor)</code>  <code>staticmethod</code>","text":"<p>Create a MeasurementUnit from given descriptor. If descriptor is already a MeasurementUnit, it returns the same object.</p> <p>This function does not serve as a constructor for MeasurementUnit, rather it is intended to be used to convert an unknown unit descriptor to a MeasurementUnit.</p> <p>Raises UnitDescriptorTypeError if given descriptor cannot be translated to a MeasurementUnit instance.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\"</p> <p>celcius = MeasurementUnit.from_descriptor(TemperatureUnit.CELCIUS**2) assert celcius == TemperatureUnit.CELCIUS</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@staticmethod\ndef from_descriptor(descriptor: UnitDescriptor) -&gt; \"MeasurementUnit\":\n    \"\"\"\n    Create a MeasurementUnit from given descriptor.\n    If descriptor is already a MeasurementUnit, it returns the same object.\n\n    This function does not serve as a constructor for MeasurementUnit, rather it\n    is intended to be used to convert an unknown unit descriptor to a\n    MeasurementUnit.\n\n    Raises UnitDescriptorTypeError if given descriptor cannot be translated\n    to a MeasurementUnit instance.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n\n    &gt;&gt;&gt; celcius = MeasurementUnit.from_descriptor(TemperatureUnit.CELCIUS**2)\n    &gt;&gt;&gt; assert celcius == TemperatureUnit.CELCIUS\n    \"\"\"\n    if isinstance(descriptor, Dimension):\n        return descriptor.unit\n    if isinstance(descriptor, MeasurementUnit):\n        return descriptor\n    raise UnitDescriptorTypeError(\n        f\"cannot create MeasurementUnit from descriptor: {descriptor}\"\n    )\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> <p>class TemperatureUnit(MeasurementUnit): ...     KELVIN = \"K\" TemperatureUnit.KELVIN.inverse()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     KELVIN = \"K\"\n    &gt;&gt;&gt; TemperatureUnit.KELVIN.inverse()\n    &lt;CompositeDimension:  / K&gt;\n    \"\"\"\n    return CompositeDimension([], [Dimension(self)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the MeasurementUnit is an instance of the generic, False otherwise.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\"</p> <p>class LengthUnit(MeasurementUnit): ...     METER = \"m\"</p> <p>TemperatureUnit.CELCIUS.isinstance(TemperatureUnit) True</p> <p>TemperatureUnit.CELCIUS.isinstance(LengthUnit) False</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the MeasurementUnit is an instance of the generic, False\n    otherwise.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n\n    &gt;&gt;&gt; class LengthUnit(MeasurementUnit):\n    ...     METER = \"m\"\n\n    &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(TemperatureUnit)\n    True\n\n    &gt;&gt;&gt; TemperatureUnit.CELCIUS.isinstance(LengthUnit)\n    False\n    \"\"\"\n    return type(self) == generic  # pylint: disable=unidiomatic-typecheck\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.si","title":"<code>si()</code>  <code>classmethod</code>","text":"<p>Returns the SI unit of this measurement unit.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>@classmethod\ndef si(cls) -&gt; \"MeasurementUnit\":\n    \"\"\"\n    Returns the SI unit of this measurement unit.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnit.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this MeasurementUnit.</p> <p>class AmountUnit(MeasurementUnit): ...     MOL = \"mol\"</p> <p>AmountUnit.MOL.to_generic()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericUnitDescriptor:\n    \"\"\"\n    Create a generic descriptor from this MeasurementUnit.\n\n    &gt;&gt;&gt; class AmountUnit(MeasurementUnit):\n    ...     MOL = \"mol\"\n\n    &gt;&gt;&gt; AmountUnit.MOL.to_generic()\n    &lt;MeasurementUnit: AmountUnit&gt;\n    \"\"\"\n    return self.__class__\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta","title":"<code>MeasurementUnitMeta</code>","text":"<p>             Bases: <code>EnumMeta</code></p> <p>Metaclass for MeasurementUnit. Defines multiplication, division and exponent operations for MeasurementUnit class (and subclasses). These operations produce GenericUnitDescriptor(s).</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class MeasurementUnitMeta(EnumMeta):\n    \"\"\"\n    Metaclass for MeasurementUnit. Defines multiplication, division and exponent\n    operations for MeasurementUnit class (and subclasses). These operations produce\n    GenericUnitDescriptor(s).\n    \"\"\"\n\n    def to_si(cls) -&gt; \"MeasurementUnit\":\n        \"\"\"\n        Create a MeasurementUnit with SI units.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n        ...     CELCIUS = \"C\"\n        ...     KELVIN = \"K\"\n        ...     @classmethod\n        ...     def si(cls):\n        ...         return cls.KELVIN\n        &gt;&gt;&gt; assert TemperatureUnit.to_si() == TemperatureUnit.KELVIN\n        \"\"\"\n        if hasattr(cls, \"si\"):\n            return cls.si()\n        raise NotImplementedError\n\n    def inverse_generic(cls) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Create a generic composite with inverse units.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; TemperatureUnit.inverse_generic()\n        &lt;GenericCompositeDimension:  / TemperatureUnit&gt;\n        \"\"\"\n        return GenericCompositeDimension([], [GenericDimension(cls)])\n\n    def __mul__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines multiplication between MeasurementUnit types and other generic\n        descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type(TemperatureUnit * TimeUnit) == GenericCompositeDimension\n        \"\"\"\n        if isinstance(other, GenericCompositeDimension):\n            numerator = other.numerator.copy()\n            denominator = other.denominator.copy()\n            numerator.append(GenericDimension(cls))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(other, GenericDimension):\n            return GenericCompositeDimension(numerator=[GenericDimension(cls), other])\n        if isinstance(other, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[\n                    GenericDimension(cls),\n                    GenericDimension(other),\n                ]\n            )\n        raise DescriptorBinaryOperationError(f\"cannot multiply {cls} with {other}. \")\n\n    def __truediv__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n        \"\"\"\n        Defines division between MeasurementUnit types and other generic\n        descriptors.\n\n        &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type(TemperatureUnit / TimeUnit) == GenericCompositeDimension\n        \"\"\"\n        if isinstance(other, GenericCompositeDimension):\n            numerator = other.denominator.copy()\n            denominator = other.numerator.copy()\n            numerator.append(GenericDimension(cls))\n            return GenericCompositeDimension(\n                numerator=numerator, denominator=denominator\n            )\n        if isinstance(other, GenericDimension):\n            return GenericCompositeDimension(\n                numerator=[GenericDimension(cls)], denominator=[other]\n            )\n        if isinstance(other, MeasurementUnitType):\n            return GenericCompositeDimension(\n                numerator=[GenericDimension(cls)],\n                denominator=[GenericDimension(other)],\n            )\n        raise DescriptorBinaryOperationError(f\"cannot divide {cls} with {other}. \")\n\n    def __pow__(cls, power: float) -&gt; \"GenericDimension\":\n        \"\"\"\n        Defines exponentiation of MeasurementUnit types.\n\n        &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n        &gt;&gt;&gt; assert type(TimeUnit**3) == GenericDimension\n        \"\"\"\n        return GenericDimension(cls, power)\n\n    def __str__(cls) -&gt; str:\n        return cls.__name__\n\n    def __repr__(cls) -&gt; str:\n        return f\"&lt;MeasurementUnit: {str(cls)}&gt;\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Defines multiplication between MeasurementUnit types and other generic descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ... assert type(TemperatureUnit * TimeUnit) == GenericCompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __mul__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines multiplication between MeasurementUnit types and other generic\n    descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type(TemperatureUnit * TimeUnit) == GenericCompositeDimension\n    \"\"\"\n    if isinstance(other, GenericCompositeDimension):\n        numerator = other.numerator.copy()\n        denominator = other.denominator.copy()\n        numerator.append(GenericDimension(cls))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(other, GenericDimension):\n        return GenericCompositeDimension(numerator=[GenericDimension(cls), other])\n    if isinstance(other, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[\n                GenericDimension(cls),\n                GenericDimension(other),\n            ]\n        )\n    raise DescriptorBinaryOperationError(f\"cannot multiply {cls} with {other}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation of MeasurementUnit types.</p> <p>class TimeUnit(MeasurementUnit): ... assert type(TimeUnit**3) == GenericDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __pow__(cls, power: float) -&gt; \"GenericDimension\":\n    \"\"\"\n    Defines exponentiation of MeasurementUnit types.\n\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type(TimeUnit**3) == GenericDimension\n    \"\"\"\n    return GenericDimension(cls, power)\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Defines division between MeasurementUnit types and other generic descriptors.</p> <p>class TemperatureUnit(MeasurementUnit): ... class TimeUnit(MeasurementUnit): ... assert type(TemperatureUnit / TimeUnit) == GenericCompositeDimension</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def __truediv__(cls, other: GenericUnitDescriptor) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Defines division between MeasurementUnit types and other generic\n    descriptors.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; class TimeUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; assert type(TemperatureUnit / TimeUnit) == GenericCompositeDimension\n    \"\"\"\n    if isinstance(other, GenericCompositeDimension):\n        numerator = other.denominator.copy()\n        denominator = other.numerator.copy()\n        numerator.append(GenericDimension(cls))\n        return GenericCompositeDimension(\n            numerator=numerator, denominator=denominator\n        )\n    if isinstance(other, GenericDimension):\n        return GenericCompositeDimension(\n            numerator=[GenericDimension(cls)], denominator=[other]\n        )\n    if isinstance(other, MeasurementUnitType):\n        return GenericCompositeDimension(\n            numerator=[GenericDimension(cls)],\n            denominator=[GenericDimension(other)],\n        )\n    raise DescriptorBinaryOperationError(f\"cannot divide {cls} with {other}. \")\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.inverse_generic","title":"<code>inverse_generic()</code>","text":"<p>Create a generic composite with inverse units.</p> <p>class TemperatureUnit(MeasurementUnit): ... TemperatureUnit.inverse_generic()  Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse_generic(cls) -&gt; \"GenericCompositeDimension\":\n    \"\"\"\n    Create a generic composite with inverse units.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit): ...\n    &gt;&gt;&gt; TemperatureUnit.inverse_generic()\n    &lt;GenericCompositeDimension:  / TemperatureUnit&gt;\n    \"\"\"\n    return GenericCompositeDimension([], [GenericDimension(cls)])\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.MeasurementUnitMeta.to_si","title":"<code>to_si()</code>","text":"<p>Create a MeasurementUnit with SI units.</p> <p>class TemperatureUnit(MeasurementUnit): ...     CELCIUS = \"C\" ...     KELVIN = \"K\" ...     @classmethod ...     def si(cls): ...         return cls.KELVIN assert TemperatureUnit.to_si() == TemperatureUnit.KELVIN</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_si(cls) -&gt; \"MeasurementUnit\":\n    \"\"\"\n    Create a MeasurementUnit with SI units.\n\n    &gt;&gt;&gt; class TemperatureUnit(MeasurementUnit):\n    ...     CELCIUS = \"C\"\n    ...     KELVIN = \"K\"\n    ...     @classmethod\n    ...     def si(cls):\n    ...         return cls.KELVIN\n    &gt;&gt;&gt; assert TemperatureUnit.to_si() == TemperatureUnit.KELVIN\n    \"\"\"\n    if hasattr(cls, \"si\"):\n        return cls.si()\n    raise NotImplementedError\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor","title":"<code>UnitDescriptor</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Descriptor for a property unit that has a specific unit, e.g. cm^2 or ft^2.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>class UnitDescriptor(Protocol):\n    \"\"\"\n    Descriptor for a property unit that has a specific unit, e.g. cm^2 or ft^2.\n    \"\"\"\n\n    def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n        \"\"\"\n        Returns True if the UnitDescriptor is an instance of the generic, False\n        otherwise.\n        \"\"\"\n\n    def to_generic(self) -&gt; GenericUnitDescriptor:\n        \"\"\"\n        Create a generic descriptor from this UnitDescriptor.\n        \"\"\"\n\n    def inverse(self) -&gt; \"CompositeDimension\":\n        \"\"\"\n        Create a composite with inverse units.\n        \"\"\"\n\n    def __mul__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\": ...\n\n    def __truediv__(self, descriptor: \"UnitDescriptor\") -&gt; \"CompositeDimension\": ...\n\n    def __pow__(self, power: float) -&gt; \"UnitDescriptor\": ...\n\n    def __hash__(self) -&gt; int: ...\n\n    def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.inverse","title":"<code>inverse()</code>","text":"<p>Create a composite with inverse units.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def inverse(self) -&gt; \"CompositeDimension\":\n    \"\"\"\n    Create a composite with inverse units.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.isinstance","title":"<code>isinstance(generic)</code>","text":"<p>Returns True if the UnitDescriptor is an instance of the generic, False otherwise.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def isinstance(self, generic: GenericUnitDescriptor) -&gt; bool:\n    \"\"\"\n    Returns True if the UnitDescriptor is an instance of the generic, False\n    otherwise.\n    \"\"\"\n</code></pre>"},{"location":"descriptors/#property_utils.units.descriptors.UnitDescriptor.to_generic","title":"<code>to_generic()</code>","text":"<p>Create a generic descriptor from this UnitDescriptor.</p> Source code in <code>src/property_utils/units/descriptors.py</code> <pre><code>def to_generic(self) -&gt; GenericUnitDescriptor:\n    \"\"\"\n    Create a generic descriptor from this UnitDescriptor.\n    \"\"\"\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>If you've got Python &gt;= 3.8 then you're good to go!</p> <pre><code>pip install property-utils\n</code></pre>"},{"location":"property/","title":"property","text":"<p>This module defines the Property class and property arithmetics.</p>"},{"location":"property/#property_utils.properties.property.Property","title":"<code>Property</code>  <code>dataclass</code>","text":"<p>A Property describes a value with a unit of measurement.</p> <p>A Property can have any 'value' or 'unit'; validations are not applied to it. For example, a Property with length units and negative value is valid.</p> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>@dataclass\nclass Property:\n    \"\"\"\n    A Property describes a value with a unit of measurement.\n\n    A Property can have any 'value' or 'unit'; validations are not applied to it.\n    For example, a Property with length units and negative value is valid.\n    \"\"\"\n\n    value: float\n    unit: UnitDescriptor\n    unit_converter: Optional[Type[UnitConverter]] = None\n\n    def __init__(self, value: float, unit: UnitDescriptor) -&gt; None:\n        if not isinstance(value, (float, int)):\n            raise PropertyValidationError(\n                f\"cannot create Property; invalid 'value': {value}; expected numeric. \"\n            )\n        if not isinstance(unit, (MeasurementUnit, Dimension, CompositeDimension)):\n            raise PropertyValidationError(\n                f\"cannot create Property; invalid 'unit': {unit}. Expected an instance\"\n                \" of one of: MeasurementUnit, Dimension, CompositeDimension. \"\n            )\n        self.value = value\n        self.unit = unit\n\n    def eq(self, other: \"Property\", *, rel_tol=1e-9, abs_tol=0) -&gt; bool:\n        \"\"\"\n        Perform equality comparison between this and some other Property. This method\n        of testing equality is preferable to the equality operator '==' because float\n        point tolerance is taken into account.\n\n        rel_tol is the maximum difference for being considered \"close\", relative\n        to the magnitude of the input values.\n        abs_tol is the maximum difference for being considered \"close\", regardless of\n        the magnitude of the input values.\n        For the values to be considered close, the difference between them must be\n        smaller than at least one of the tolerances.\n\n        Raises `PropertyBinaryOperationError` if an error occurs during conversion\n        of other's units.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T1 = Property(33.333333, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; T2 = Property(100/3, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; T1 == T2\n            False\n            &gt;&gt;&gt; T1.eq(T2)\n            False\n            &gt;&gt;&gt; T1.eq(T2, rel_tol=0.1)\n            True\n        \"\"\"\n        if not isinstance(other, Property):\n            return False\n        if not self.unit.isinstance(other.unit.to_generic()):\n            return False\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUtilsException as exc:\n            raise PropertyBinaryOperationError(\n                f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n                exc,\n            ) from None\n        return isclose(self.value, prop.value, rel_tol=rel_tol, abs_tol=abs_tol)\n\n    def to_si(self) -&gt; Self:\n        \"\"\"\n        Create a new property with SI units.\n\n        Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n        for the unit.\n\n        Raises `InvalidUnitConversion` if any error occurs in the unit conversion.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T.to_si()\n            &lt;Property: 373.15 K&gt;\n        \"\"\"\n        if isinstance(self.unit, MeasurementUnit):\n            return self.to_unit(self.unit.si())\n        if isinstance(self.unit, Dimension):\n            return self.to_unit(self.unit.unit.si() ** self.unit.power)\n        if isinstance(self.unit, CompositeDimension):\n            return self.to_unit(self.unit.to_generic().to_si())\n        raise PropertyValidationError(\n            f\"cannot convert Property to SI; 'unit' is invalid: {self.unit}. \"\n        )\n\n    def to_unit(self, unit: UnitDescriptor) -&gt; Self:\n        \"\"\"\n        Create a new property with specified unit.\n\n        Raises `PropertyUnitConversionError` if the unit is not of the same type.\n\n        Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n        for the unit.\n\n        Raises `UnitConversionError` if any error occurs in the unit conversion.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T.to_unit(RelativeTemperatureUnit.FAHRENHEIT)\n            &lt;Property: 212.0 \u00b0F&gt;\n        \"\"\"\n        if not unit.isinstance(self.unit.to_generic()):\n            raise PropertyUnitConversionError(\n                f\"cannot convert {self} to ({unit}) units; 'unit' should be an instance\"\n                f\" of {self.unit.to_generic()}. \"\n            )\n        try:\n            converter = self._converter()\n        except UndefinedConverterError:\n            raise PropertyUnitConversionError(\n                f\"cannot convert property {self} to units: {unit}; no unit converter \"\n                f\" found for {unit.to_generic()}. \"\n                \"Did you forget to @register_converter? \"\n            ) from None\n        try:\n            value = converter.convert(self.value, self.unit, unit)\n        except UnitConversionError as exc:\n            raise exc from None\n        return self.__class__(value=value, unit=unit)\n\n    def __neg__(self) -&gt; Self:\n        \"\"\"\n        Defines negation of properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T = Property(3, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; -T\n            &lt;Property: -3 \u00b0C&gt;\n        \"\"\"\n        return self.__class__(-self.value, self.unit)\n\n    def __mul__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines multiplication between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; 2*T\n            &lt;Property: 600 K&gt;\n            &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n            &gt;&gt;&gt; T * A\n            &lt;Property: 3000 (m^2) * K&gt;\n        \"\"\"\n        if isinstance(other, (float, int)):\n            return Property(self.value * other, self.unit)\n        if isinstance(other, Property):\n            return Property(\n                self.value * other.value, (self.unit * other.unit).simplified()\n            )\n        raise PropertyBinaryOperationError(\n            f\"cannot multiply {self} with {other}; \"\n            \"second operand must be numeric or Property. \"\n        )\n\n    def __rmul__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines multiplication between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; 2*T\n            &lt;Property: 600 K&gt;\n            &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n            &gt;&gt;&gt; T * A\n            &lt;Property: 3000 (m^2) * K&gt;\n        \"\"\"\n        return self.__mul__(other)\n\n    def __truediv__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines division between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n            &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; T/2\n            &lt;Property: 250.0 K&gt;\n            &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n            &gt;&gt;&gt; T / A\n            &lt;Property: 50.0 K / (m^2)&gt;\n        \"\"\"\n        if isinstance(other, (float, int)):\n            try:\n                value = self.value / other\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator is zero. \"\n                ) from None\n            return Property(value, self.unit)\n        if isinstance(other, Property):\n            try:\n                value = self.value / other.value\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator's value is zero. \"\n                ) from None\n            return Property(value, (self.unit / other.unit).simplified())\n        raise PropertyBinaryOperationError(\n            f\"cannot divide {self} with {other}; \"\n            \"denominator must be numeric or Property. \"\n        )\n\n    def __rtruediv__(self, other) -&gt; \"Property\":\n        \"\"\"\n        Defines right division between properties and numerics.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit\n            &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n            &gt;&gt;&gt; 100/T\n            &lt;Property: 0.2  / K&gt;\n        \"\"\"\n        if isinstance(other, (float, int)):\n            try:\n                value = other / self.value\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator is zero. \"\n                ) from None\n            return Property(value, self.unit.inverse())\n        if isinstance(other, Property):\n            try:\n                value = other.value / self.value\n            except ZeroDivisionError:\n                raise PropertyBinaryOperationError(\n                    f\"cannot divide {self} with {other}; denominator's value is zero. \"\n                ) from None\n            return Property(value, (other.unit / self.unit).simplified())\n        raise PropertyBinaryOperationError(\n            f\"cannot divide {self} with {other}; \"\n            \"numerator must be numeric or Property. \"\n        )\n\n    def __add__(self, other) -&gt; Self:\n        \"\"\"\n        Defines addition between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n            &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; x1 + x2\n            &lt;Property: 20 m&gt;\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise PropertyBinaryOperationError(\n                f\"cannot add {other} to ({self}); {other} is not a {self.__class__}; \"\n                \"only same properties can be added to each other. \"\n            )\n        if not self.unit.isinstance(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot add ({other}) to ({self}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot add ({other}) to ({self}); ({other}) does not have the same \"\n                f\"units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot add ({other}) to ({self});\", exc\n            ) from None\n        return self.__class__(self.value + prop.value, self.unit)\n\n    def __radd__(self, other) -&gt; Self:\n        \"\"\"\n        Defines right addition between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n            &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; x1 + x2\n            &lt;Property: 20 m&gt;\n        \"\"\"\n        return self.__add__(other)\n\n    def __sub__(self, other) -&gt; Self:\n        \"\"\"\n        Defines subtraction between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n            &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n            &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n            &gt;&gt;&gt; t1 - t2\n            &lt;Property: 1.0 min&gt;\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract {other} from ({self}); {other} is not a \"\n                f\"{self.__class__}; only same properties can be subtracted from each \"\n                \"other. \"\n            )\n        if not self.unit.isinstance(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({other}) from ({self}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({other}) from ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({other}) from ({self});\", exc\n            ) from None\n        return self.__class__(self.value - prop.value, self.unit)\n\n    def __rsub__(self, other) -&gt; Self:\n        \"\"\"\n        Defines right subtraction between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n            &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n            &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n            &gt;&gt;&gt; t1 - t2\n            &lt;Property: 1.0 min&gt;\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract {self} from ({other}); {other} is not a \"\n                f\"{self.__class__}; only same properties can be subtracted from each \"\n                \"other. \"\n            )\n        if not self.unit.isinstance(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot subtract ({self}) from ({other}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n        return other.__add__(-self)\n\n    def __pow__(self, power) -&gt; \"Property\":\n        \"\"\"\n        Defines exponentiation for properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; L = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; L**3\n            &lt;Property: 125 (m^3)&gt;\n        \"\"\"\n        if not isinstance(power, (float, int)):\n            raise PropertyExponentError(\n                f\"invalid exponent: {power}; expected numeric. \"\n            )\n        return Property(self.value**power, self.unit**power)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Defines equality between properties.\n        Prefer Property.eq instead.The equality operator returns False even for very\n        small differences between floating point values.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n            &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; L1 == L2\n            True\n\n            &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n            &gt;&gt;&gt; L2 == L3\n            False\n        \"\"\"\n        if not isinstance(other, Property):\n            return False\n        if not self.unit.isinstance(other.unit.to_generic()):\n            return False\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUtilsException as exc:\n            raise PropertyBinaryOperationError(\n                f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n                exc,\n            ) from None\n        return self.value == prop.value\n\n    def __ne__(self, other) -&gt; bool:\n        \"\"\"\n        Defines inequality between properties.\n        Prefer Property.eq instead.The inequality operator returns True even for very\n        small differences between floating point values.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n            &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n            &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n            &gt;&gt;&gt; L1 != L2\n            False\n\n            &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n            &gt;&gt;&gt; L2 != L3\n            True\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __gt__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &gt; T2\n            False\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &gt; prop.value\n\n    def __ge__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(212, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &gt;= T2\n            True\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &gt;= prop.value\n\n    def __lt__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &lt; T2\n            True\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &lt; prop.value\n\n    def __le__(self, other) -&gt; bool:\n        \"\"\"\n        Defines comparison between properties.\n\n        Examples:\n            &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n            &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n            &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n            &gt;&gt;&gt; T1 &lt;= T2\n            True\n        \"\"\"\n        self._validate_comparison_input(other)\n        try:\n            prop = other.to_unit(self.unit) if self.unit != other.unit else other\n        except PropertyUnitConversionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n                f\"same units as ({self}) and there is no unit converter registered for \"\n                f\"({self.unit.to_generic()}). \"\n            ) from None\n        except UnitConversionError as exc:\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self});\", exc\n            ) from None\n        return self.value &lt;= prop.value\n\n    def __str__(self) -&gt; str:\n        return f\"{self.value} {self.unit}\"\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Property: {str(self)}&gt;\"\n\n    def _converter(self) -&gt; Type[UnitConverter]:\n        \"\"\"\n        Raises `UndefinedConverter` if a converter is not defined.\n        \"\"\"\n        if self.unit_converter is None:\n            self.unit_converter = self._get_converter()\n        return self.unit_converter\n\n    def _get_converter(self) -&gt; Type[UnitConverter]:\n        \"\"\"\n        Raises `UndefinedConverter` if a converter is not defined.\n        \"\"\"\n        return get_converter(self.unit.to_generic())\n\n    def _validate_comparison_input(self, other) -&gt; None:\n        \"\"\"\n        Raises `PropertyBinaryOperationError` if other is not a Property or if it does\n        not have the same unit type as this Property.\n        \"\"\"\n        if not isinstance(other, Property):\n            raise PropertyBinaryOperationError(\n                f\"cannot compare {other} to ({self}); {other} is not a Property; \"\n                \"only properties can be compared to properties. \"\n            )\n        if not self.unit.isinstance(other.unit.to_generic()):\n            raise PropertyBinaryOperationError(\n                f\"cannot compare ({other}) to ({self}); \"\n                f\"({other}) must have ({self.unit.to_generic()}) units. \"\n            )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__add__","title":"<code>__add__(other)</code>","text":"<p>Defines addition between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n&gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; x1 + x2\n&lt;Property: 20 m&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __add__(self, other) -&gt; Self:\n    \"\"\"\n    Defines addition between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n        &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; x1 + x2\n        &lt;Property: 20 m&gt;\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        raise PropertyBinaryOperationError(\n            f\"cannot add {other} to ({self}); {other} is not a {self.__class__}; \"\n            \"only same properties can be added to each other. \"\n        )\n    if not self.unit.isinstance(other.unit.to_generic()):\n        raise PropertyBinaryOperationError(\n            f\"cannot add ({other}) to ({self}); \"\n            f\"({other}) must have ({self.unit.to_generic()}) units. \"\n        )\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot add ({other}) to ({self}); ({other}) does not have the same \"\n            f\"units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot add ({other}) to ({self});\", exc\n        ) from None\n    return self.__class__(self.value + prop.value, self.unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Defines equality between properties. Prefer Property.eq instead.The equality operator returns False even for very small differences between floating point values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n&gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; L1 == L2\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n&gt;&gt;&gt; L2 == L3\nFalse\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Defines equality between properties.\n    Prefer Property.eq instead.The equality operator returns False even for very\n    small differences between floating point values.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n        &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; L1 == L2\n        True\n\n        &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n        &gt;&gt;&gt; L2 == L3\n        False\n    \"\"\"\n    if not isinstance(other, Property):\n        return False\n    if not self.unit.isinstance(other.unit.to_generic()):\n        return False\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUtilsException as exc:\n        raise PropertyBinaryOperationError(\n            f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n            exc,\n        ) from None\n    return self.value == prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(212, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &gt;= T2\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __ge__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(212, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &gt;= T2\n        True\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &gt;= prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &gt; T2\nFalse\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __gt__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &gt; T2\n        False\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &gt; prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__le__","title":"<code>__le__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &lt;= T2\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __le__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &lt;= T2\n        True\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &lt;= prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Defines comparison between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n&gt;&gt;&gt; T1 &lt; T2\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __lt__(self, other) -&gt; bool:\n    \"\"\"\n    Defines comparison between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T1 = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T2 = Property(213, RelativeTemperatureUnit.FAHRENHEIT)\n        &gt;&gt;&gt; T1 &lt; T2\n        True\n    \"\"\"\n    self._validate_comparison_input(other)\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot compare ({other}) to ({self});\", exc\n        ) from None\n    return self.value &lt; prop.value\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Defines multiplication between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; 2*T\n&lt;Property: 600 K&gt;\n&gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n&gt;&gt;&gt; T * A\n&lt;Property: 3000 (m^2) * K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __mul__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines multiplication between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; 2*T\n        &lt;Property: 600 K&gt;\n        &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n        &gt;&gt;&gt; T * A\n        &lt;Property: 3000 (m^2) * K&gt;\n    \"\"\"\n    if isinstance(other, (float, int)):\n        return Property(self.value * other, self.unit)\n    if isinstance(other, Property):\n        return Property(\n            self.value * other.value, (self.unit * other.unit).simplified()\n        )\n    raise PropertyBinaryOperationError(\n        f\"cannot multiply {self} with {other}; \"\n        \"second operand must be numeric or Property. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Defines inequality between properties. Prefer Property.eq instead.The inequality operator returns True even for very small differences between floating point values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n&gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; L1 != L2\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n&gt;&gt;&gt; L2 != L3\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __ne__(self, other) -&gt; bool:\n    \"\"\"\n    Defines inequality between properties.\n    Prefer Property.eq instead.The inequality operator returns True even for very\n    small differences between floating point values.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; L1 = Property(500, LengthUnit.CENTI_METER)\n        &gt;&gt;&gt; L2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; L1 != L2\n        False\n\n        &gt;&gt;&gt; L3 = Property(6, LengthUnit.METER)\n        &gt;&gt;&gt; L2 != L3\n        True\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__neg__","title":"<code>__neg__()</code>","text":"<p>Defines negation of properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T = Property(3, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; -T\n&lt;Property: -3 \u00b0C&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"\n    Defines negation of properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T = Property(3, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; -T\n        &lt;Property: -3 \u00b0C&gt;\n    \"\"\"\n    return self.__class__(-self.value, self.unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Defines exponentiation for properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; L = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; L**3\n&lt;Property: 125 (m^3)&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __pow__(self, power) -&gt; \"Property\":\n    \"\"\"\n    Defines exponentiation for properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; L = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; L**3\n        &lt;Property: 125 (m^3)&gt;\n    \"\"\"\n    if not isinstance(power, (float, int)):\n        raise PropertyExponentError(\n            f\"invalid exponent: {power}; expected numeric. \"\n        )\n    return Property(self.value**power, self.unit**power)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Defines right addition between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import LengthUnit\n&gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n&gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n&gt;&gt;&gt; x1 + x2\n&lt;Property: 20 m&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __radd__(self, other) -&gt; Self:\n    \"\"\"\n    Defines right addition between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import LengthUnit\n        &gt;&gt;&gt; x1 = Property(15, LengthUnit.METER)\n        &gt;&gt;&gt; x2 = Property(5, LengthUnit.METER)\n        &gt;&gt;&gt; x1 + x2\n        &lt;Property: 20 m&gt;\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__rmul__","title":"<code>__rmul__(other)</code>","text":"<p>Defines multiplication between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; 2*T\n&lt;Property: 600 K&gt;\n&gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n&gt;&gt;&gt; T * A\n&lt;Property: 3000 (m^2) * K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __rmul__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines multiplication between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T = Property(300, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; 2*T\n        &lt;Property: 600 K&gt;\n        &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n        &gt;&gt;&gt; T * A\n        &lt;Property: 3000 (m^2) * K&gt;\n    \"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__rsub__","title":"<code>__rsub__(other)</code>","text":"<p>Defines right subtraction between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import TimeUnit\n&gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n&gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n&gt;&gt;&gt; t1 - t2\n&lt;Property: 1.0 min&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __rsub__(self, other) -&gt; Self:\n    \"\"\"\n    Defines right subtraction between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n        &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n        &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n        &gt;&gt;&gt; t1 - t2\n        &lt;Property: 1.0 min&gt;\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract {self} from ({other}); {other} is not a \"\n            f\"{self.__class__}; only same properties can be subtracted from each \"\n            \"other. \"\n        )\n    if not self.unit.isinstance(other.unit.to_generic()):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({self}) from ({other}); \"\n            f\"({other}) must have ({self.unit.to_generic()}) units. \"\n        )\n    return other.__add__(-self)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__rtruediv__","title":"<code>__rtruediv__(other)</code>","text":"<p>Defines right division between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit\n&gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; 100/T\n&lt;Property: 0.2  / K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __rtruediv__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines right division between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit\n        &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; 100/T\n        &lt;Property: 0.2  / K&gt;\n    \"\"\"\n    if isinstance(other, (float, int)):\n        try:\n            value = other / self.value\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator is zero. \"\n            ) from None\n        return Property(value, self.unit.inverse())\n    if isinstance(other, Property):\n        try:\n            value = other.value / self.value\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator's value is zero. \"\n            ) from None\n        return Property(value, (other.unit / self.unit).simplified())\n    raise PropertyBinaryOperationError(\n        f\"cannot divide {self} with {other}; \"\n        \"numerator must be numeric or Property. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Defines subtraction between properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import TimeUnit\n&gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n&gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n&gt;&gt;&gt; t1 - t2\n&lt;Property: 1.0 min&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __sub__(self, other) -&gt; Self:\n    \"\"\"\n    Defines subtraction between properties.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import TimeUnit\n        &gt;&gt;&gt; t1 = Property(2, TimeUnit.MINUTE)\n        &gt;&gt;&gt; t2 = Property(60, TimeUnit.SECOND)\n        &gt;&gt;&gt; t1 - t2\n        &lt;Property: 1.0 min&gt;\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract {other} from ({self}); {other} is not a \"\n            f\"{self.__class__}; only same properties can be subtracted from each \"\n            \"other. \"\n        )\n    if not self.unit.isinstance(other.unit.to_generic()):\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({other}) from ({self}); \"\n            f\"({other}) must have ({self.unit.to_generic()}) units. \"\n        )\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUnitConversionError:\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({other}) from ({self}); ({other}) does not have the \"\n            f\"same units as ({self}) and there is no unit converter registered for \"\n            f\"({self.unit.to_generic()}). \"\n        ) from None\n    except UnitConversionError as exc:\n        raise PropertyBinaryOperationError(\n            f\"cannot subtract ({other}) from ({self});\", exc\n        ) from None\n    return self.__class__(self.value - prop.value, self.unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Defines division between properties and numerics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; T/2\n&lt;Property: 250.0 K&gt;\n&gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n&gt;&gt;&gt; T / A\n&lt;Property: 50.0 K / (m^2)&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def __truediv__(self, other) -&gt; \"Property\":\n    \"\"\"\n    Defines division between properties and numerics.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T = Property(500, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; T/2\n        &lt;Property: 250.0 K&gt;\n        &gt;&gt;&gt; A = Property(10, LengthUnit.METER**2)\n        &gt;&gt;&gt; T / A\n        &lt;Property: 50.0 K / (m^2)&gt;\n    \"\"\"\n    if isinstance(other, (float, int)):\n        try:\n            value = self.value / other\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator is zero. \"\n            ) from None\n        return Property(value, self.unit)\n    if isinstance(other, Property):\n        try:\n            value = self.value / other.value\n        except ZeroDivisionError:\n            raise PropertyBinaryOperationError(\n                f\"cannot divide {self} with {other}; denominator's value is zero. \"\n            ) from None\n        return Property(value, (self.unit / other.unit).simplified())\n    raise PropertyBinaryOperationError(\n        f\"cannot divide {self} with {other}; \"\n        \"denominator must be numeric or Property. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.eq","title":"<code>eq(other, *, rel_tol=1e-09, abs_tol=0)</code>","text":"<p>Perform equality comparison between this and some other Property. This method of testing equality is preferable to the equality operator '==' because float point tolerance is taken into account.</p> <p>rel_tol is the maximum difference for being considered \"close\", relative to the magnitude of the input values. abs_tol is the maximum difference for being considered \"close\", regardless of the magnitude of the input values. For the values to be considered close, the difference between them must be smaller than at least one of the tolerances.</p> <p>Raises <code>PropertyBinaryOperationError</code> if an error occurs during conversion of other's units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n&gt;&gt;&gt; T1 = Property(33.333333, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; T2 = Property(100/3, AbsoluteTemperatureUnit.KELVIN)\n&gt;&gt;&gt; T1 == T2\nFalse\n&gt;&gt;&gt; T1.eq(T2)\nFalse\n&gt;&gt;&gt; T1.eq(T2, rel_tol=0.1)\nTrue\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def eq(self, other: \"Property\", *, rel_tol=1e-9, abs_tol=0) -&gt; bool:\n    \"\"\"\n    Perform equality comparison between this and some other Property. This method\n    of testing equality is preferable to the equality operator '==' because float\n    point tolerance is taken into account.\n\n    rel_tol is the maximum difference for being considered \"close\", relative\n    to the magnitude of the input values.\n    abs_tol is the maximum difference for being considered \"close\", regardless of\n    the magnitude of the input values.\n    For the values to be considered close, the difference between them must be\n    smaller than at least one of the tolerances.\n\n    Raises `PropertyBinaryOperationError` if an error occurs during conversion\n    of other's units.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import AbsoluteTemperatureUnit, LengthUnit\n        &gt;&gt;&gt; T1 = Property(33.333333, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; T2 = Property(100/3, AbsoluteTemperatureUnit.KELVIN)\n        &gt;&gt;&gt; T1 == T2\n        False\n        &gt;&gt;&gt; T1.eq(T2)\n        False\n        &gt;&gt;&gt; T1.eq(T2, rel_tol=0.1)\n        True\n    \"\"\"\n    if not isinstance(other, Property):\n        return False\n    if not self.unit.isinstance(other.unit.to_generic()):\n        return False\n    try:\n        prop = other.to_unit(self.unit) if self.unit != other.unit else other\n    except PropertyUtilsException as exc:\n        raise PropertyBinaryOperationError(\n            f\"during conversion of {other} to ({self.unit}) units an error occured: \",\n            exc,\n        ) from None\n    return isclose(self.value, prop.value, rel_tol=rel_tol, abs_tol=abs_tol)\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.to_si","title":"<code>to_si()</code>","text":"<p>Create a new property with SI units.</p> <p>Raises <code>ImpossiblePropertyUnitConverion</code> if there is no converter registered for the unit.</p> <p>Raises <code>InvalidUnitConversion</code> if any error occurs in the unit conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T.to_si()\n&lt;Property: 373.15 K&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def to_si(self) -&gt; Self:\n    \"\"\"\n    Create a new property with SI units.\n\n    Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n    for the unit.\n\n    Raises `InvalidUnitConversion` if any error occurs in the unit conversion.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T.to_si()\n        &lt;Property: 373.15 K&gt;\n    \"\"\"\n    if isinstance(self.unit, MeasurementUnit):\n        return self.to_unit(self.unit.si())\n    if isinstance(self.unit, Dimension):\n        return self.to_unit(self.unit.unit.si() ** self.unit.power)\n    if isinstance(self.unit, CompositeDimension):\n        return self.to_unit(self.unit.to_generic().to_si())\n    raise PropertyValidationError(\n        f\"cannot convert Property to SI; 'unit' is invalid: {self.unit}. \"\n    )\n</code></pre>"},{"location":"property/#property_utils.properties.property.Property.to_unit","title":"<code>to_unit(unit)</code>","text":"<p>Create a new property with specified unit.</p> <p>Raises <code>PropertyUnitConversionError</code> if the unit is not of the same type.</p> <p>Raises <code>ImpossiblePropertyUnitConverion</code> if there is no converter registered for the unit.</p> <p>Raises <code>UnitConversionError</code> if any error occurs in the unit conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n&gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n&gt;&gt;&gt; T.to_unit(RelativeTemperatureUnit.FAHRENHEIT)\n&lt;Property: 212.0 \u00b0F&gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def to_unit(self, unit: UnitDescriptor) -&gt; Self:\n    \"\"\"\n    Create a new property with specified unit.\n\n    Raises `PropertyUnitConversionError` if the unit is not of the same type.\n\n    Raises `ImpossiblePropertyUnitConverion` if there is no converter registered\n    for the unit.\n\n    Raises `UnitConversionError` if any error occurs in the unit conversion.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units.units import RelativeTemperatureUnit\n        &gt;&gt;&gt; T = Property(100, RelativeTemperatureUnit.CELCIUS)\n        &gt;&gt;&gt; T.to_unit(RelativeTemperatureUnit.FAHRENHEIT)\n        &lt;Property: 212.0 \u00b0F&gt;\n    \"\"\"\n    if not unit.isinstance(self.unit.to_generic()):\n        raise PropertyUnitConversionError(\n            f\"cannot convert {self} to ({unit}) units; 'unit' should be an instance\"\n            f\" of {self.unit.to_generic()}. \"\n        )\n    try:\n        converter = self._converter()\n    except UndefinedConverterError:\n        raise PropertyUnitConversionError(\n            f\"cannot convert property {self} to units: {unit}; no unit converter \"\n            f\" found for {unit.to_generic()}. \"\n            \"Did you forget to @register_converter? \"\n        ) from None\n    try:\n        value = converter.convert(self.value, self.unit, unit)\n    except UnitConversionError as exc:\n        raise exc from None\n    return self.__class__(value=value, unit=unit)\n</code></pre>"},{"location":"property/#property_utils.properties.property.p","title":"<code>p(value, unit=NonDimensionalUnit.NON_DIMENSIONAL)</code>","text":"<p>Create a property with a value and a unit. Default unit is non-dimensional, i.e. no unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from property_utils.units import KELVIN\n&gt;&gt;&gt; p(350, KELVIN)\n&lt;Property: 350 K&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; p(20.23)\n&lt;Property: 20.23 &gt;\n</code></pre> Source code in <code>src/property_utils/properties/property.py</code> <pre><code>def p(\n    value: float, unit: UnitDescriptor = NonDimensionalUnit.NON_DIMENSIONAL\n) -&gt; \"Property\":\n    \"\"\"\n    Create a property with a value and a unit.\n    Default unit is non-dimensional, i.e. no unit.\n\n    Examples:\n        &gt;&gt;&gt; from property_utils.units import KELVIN\n        &gt;&gt;&gt; p(350, KELVIN)\n        &lt;Property: 350 K&gt;\n\n        &gt;&gt;&gt; p(20.23)\n        &lt;Property: 20.23 &gt;\n    \"\"\"\n    return Property(value, unit)\n</code></pre>"},{"location":"units/","title":"units","text":""},{"location":"units/#property_utils.units.units.NonDimensionalUnit","title":"<code>NonDimensionalUnit</code>","text":"<p>             Bases: <code>MeasurementUnit</code></p> <p>This enum is used to denote physical quantities that do not have a unit of measurement.</p> Source code in <code>src/property_utils/units/units.py</code> <pre><code>class NonDimensionalUnit(MeasurementUnit):\n    \"\"\"\n    This enum is used to denote physical quantities that do not have a unit of\n    measurement.\n    \"\"\"\n\n    NON_DIMENSIONAL = \"\"\n\n    @classmethod\n    def si(cls) -&gt; \"NonDimensionalUnit\":\n        return cls.NON_DIMENSIONAL\n</code></pre>"}]}